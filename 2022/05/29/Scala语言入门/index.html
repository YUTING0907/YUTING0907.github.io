

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_yt.png">
  <link rel="icon" href="/img/favicon_yt.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Echo Yu">
  <meta name="keywords" content="ML">
  
    <meta name="description" content="Scala语言入门Scala（发音为&#x2F;ˈskɑːlə, ˈskeɪlə&#x2F;）是一门多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。洛桑联邦理工学院的Martin Odersky于2001年基于Funnel的工作开始设计Scala。Java平台的Scala于2003年底&#x2F;2004年初发布。 特点：  同样运行在JVM上，可以与现存程序同时运行。 可直">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala语言入门">
<meta property="og:url" content="http://yuting0907.github.io/2022/05/29/Scala%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="YUTING">
<meta property="og:description" content="Scala语言入门Scala（发音为&#x2F;ˈskɑːlə, ˈskeɪlə&#x2F;）是一门多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。洛桑联邦理工学院的Martin Odersky于2001年基于Funnel的工作开始设计Scala。Java平台的Scala于2003年底&#x2F;2004年初发布。 特点：  同样运行在JVM上，可以与现存程序同时运行。 可直">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_implicit_datatype_cast.jpeg">
<meta property="og:image" content="https://github.com/tch0/notes/raw/master/Images/Scala_immutable_collections_tree.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_mutable_collections_tree.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_sbt_dsl_setting_expression.png">
<meta property="article:published_time" content="2022-05-29T03:14:24.000Z">
<meta property="article:modified_time" content="2024-12-19T02:17:19.836Z">
<meta property="article:author" content="Echo Yu">
<meta property="article:tag" content="Scala">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_implicit_datatype_cast.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Scala语言入门 - YUTING</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/reward.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yuting0907.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>EchoYu&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Scala语言入门"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Echo Yu
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-29 11:14" pubdate>
          2022年5月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          76k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          638 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Scala语言入门</h1>
            
            <div class="markdown-body">
              
              <div id="readmore-container"><h1 id="Scala语言入门"><a href="#Scala语言入门" class="headerlink" title="Scala语言入门"></a>Scala语言入门</h1><p>Scala（发音为&#x2F;ˈskɑːlə, ˈskeɪlə&#x2F;）是一门多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。洛桑联邦理工学院的Martin Odersky于2001年基于Funnel的工作开始设计Scala。Java平台的Scala于2003年底&#x2F;2004年初发布。</p>
<p>特点：</p>
<ul>
<li>同样运行在JVM上，可以与现存程序同时运行。</li>
<li>可直接使用Java类库。</li>
<li>同Java一样静态类型。</li>
<li>语法和Java类似，比Java更加简洁（简洁而并不是简单），表达性更强。</li>
<li>同时支持面向对象、函数式编程。</li>
<li>比Java更面向对象。</li>
</ul>
<p>关注点：</p>
<ul>
<li>类型推断、不变量、函数式编程、高级程序构造。</li>
<li>并发：actor模型。</li>
<li>和现有Java代码交互、相比Java异同和优缺。</li>
</ul>
<p>和Java关系：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">        javac               java<br><span class="hljs-string">.java</span> <span class="hljs-params">--------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br><span class="hljs-string">.scala</span> <span class="hljs-params">-------</span>&gt; <span class="hljs-string">.class</span> <span class="hljs-params">----------</span>&gt; run on JVM<br>        scalac              scala<br></code></pre></td></tr></table></figure>

<p>测试代码：<a target="_blank" rel="noopener" href="https://github.com/tch0/notes/tree/Scala">Scala分支</a> </p>
<p>等待替换repo，还没手敲</p>
<p>阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xh411S7bP">尚硅谷大数据技术之Scala入门到精通教程</a>（本文参考）</li>
<li><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/zh-cn/cheatsheets/index.html">Scala官网语法速查</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/zh-cn/tour/tour-of-scala.html">Scala官方文档 Tour Of Scala</a></li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>Scala需要依赖Java，访问<a target="_blank" rel="noopener" href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">这里</a>查看特定Scala版本依赖的Java版本。这里选择，最新的JDK17配合Scala2.13.6。</p>
<p>Windows中下载安装配置环境变量：</p>
<ul>
<li>类似于java配置<code>SCALA_HOME</code>为安装目录。</li>
<li>添加<code>%SCALA_HOME%\bin</code>到path环境变量。</li>
</ul>
<p>Linux中类似，可以使用包管理器，但如果依赖版本不严格一致的话，需要官网下载对应版本安装即可。</p>
<p>也有交互式执行环境：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scala</span><br></code></pre></td></tr></table></figure>

<p>交互式执行环境中的传统艺能：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;hello,world!&quot;</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>暂时不管项目配置，还是单文件编译执行为主，项目开发肯定要以包的形式组织可以使用IntelliJ IDEA开发，使用maven或者sbt进行项目配置。</p>
<p>使用VSCode编辑器，安装插件Scala Syntax (official)和Scala (Mentals)。</p>
<p>新建文件<code>HelloScala.scala</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">object</span> HelloScala &#123; // HelloScala is <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">object</span>, not <span class="hljs-selector-tag">a</span> class, will create <span class="hljs-selector-tag">a</span> <br>    def <span class="hljs-selector-tag">main</span>(args : Array[String]) : Unit = &#123;<br>        println(&quot;hello,world!&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以使用插件CodeRunner直接快捷键运行。也可以在命令行编译为字节码后再运行：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scalac </span>HelloScala.<span class="hljs-keyword">scala</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scala </span>helloScala<br></code></pre></td></tr></table></figure>

<p>或者直接运行scala源文件：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">scala</span> HelloScala.<span class="hljs-keyword">scala</span><br></code></pre></td></tr></table></figure>

<p>和java如出一辙。</p>
<p>如果编译的话会生成2个<code>.class</code>字节码文件，<code>HelloScala.class</code>和<code>HelloScala$.class</code>。都是字节码但是不能通过<code>java</code>直接运行。但对于HelloWorld这个例子来说，java源代码编译而成的字节码是可以通过<code>scala</code>命令运行的。</p>
<p>原因是没有引入Scala的库，添加<code>classpath</code>就可以通过java执行scala编译成的字节码了：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">java -cp %SCALA_HOME%<span class="hljs-regexp">/lib/</span>scala-library.jar; HelloScala<br></code></pre></td></tr></table></figure>

<p>使用<a target="_blank" rel="noopener" href="http://java-decompiler.github.io/">Java Decompiler</a>反编译字节码到java源文件可以看到引入Scala库的逻辑。并且：</p>
<ul>
<li>scala源文件中的<code>HelloScala</code>对象编译后成为了一个类，但对象本身编译后就是生成的另一个类<code>HelloScala$</code>类的单例对象<code>HelloScala$.MODULE$</code>，称之为伴生对象。</li>
<li><code>HelloScala$</code>有一个<code>main</code>实例方法，<code>HelloScala</code>类的静态方法通过这个单例对象转调这个实例方法。完成打印。</li>
<li>Scala比Java更面向对象。</li>
</ul>
<h2 id="IDEA环境配置"><a href="#IDEA环境配置" class="headerlink" title="IDEA环境配置"></a>IDEA环境配置</h2><p>使用IntelliJ IDEA：</p>
<ul>
<li><p>创建Maven项目，JDK版本17。</p>
</li>
<li><p>安装插件：Scala。在IDEA里Preferences&#x2F;Plugins安装scala插件，在线下载慢的话，可以去jerkins官网下载插件到本地然后from disk安装 。</p>
</li>
<li><p>Maven项目默认用Java写，在<code>main/</code>目录下新建目录<code>scala/</code>，文件夹上右击Mark directory as, 然后将目录标记为Source Root。</p>
</li>
<li><p>这样甚至可以在同一个项目中混用Scala和Java源文件，并互相调用。</p>
</li>
<li><p>需要能够添加scala源文件，右键项目，添加框架支持(Add Framworks Support)，配置Scala SDK，选择，然后就可以右键添加Scala源文件了。</p>
<p>⚠️注意：到这里如果new文件还没出现scala class</p>
<p>🍬尝试解决方案：</p>
<p>  在项目的目录下，找到.idea文件下，再从里面找到modules文件夹，里面有个以.iml为后缀的文件，打开它，新增下面这段代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml">新增下面这段代码，name指的是你自己安装的scala版本，最后你再右键的时候可以发现能new出来一个Scala文件啦<br><span class="hljs-tag">&lt;<span class="hljs-name">orderEntry</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;library&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;scala-sdk-2.13.0&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;application&quot;</span> /&gt;</span><br><br>以下是整个.iml为后缀文件的参考案例：<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span> <span class="hljs-attr">org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JAVA_MODULE&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NewModuleRootManager&quot;</span> <span class="hljs-attr">LANGUAGE_LEVEL</span>=<span class="hljs-string">&quot;JDK_1_5&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/target/classes&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">output-test</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/target/test-classes&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">sourceFolder</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/java&quot;</span> <span class="hljs-attr">isTestSource</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">sourceFolder</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/resources&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java-resource&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">sourceFolder</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/main/scala&quot;</span> <span class="hljs-attr">isTestSource</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">sourceFolder</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/src/test/java&quot;</span> <span class="hljs-attr">isTestSource</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">excludeFolder</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file://$MODULE_DIR$/target&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">orderEntry</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jdk&quot;</span> <span class="hljs-attr">jdkName</span>=<span class="hljs-string">&quot;1.8&quot;</span> <span class="hljs-attr">jdkType</span>=<span class="hljs-string">&quot;JavaSDK&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">orderEntry</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;sourceFolder&quot;</span> <span class="hljs-attr">forTests</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">orderEntry</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;library&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;scala-sdk-2.12.10&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;application&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加包，添加Scala类，选择对象，编辑源码。</p>
</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> VeryStarted<br><br>object HelloWorld &#123;<br>  def <span class="hljs-title function_">main</span>(args: <span class="hljs-built_in">Array</span>[<span class="hljs-built_in">String</span>]): Unit= &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello,world!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Ctrl + Shift + F10运行。</li>
<li>可以看到执行的命令是<code>java</code>在<code>classpath</code>中引入了Scala的<code>jar</code>包形式的库。</li>
<li>调用java的类库：</li>
</ul>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">package VeryStarted<br><br>object HelloWorld &#123;<br>  def mai<span class="hljs-meta">n</span>(args: <span class="hljs-keyword">Array</span>[String]): Unit= &#123;<br>    printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;Hello,world!&quot;</span>)<br>    System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;Hello,world! from java&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>语法含义：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">object</span> SingletonObject &#123; <span class="hljs-selector-tag">body</span> &#125;<br>def MethodName(ArgName: ArgType): RetType = &#123; <span class="hljs-selector-tag">body</span> &#125;<br></code></pre></td></tr></table></figure>

<p><code>object</code>关键字创建的伴生对象，可以理解为替代Java的<code>static</code>关键字的方式，将静态方法用单例对象的实例方法做了替代，做到了更纯粹的面向对象。</p>
<p>仅仅测试理解语法既可以单文件编写VSCode编译执行也可以用IDEA管理项目，影响不大。</p>
<p>再用一个等价的类定义来认识和区别一下Scala和Java：</p>
<p>java:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> school = <span class="hljs-string">&quot;XDU&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-title class_">Integer</span> age) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">printInfo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-title class_">Student</span>.<span class="hljs-property">school</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// psvm</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Student</span> tch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tch&quot;</span>, <span class="hljs-number">20</span>);<br>        tch.<span class="hljs-title function_">printInfo</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>scala:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package VeryStarted<br><br><span class="hljs-keyword">class</span> <span class="hljs-constructor">Student(<span class="hljs-params">name</span>: String, <span class="hljs-params">age</span>: Int)</span> &#123;<br>  def print<span class="hljs-constructor">Info()</span>: Unit = &#123;<br>    println(name + <span class="hljs-string">&quot; &quot;</span> + age + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span>school)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 引入伴生对象，名称一致，同一个文件</span><br><span class="hljs-keyword">object</span> Student &#123;<br>  <span class="hljs-keyword">val</span> school: String = <span class="hljs-string">&quot;XDU&quot;</span><br><br>  def main(args: Array<span class="hljs-literal">[S<span class="hljs-identifier">tring</span>]</span>): Unit = &#123;<br>    <span class="hljs-keyword">val</span> tch = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Student(<span class="hljs-string">&quot;tch&quot;</span>, 20)</span><br>    tch.print<span class="hljs-constructor">Info()</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Scala库源码与API文档：</p>
<ul>
<li>官网上下载下载Scala源码，解压到Scala安装目录或任意位置。</li>
<li>IntelliJ IDEA进入反编译的源码后选择右上角附加源码，选择源码的<code>src/</code>目录。</li>
<li>安装包里面已经有了文档，没有的话可以单独下载。</li>
<li>Scala依赖Java，某些类型就是Java的包装，库中有一部分java源码。</li>
</ul>
<h2 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h2><p>注释：</p>
<ul>
<li>和java一样</li>
<li><code>//</code> 单行</li>
<li><code>/* */</code> 多行</li>
<li><code>/** */</code> 文档，方法或者类前面，便于<code>scaladoc</code>生成文档。</li>
</ul>
<p>变量和常量：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> [:VariableType] = value <span class="hljs-comment">// variable</span><br>val <span class="hljs-keyword">name</span> [:ConstantType] = value <span class="hljs-comment">// constant</span><br></code></pre></td></tr></table></figure>

<p>因为Scala的函数式编程要素，所以一个指导意见就是能用常量就不要用变量。</p>
<ul>
<li>声明变量时，类型可以省略，编译器会自动推导。</li>
<li>静态类型，类型经过给定或推导确定后就不能修改。</li>
<li>变量和常量声明时，必须有初始值。</li>
<li>变量可变，常量不可变。</li>
<li>引用类型常量，不能改变常量指向的对象，可以改变对象的字段。</li>
<li>不以<code>;</code>作为语句结尾，scala编译器自动识别语句结尾。</li>
</ul>
<p>标识符命名规范：</p>
<ul>
<li>字母下划线开头，后跟字母数字下划线，和C&#x2F;C++&#x2F;Java一样。</li>
<li>操作符开头，且只包含(+-*&#x2F;#!等)，也是有效的标识符。这样用会用什么奇怪的好处吗？答案是灵活到天顶星的运算符重载。</li>
<li>用反引号包括的任意字符串，即使是同39个Scala关键字同名也可以。有点奇怪的用法，尚不知道为什么。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _abc:String = <span class="hljs-string">&quot;hello&quot;</span><br>val -+/%# = <span class="hljs-number">10</span><br>val <span class="hljs-string">`if`</span> = <span class="hljs-number">10</span><br><span class="hljs-built_in">println</span>(_abc)<br><span class="hljs-built_in">println</span>(-+/%#)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">`if`</span>)<br></code></pre></td></tr></table></figure>

<p>关键字：</p>
<ul>
<li><code>package import class obejct trait extends with type for</code></li>
<li><code>private protected abstract sealed final implicit lazy override</code></li>
<li><code>try catch finlly throw</code></li>
<li><code>if else match case do while for return yield</code></li>
<li><code>def var val</code></li>
<li><code>this super</code></li>
<li><code>new</code></li>
<li><code>true false null</code></li>
<li>其中Java没有的关键字：<code>object trait with implicit match yield def val var</code></li>
</ul>
<p>字符串：</p>
<ul>
<li>类型：<code>String</code></li>
<li><code>+</code>号连接</li>
<li><code>*</code>字符串乘法，复制一个字符串多次</li>
<li><code>printf</code>格式化输出</li>
<li>字符串插值：<code>s&quot;xxx$&#123;varname&#125;&quot;</code>前缀<code>s</code>模板字符串，前缀<code>f</code>格式化模板字符串，通过<code>$</code>获取变量值，<code>%</code>后跟格式化字符串。</li>
<li>原始字符串：<code>raw&quot;rawstringcontents$&#123;var&#125;&quot;</code>，不会考虑后跟的格式化字符串。</li>
<li>多行字符串：<code>&quot;&quot;&quot; &quot;&quot;&quot;</code>。</li>
<li>输出：<code>print printf println ...</code></li>
</ul>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pony"><span class="hljs-meta">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Pyrrha&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-string">&quot;Nikos&quot;</span><br><span class="hljs-meta">val</span> age = <span class="hljs-number">17</span><br>println((name + <span class="hljs-string">&quot; &quot;</span>) * <span class="hljs-number">3</span>)<br>printf(<span class="hljs-string">&quot;%s : dead in %d\n&quot;</span>, name, age)<br>print(s<span class="hljs-string">&quot;$name : dead in $&#123;age&#125;&quot;</span>)<br><span class="hljs-meta">val</span> power = <span class="hljs-number">98.9072</span><br>println(f<span class="hljs-string">&quot; : power $&#123;power&#125;%.2f.&quot;</span>)<br><br><span class="hljs-keyword">var</span> sql = s<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    |Select *</span><br><span class="hljs-string">    |from </span><br><span class="hljs-string">    |   Student</span><br><span class="hljs-string">    |Where</span><br><span class="hljs-string">    |   name = $&#123;name&#125;</span><br><span class="hljs-string">    |and</span><br><span class="hljs-string">    |   age &gt;= $&#123;age&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>.stripMargin <span class="hljs-comment">// strip | and whitespaces before |</span><br>println(sql)<br></code></pre></td></tr></table></figure>

<p>输入：</p>
<ul>
<li><code>StdIn.readLine()</code></li>
<li><code>StdIn.readShort() StdIn.readDouble</code></li>
<li><code>import scala.io.StdIn</code></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;input name:&quot;</span>)</span></span><br>val name: String = StdIn<span class="hljs-selector-class">.readLine</span>()<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;input age:&quot;</span>)</span></span><br>val age:Int = StdIn<span class="hljs-selector-class">.readInt</span>()<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(name + <span class="hljs-string">&quot; : &quot;</span> + age)</span></span><br></code></pre></td></tr></table></figure>

<p>读写文件：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> scala.io.Source<br><span class="hljs-keyword">import</span> java.io.PrintWriter<br><span class="hljs-keyword">import</span> java.io.File<br><span class="hljs-keyword">object</span> FileIO &#123;<br>    def main(args: <span class="hljs-keyword">Array</span>[String]): Unit =&#123;<br>        // <span class="hljs-keyword">read</span> <span class="hljs-keyword">from</span> file<br>        Source.fromFile(&quot;FileIO.txt&quot;).<span class="hljs-keyword">foreach</span>(print)<br><br>        // <span class="hljs-keyword">write</span> <span class="hljs-keyword">to</span> file<br>        // <span class="hljs-keyword">call</span> java API <span class="hljs-keyword">to</span> <span class="hljs-keyword">write</span><br>        val writer = <span class="hljs-built_in">new</span> PrintWriter(<span class="hljs-built_in">new</span> File(&quot;WFile.txt&quot;))<br>        writer.<span class="hljs-keyword">write</span>(&quot;Nephren!&quot;)<br>        writer.<span class="hljs-keyword">close</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>数据类型：</p>
<ul>
<li>java基本类型<code>char byte short int long float double boolean</code>。</li>
<li>java基本类型对应包装类型：<code>Charater Byte Short Integer Long Float Double Boolean</code>。</li>
<li>java中不是纯粹的面向对象。</li>
<li>Scala吸取了这一点，所有数据都是对象，都是<code>Any</code>的子类。</li>
<li><code>Any</code>有两个子类：<code>AnyVal</code>值类型 <code>AnyRef</code>引用类型。</li>
<li>数值类型都是<code>AnyVal</code>子类，和Java数值包装类型都一样，只有整数在scala中是<code>Int</code>、字符是<code>Char</code>有点区别。</li>
<li><code>StringOps</code>是java中<code>String</code>类增强，<code>AnyVal</code>子类。</li>
<li><code>Unit</code>对应java中的<code>void</code>，<code>AnyVal</code>子类。用于方法返回值的位置，表示方法无返回值，<code>Unit</code>是一个类型，只有一个单例的对象，转成字符串打印出来为<code>()</code>。</li>
<li><code>Void</code>不是数据类型，只是一个关键字。</li>
<li><code>Null</code>是一个类型，只有一个单例对象<code>null</code>就是空引用，所有引用类型<code>AnyRef</code>的子类，这个类型主要用途是与其他JVM语言互操作，几乎不在Scala代码中使用。</li>
<li><code>Nothing</code>所有类型的子类型，也称为底部类型。它常见的用途是发出终止信号，例如抛出异常、程序退出或无限循环。</li>
</ul>
<p>整数类型：都是有符号整数，标准补码表示。</p>
<ul>
<li><code>Byte</code> 1字节</li>
<li><code>Short</code> 2字节</li>
<li><code>Int</code> 4字节</li>
<li><code>Long</code> 8字节</li>
<li>整数赋初值超出表示范围报错。</li>
<li>自动类型推断，整数字面值默认类型<code>Int</code>，长整型字面值必须加<code>L</code>后缀表示。</li>
<li>直接向下转换会失败，需要使用强制类型转换，<code>(a + 10).toByte</code>。</li>
</ul>
<p>浮点类型：</p>
<ul>
<li><code>Float</code> IEEE 754 32位浮点数</li>
<li><code>Double</code> IEEE 754 64位浮点数</li>
<li>字面值默认<code>Double</code></li>
</ul>
<p>字符类型：</p>
<ul>
<li>同java的<code>Character</code>，2字节，UTF-16编码的字符。</li>
<li>字符常量：<code>&#39;&#39;</code></li>
<li>类型<code>Char</code></li>
<li>转义：<code>\t \n \r \\ \&quot; \&#39;</code>etc</li>
</ul>
<p>布尔类型：<code>true false</code></p>
<p>空类型：</p>
<ul>
<li><code>Unit</code> 无值，只有一个实例，用于函数返回值。</li>
<li><code>Null</code> 只有一个实例<code>null</code>，空引用。</li>
<li><code>Nothing</code> 确定没有正常的返回值，可以用Nothing来指定返回值类型。好像意思是抛异常时返回Nothing，不是特别懂。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">object NullType &#123;<br>    <span class="hljs-function">def <span class="hljs-title">main</span><span class="hljs-params">(arg : Array[<span class="hljs-type">String</span>])</span> : Unit =</span> &#123;<br>        <span class="hljs-comment">// Unit</span><br>        <span class="hljs-function">def <span class="hljs-title">f1</span><span class="hljs-params">()</span>: Unit =</span> &#123;<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;just nothing!&quot;</span>)<br>        &#125;<br>        val a = <span class="hljs-built_in">f1</span>()<br>        <span class="hljs-built_in">println</span>(a) <span class="hljs-comment">// ()</span><br><br>        <span class="hljs-comment">// null only used for AnyRef</span><br>        <span class="hljs-comment">// val n:Int = null // invalid</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>数据类型转换：</p>
<ul>
<li><p>自动类型提升：多种数据类型混合运算，自动提升到精度最大的数据类型。</p>
</li>
<li><p>高精度赋值到低精度，直接报错。</p>
</li>
<li><p>除了图中的隐式类型转换，都需要强制类型转换。</p>
</li>
<li><p><code>Byte Short Char</code>计算时会直接提升为<code>Int</code>。</p>
</li>
<li><p><code>Boolean</code>不能参与整数浮点运算，不能隐式转换为整数。</p>
<p><img src="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_implicit_datatype_cast.jpeg" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p>强制类型转换：</p>
<ul>
<li><code>toByte toInt toChar toXXXX</code></li>
<li><code>&#39;a&#39;.toInt</code> <code>2.7.toInt</code></li>
<li>数值与String的转换：<code>&quot;&quot; + n</code> <code>&quot;100&quot;.toInt</code> <code>&quot;12.3&quot;.toFloat</code> <code>12.3&quot;.toDouble.toInt</code></li>
<li>整数强转是二进制截取，整数高精度转低精度可能会溢出，比如<code>128.toByte</code>。</li>
</ul>
<p>Scala标准库：</p>
<ul>
<li><code>Int</code> <code>Double</code>这些数据类型对应于Java中的原始数据类型，在底层的运行时不是一个对象，但Scala提供了从这些类型到<code>scala.runtime.RichInt/RichDouble/...</code>的（低优先级）隐式类型转换（在<code>Perdef</code>中定义），从而提供了非原始类型具有的对象操作。</li>
<li>基本类型都是默认导入的，不需要显式导入，位于包<code>scala</code>中。还有<code>scala.Predef</code>对象也是自动导入。</li>
<li>其他需要导入的包：<ul>
<li><code>scala.collection</code>集合。</li>
<li><code>scala.collection.immutable</code>不可变数据结构，比如数组、列表、范围、哈希表、哈希集合。</li>
<li><code>scala.collection.mutable</code>可变数据结构，数组缓冲、字符串构建器、哈希表、哈希集合。</li>
<li><code>scala.collection.concurrent</code>可变并发数据结构，比如字典树。</li>
</ul>
</li>
<li><code>scala.concurrent</code>原始的并发编程。</li>
<li><code>scala.io</code>输入输出。</li>
<li><code>scala.math</code>基本数学操作。</li>
<li><code>scala.sys</code>操作系统交互。</li>
<li><code>scala.util.matching</code>正则。</li>
<li>标准库中的其他部分被放在独立的分开的库中。可能需要单独安装，包括：</li>
<li><code>scala.reflect</code>反射API。</li>
<li><code>scala.xml</code>xml解析、操作、序列化。</li>
<li><code>scala.collection.parallel</code>并行集合。</li>
<li><code>scala.util.parsing</code> parser的组合子，什么东西？</li>
<li><code>scala.swing</code>java的GUI框架Swing的封装。</li>
<li>定义了一些别名给常用的类，比如<code>List</code>是<code>scala.collection.immutable.List</code>的别名，也可以理解为默认导入？</li>
<li>其他别名可能是底层平台JVM提供的，比如<code>String</code>是<code>java.lang.String</code>的别名。</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符：</p>
<ul>
<li>和Java基本相同。</li>
<li>算术运算：<code>+ - * / %</code> ，<code>+</code>可以用于一元正号，二元加号，还可以用作字符串加法，取模也可用于浮点数。没有自增和自减语法<code>++ --</code>。</li>
<li>关系运算：<code>== != &lt; &gt; &lt;= &gt;=</code></li>
<li>逻辑运算：<code>&amp;&amp; || !</code>， <code>&amp;&amp; ||</code>所有语言都支持短路求值，scala也不例外。</li>
<li>赋值运算：<code>= += -= *= /= %=</code></li>
<li>按位运算：<code>&amp; | ^ ~</code></li>
<li>移位运算：<code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code>，其中<code>&lt;&lt; &gt;&gt;</code>是有符号左移和右移，<code>&gt;&gt;&gt;</code>无符号右移。</li>
<li>scala中所有运算符本质都是对象的方法调用，拥有比C++更灵活的运算符重载。</li>
</ul>
<p>自定义运算符：</p>
<ul>
<li>Scala中运算符即是方法，任何具有单个参数的方法都可以用作<strong>中缀运算符</strong>，写作中缀表达式的写法。<code>10.+(1)</code>即是<code>10 + 1</code>。</li>
<li>定义时将合法的运算符（只有特殊符号构成的标识符）作为函数名称即可定义。</li>
</ul>
<p>运算符优先级：</p>
<ul>
<li>当一个表达式使用多个运算符时，将<strong>根据运算符的第一个字符来评估优先级</strong>。内置的运算符和自定义运算符都是函数，遵守同样的规则。</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">(characters not shown below)<br><span class="hljs-bullet">* </span>/ %<br>+ -<br>:<br><span class="hljs-section">= !</span><br>&lt; &gt;<br>&amp;<br>^<br>|<br>(all letters, $, _)<br></code></pre></td></tr></table></figure>

<ul>
<li>比如下面两个表示等价：</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">a + b ^? c ?^ d less a ==&gt; b | <span class="hljs-type">c</span><br>((a + b) ^? (c ?^ d)) less ((a ==&gt; b) | <span class="hljs-type">c</span>)<br></code></pre></td></tr></table></figure>

<p>上面都是粗浅的理解，以下引用自<a target="_blank" rel="noopener" href="https://www.scala-lang.org/files/archive/spec/2.13/06-expressions.html#prefix-infix-and-postfix-operations">Scala2.13标准 - 06表达式 - 12前缀中缀和后缀操作</a>一节：</p>
<p>词法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">PostfixExpr     ::=  InfixExpr [<span class="hljs-built_in">id</span> [<span class="hljs-built_in">nl</span>]]<br>InfixExpr       ::=  PrefixExpr<br>                  |  InfixExpr <span class="hljs-built_in">id</span> [<span class="hljs-built_in">nl</span>] InfixExpr<br>PrefixExpr      ::=  [<span class="hljs-string">&#x27;-&#x27;</span> | <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;!&#x27;</span> | <span class="hljs-string">&#x27;~&#x27;</span>] SimpleExpr<br></code></pre></td></tr></table></figure>

<ul>
<li>可以看到前缀运算符只有<code>- + ! ~</code>含义是正负号、逻辑非、按位取反。</li>
<li>表达式是通过运算符和操作数构建的。</li>
</ul>
<p>前缀运算：</p>
<ul>
<li>仅有<code>+ - ! ~</code>，等价于后缀的方法调用<code>.+() .-() .!() .~()</code></li>
<li>前缀运算符的操作数是<strong>原子</strong>的，比如<code>-sin(x)</code>被解析为<code>-(sin(x))</code>。这不同于一般的函数，如果定义一个相同含义的<code>negate</code>函数，那么<code>negate sin(x)</code>会被解析为<code>sin</code>是操作符，而<code>negate</code>和<code>(x)</code>是它的操作数。</li>
</ul>
<p>后缀运算：</p>
<ul>
<li>后缀的运算符可以是任意的标识符，所有的<code>e op</code>被解释为<code>e.op</code>。原来还可以这样！</li>
</ul>
<p>中缀运算：</p>
<ul>
<li>一个中缀运算符可以是任意的标识符，中缀运算符</li>
<li>中缀运算符的优先级定义如下：递增顺序，优先级由运算符首字符确定，同一行拥有同等优先级。</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">(all letters, as defined in [chapter 1], including <span class="hljs-code">`_`</span> and <span class="hljs-code">`$`</span>)<br>|<br>^<br>&amp;<br><span class="hljs-section">= !</span><br>&lt; &gt;<br>:<br>+ -<br><span class="hljs-bullet">* </span>/ %<br>(other operator characters, as defined in [chapter 1], including Unicode categories <span class="hljs-code">`Sm`</span> and <span class="hljs-code">`So`</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>运算符的结合性由运算符的尾字符确定，以<code>:</code>结尾的字符为右结合，其他的都是左结合。后面的集合操作运算符中有例子。</li>
<li>优先级和结合性决定了一个表达式的语义，也即是它的组合方式。具体规则：<ul>
<li>多个中缀运算符同时出现，优先级更高的更显绑定到操作数。</li>
<li>如果有多个连续的同一优先级的中缀运算符（同一优先级结合性必定相同），那么按照结合性绑定，左结合从左往右，右结合从右往左。</li>
<li>后缀运算符总是比中缀运算符优先级更低。比如<code>e1 op1 e2 op2</code>总是解释为<code>(e1 op1 e2) op2</code>。</li>
</ul>
</li>
<li>中缀的左结合的运算符可能包含多个参数，<code>e op (e1, e2, ..., en)</code>总是被解释为<code>e.op(e1, e2, ..., en)</code>。</li>
<li>对于中缀表达式<code>e1 op e2</code>，如果<code>op</code>左结合那么被解释为<code>e1.op(e2)</code>，如果右结合并且是它的参数是传名参数那么被解释为<code>e2.op(e1)</code>，如果参数是值传递，那么解释为<code>&#123;val x = e2; e2.op(x)&#125;</code>，其中x是一个新名称。后面的集合操作有例子。</li>
<li>前面所说的前缀运算、后缀运算、中缀运算对应的运算符分别是一元前置运算符、一元后置运算符、二元后置运算符，不存在其他类型，比如三元的条件运算符。</li>
</ul>
<p>赋值运算符：</p>
<ul>
<li>赋值运算符是指以<code>=</code>结尾的运算符。除了同样以<code>=</code>开始，和<code>&gt;= &lt;= !=</code>之外。</li>
<li>赋值运算符在当其他的解释都非法时会有特殊对待。</li>
<li>比如说<code>l += r</code>，如果没有显式定义的<code>+=</code>运算符，那么会被解释为<code>l = l + r</code>。</li>
<li>这种重新解释发生在满足以下两个条件的情况下：<ul>
<li><code>l</code>没有<code>+=</code>运算符。</li>
<li><code>l = l + r</code>是类型正确的，通常情况下这意味着<code>l</code>是一个左值，并且<code>l + r</code>是合法的（定义了<code>+</code>或者可隐式转换为定义了<code>+</code>的类型）。</li>
</ul>
</li>
</ul>
<p>试验与总结：</p>
<ul>
<li>内置前缀运算符有<code>+ - ! ~</code>对少量内置类型提供支持，自定义一元前缀请使用<code>unary_</code>加上要定义的运算符名称，并且不要加参数列表<code>()</code>。而且这东西真的可以加参数列表，但我并没有找到用运算符形式调用的方式。</li>
<li>自定义一元后置运算符（即定义为空参数列表）需要引入<code>scala.language.postfixOps</code>才能使用后缀运算符形式调用。当然用函数调用形式调用总是没有语法问题的。同样去掉参数列表后就可以后置使用。</li>
<li>二元后置运算符，是最常用的自定义运算符。优先级上面有，结合性以是否<code>:</code>结尾确定。需要特别注意的是右结合和比如C++中重载赋值运算符是有区别的，需要了解。</li>
<li>Scala中内置的赋值运算符返回空<code>()</code>，所以其实是不能连续赋值的，赋值类运算符算是被特殊对待了。并且因为推崇函数式编程风格，能定义为<code>val</code>则定义为<code>val</code>也就不能连续赋值。因为变量都是引用变量，定义<code>=</code>变成了没有道理也不可能的一件事情，所以实践中也只能一条语句只做一次赋值。</li>
<li>Scala不能定义<code>=</code>运算符，但可以定义复合赋值，并且做了处理，某些情况下只要类设计得好定义了运算类运算符就不需要多去定义复合赋值了。所以说如果真要定义复合赋值返回值也应该返回<code>()</code>吗？也许是的。</li>
<li>多参数的方法其实也可以写成中缀形式，<code>e op (e1, e2, ..., en)</code>。</li>
<li>对于类方法来说，<strong>运算符是函数，函数也是运算符</strong>。</li>
</ul>
<p>例子：可窥见其灵活程度。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> scala.<span class="hljs-property">language</span>.<span class="hljs-property">postfixOps</span><br>object UserDefindOps &#123;<br>    def <span class="hljs-title function_">main</span>(args: <span class="hljs-built_in">Array</span>[<span class="hljs-built_in">String</span>]): Unit = &#123;<br>        val v = <span class="hljs-title function_">Vector2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br>        val v2 = <span class="hljs-title function_">Vector2</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br><br>        <span class="hljs-built_in">println</span>(v)<br>        <span class="hljs-comment">// prefix unary</span><br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        <span class="hljs-built_in">println</span>(+v)<br>        <span class="hljs-built_in">println</span>(-v)<br>        <span class="hljs-built_in">println</span>(v.<span class="hljs-property">unary_</span>-(<span class="hljs-string">&quot;hello&quot;</span>))<br><br>        <span class="hljs-comment">// binary</span><br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        <span class="hljs-built_in">println</span>(v * <span class="hljs-number">3</span>)<br>        <span class="hljs-built_in">println</span>(v * v2)<br>        <span class="hljs-built_in">println</span>(v + v2)<br>        <span class="hljs-built_in">println</span>(v - v2)<br>        <br>        <span class="hljs-comment">// postfix unary, just for test, no meaning</span><br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        <span class="hljs-built_in">println</span>(v-)<br>        <span class="hljs-built_in">println</span>((v-)-)<br><br>        <span class="hljs-comment">// multiple</span><br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        <span class="hljs-built_in">println</span>(v <span class="hljs-title function_">hello</span> (<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>))<br>        <span class="hljs-built_in">println</span>(v + (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br>        <span class="hljs-built_in">println</span>(v - (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br><br>        <span class="hljs-comment">// assignment operator</span><br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>        var v3 = <span class="hljs-title function_">Vector2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br>        <span class="hljs-built_in">println</span>(v3 *= <span class="hljs-number">3</span>) <span class="hljs-comment">// ()</span><br>        <span class="hljs-built_in">println</span>(v3) <span class="hljs-comment">// Vector2(30.0, 15.0)</span><br>        v3 /= <span class="hljs-number">3</span><br>        <span class="hljs-built_in">println</span>(v3)<br>        v3 += v2<br>        <span class="hljs-built_in">println</span>(v3)<br>        v3 += (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        <span class="hljs-built_in">println</span>(v3)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector2</span>(val x: Double, val y: Double) &#123;<br>    override def <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">String</span> = s<span class="hljs-string">&quot;Vector2($x, $y)&quot;</span><br>    <span class="hljs-comment">// prefix unary</span><br>    def unary_- = <span class="hljs-variable">this</span>.- <span class="hljs-comment">// call postfix -</span><br>    def unary_+ = <span class="hljs-title function_">Vector2</span>(x, y)<br>    def unary_-(<span class="hljs-built_in">str</span>: <span class="hljs-built_in">String</span>) = s<span class="hljs-string">&quot;unary - with a string parameter: $str&quot;</span> <span class="hljs-comment">// can not call this through operator format</span><br>    <span class="hljs-comment">// binary</span><br>    def +(v: Vector2) = <span class="hljs-title function_">Vector2</span>(x + v.<span class="hljs-property">x</span>, y + v.<span class="hljs-property">y</span>)<br>    def -(v: Vector2) = <span class="hljs-title function_">Vector2</span>(x - v.<span class="hljs-property">x</span>, y - v.<span class="hljs-property">y</span>)<br>    def *(v: Vector2) = x * v.<span class="hljs-property">x</span> + y * v.<span class="hljs-property">y</span> <span class="hljs-comment">// Inner product </span><br>    def *(d: Double) = <span class="hljs-title function_">Vector2</span>(d * x, d * y) <span class="hljs-comment">// multiply</span><br>    def /(d: Double) = <span class="hljs-title function_">Vector2</span>(x / d, y / d)<br>    <span class="hljs-comment">// postfix unary</span><br>    def - = <span class="hljs-title function_">Vector2</span>(-x, -y)<br>    <span class="hljs-comment">// multiple</span><br>    def <span class="hljs-title function_">hello</span>(a: <span class="hljs-built_in">String</span>, b: <span class="hljs-built_in">String</span>) = s<span class="hljs-string">&quot;$a, $b, $&#123;toString()&#125;&quot;</span><br>    def +(_x: Double, _y: Double): Vector2 = <span class="hljs-variable">this</span> + <span class="hljs-title function_">Vector2</span>(_x, _y)<br>    def -(_x: Double, _y: Double): Vector2 = <span class="hljs-title function_">Vector2</span>(x - _x, y - _y)<br>&#125;<br><br>object Vector2 &#123;<br>    def <span class="hljs-title function_">apply</span>(x: Double, y: Double) = <span class="hljs-keyword">new </span><span class="hljs-class title_">Vector2</span>(x, y)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实践指南：</p>
<ul>
<li>一元前缀和一元后缀运算符定义时不加参数列表，运算符形式使用。</li>
<li>在复杂表达式中使用一元前缀和后缀运算符使用时最好加括号表明优先级，不然在复杂表达式中编译器可能难以区分这是一元的还是二元的。至少定义了一元前置和后置<code>-</code>的类中无法像<code>a - -</code>和<code>- - a</code>这样来用。</li>
<li>二元运算符定义只给一个参数，运算符形式使用。</li>
<li>参数多于1个时不要通过运算符形式使用，但如果很清晰的话其实也无妨。</li>
<li>函数也是运算符，非特殊符号运算符形式使用也可以很有用，表达能力很强，比如<code>1 to 10</code>。</li>
<li>不要滥用，用到都搞不清谁是运算符谁是操作数就不好了。</li>
<li>经验尚浅，还需多实践。</li>
</ul>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p><code>if-else</code>：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">condition</span>) &#123;<br>    xxx<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">condition</span>) &#123;<br>    xxx<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    xxx<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>scala中特殊一点，<code>if-else</code>语句也有返回值，也就是说也可以作为表达式，定义为执行的最后一个语句的返回值。</li>
<li>可以强制要求返回<code>Unit</code>类型，此时忽略最后一个表达式的值，得到<code>()</code>。</li>
<li>多种返回类型的话，赋值的目标变量类型需要指定为具体公共父类，也可以自动推断。</li>
<li>scala中没有三元条件运算符，可以用<code>if (a) b else c</code> 替代<code>a ? b : c</code>。</li>
<li>嵌套条件同理。</li>
</ul>
<p><code>for</code>循环，也叫<code>for</code>推导式：</p>
<ul>
<li><p>范围遍历：<code>for(i &lt;- 1 to 10) &#123;&#125;</code>，其中<code>1 to 10</code>是<code>Int</code>一个方法调用，返回一个<code>Range</code>。</p>
</li>
<li><p>范围<code>1 to 10</code> <code>1 until 10</code>是包含右边界和不包含右边界的范围，也可以直接用<code>Range</code>类。</p>
</li>
<li><p>范围步长<code>1 to 10 by 2</code>。</p>
</li>
<li><p>范围也是一个集合，也可以遍历普通集合：<code>for(i &lt;- collection) &#123;&#125;</code></p>
</li>
<li><p>循环守卫：即循环保护式，或者叫条件判断式，循环守卫为<code>true</code></p>
<p>则进入循环体内部，为<code>fasle</code></p>
<p>则跳过，类似于<code>continue</code></p>
<ul>
<li>写法：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i &lt;- collection if condition)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>等价于：</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(i &lt;- collection)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(condition)</span> &#123;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>嵌套循环同理。嵌套循环可以将条件合并到一个for中：</p>
<ul>
<li>标准写法：</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">4</span>)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">5</span>)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)</span></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>等价写法：</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">4</span>; j &lt;- <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">5</span>) &#123;<br>        println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>典型例子，乘法表：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> (i &lt;- 1 <span class="hljs-keyword">to</span> 9; j &lt;- 1 <span class="hljs-keyword">to</span> i) &#123;<br>    <span class="hljs-built_in">print</span>(s<span class="hljs-string">&quot;<span class="hljs-variable">$j</span> * <span class="hljs-variable">$i</span> = <span class="hljs-variable">$&#123;i * j&#125;</span> \t&quot;</span>)<br>    <span class="hljs-keyword">if</span> (j == i) println()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>循环中的引入变量，但不是循环变量：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>; j = <span class="hljs-number">10</span> - i)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>循环条件也可以用<code>&#123;&#125;</code></p>
<ul>
<li>上面的引入变量循环等价于：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-selector-tag">i</span> &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span><br>    j = <span class="hljs-number">10</span> - <span class="hljs-selector-tag">i</span><br>&#125; &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;i = &quot;</span> + <span class="hljs-selector-tag">i</span> + <span class="hljs-string">&quot;, j = &quot;</span> + j)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>循环同样有返回值，返回值都是空，也就是<code>Unit</code>实例<code>()</code>。</p>
</li>
<li><p>循环中同样可以用<code>yield</code></p>
<p>返回，外面可以接住用来操作，循环暂停，执行完后再继续循环。就像Ruby&#x2F;Python。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">val</span> v = for (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) yield i * i // default implementation is Vector, Vector(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>while</code>和<code>do while</code>：</p>
<ul>
<li>为了兼容java，不推荐使用，结果类型是<code>Unit</code>。</li>
<li>不可避免需要声明变量在循环外部，等同于循环内部对外部变量造成了影响，所以不推荐使用。</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(condition)</span> &#123;<br>&#125;<br><span class="hljs-keyword">do</span> &#123;<br>&#125; <span class="hljs-keyword">while</span> <span class="hljs-comment">(condition)</span><br></code></pre></td></tr></table></figure>

<p>循环中断：</p>
<ul>
<li><p>Scala内置控制结构去掉了<code>break continue</code>关键字，为了更好适应函数式编程，推荐使用函数式风格解决。</p>
</li>
<li><p>使用<code>breakable</code>结构来实现<code>break continue</code>功能。</p>
</li>
<li><p>循环守卫可以一定程度上替代<code>continue</code>。</p>
</li>
<li><p>可以用抛出异常捕获的方式退出循环，替代break</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">0</span> to <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span><br>        <span class="hljs-title function_ invoke__">println</span>(i)<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e: <span class="hljs-built_in">Exception</span> =&gt; <span class="hljs-comment">// do nothing</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以使用Scala中的<code>Breaks</code>类中的<code>break</code></p>
<p>方法（只是封装了异常捕获），实现异常抛出和捕获。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import scala<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.control</span><span class="hljs-selector-class">.Breaks</span><br>Breaks<span class="hljs-selector-class">.breakable</span>(<br>    <span class="hljs-keyword">for</span> (<span class="hljs-selector-tag">i</span> &lt;- <span class="hljs-number">0</span> to <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">i</span> == <span class="hljs-number">3</span>)<br>            Breaks<span class="hljs-selector-class">.break</span>()<br>        <span class="hljs-built_in">println</span>(i)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>不同范式对比：</p>
<ul>
<li>面向过程：按照步骤解决问题。</li>
<li>面向对象：分解对象、行为、属性，通过对象关系以及行为调用解决问题。耦合低，复用性高，可维护性强。</li>
<li>函数式编程：面向对象和面向过程都是命令式编程，但是函数式编程不关心具体运行过程，而是关心数据之间的映射。纯粹的函数式编程语言中没有变量，所有量都是常量，计算过程就是不停的表达式求值的过程，每一段程序都有返回值。不关心底层实现，对人来说更好理解，相对地编译器处理就比较复杂。</li>
<li>函数式编程优点：编程效率高，函数式编程的不可变性，对于函数特定输入输出是特定的，与环境上下文等无关。函数式编程无副作用，利于并行处理，所以Scala特别利于应用于大数据处理，比如Spark，Kafka框架。</li>
</ul>
<p>函数定义：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">func</span>(arg1: TypeOfArg1, arg2: ...): RetType = &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>函数式编程语言中，函数是一等公民（可以像对象一样赋值、作为参数返回值），可以在任何代码块中定义函数。</li>
<li>一般将定义在类或对象中（最外层）的函数称为方法，而定义在方法中（内层）的称为函数。广义上都是函数。</li>
<li>返回值用<code>return</code>返回，不写的话会使用最后一行代码作为返回值。</li>
<li>无返回值<code>Unit</code>时可以用<code>return</code>可以用<code>return ()</code>可以不返回。</li>
<li>其他时候只需要返回值是返回值类型的子类对象就行。</li>
</ul>
<p>术语说明：</p>
<ul>
<li>java中不提函数的说法，而是说类或者实例方法，不涉及一般化的函数。</li>
<li>函数式编程中的函数二字来源于数学上的函数，也就是映射，集合和集合之间的关系，强调数据之间的映射关系。</li>
<li>而编程语言中的函数，也包括scala中的函数定义都是指的一个完成特定功能的子程序（subroutine），并不等同于数学意义上的函数。</li>
</ul>
<p>函数参数：</p>
<ul>
<li><p>可变参数，类似于Java，使用数组包装。</p>
<ul>
<li><code>def f4(str:String*): Unit = &#123;&#125;</code>。</li>
<li>如果除了可变参数还有其他参数，需要将可变参数放在末尾。</li>
<li>可变参数当做数组来使用。</li>
</ul>
</li>
<li><p>参数默认值:</p>
<ul>
<li><code>def f5(name: String = &quot;alice&quot;): Unit = &#123;&#125;</code></li>
<li>和C++一样，默认参数可以不传，默认参数必须全部放在末尾。</li>
</ul>
</li>
<li><p>带名称传参：</p>
<ul>
<li>调用时带名称。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">def f6(name: <span class="hljs-built_in">String</span>, age: Int = <span class="hljs-number">20</span>, loc: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;BeiJing&quot;</span>): Unit = &#123;<br>    println(s<span class="hljs-string">&quot;name <span class="hljs-subst">$&#123;name&#125;</span>, age <span class="hljs-subst">$&#123;age&#125;</span>, location <span class="hljs-subst">$&#123;loc&#125;</span>&quot;</span>)<br>&#125;<br>f6(<span class="hljs-string">&quot;Bob&quot;</span>)<br>f6(<span class="hljs-string">&quot;Alice&quot;</span>, loc = <span class="hljs-string">&quot;Xi&#x27;An&quot;</span>)<br>f6(<span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>不给名称的就是按顺序赋值。</li>
<li>调用时带名参数必须位于实参列表末尾。</li>
<li>和默认参数一起使用会很方便，比如有多个默认参数，但只想覆盖其中一个。</li>
</ul>
</li>
</ul>
<p>函数至简原则：</p>
<ul>
<li><p>能省则省。</p>
</li>
<li><p>最后一行代码会作为返回值，可以省略<code>return</code>。</p>
</li>
<li><p>函数体只有一行代码的话，可以省略花括号。</p>
</li>
<li><p>如果返回值类型能够自动推断那么可以省略。</p>
</li>
<li><p>如果函数体中用<code>return</code>做返回，那么返回值类型必须指定。</p>
</li>
<li><p>如果声明返回<code>Unit</code>，那么函数体中使用<code>return</code>返回的值也不起作用。</p>
</li>
<li><p>如果期望是无返回值类型，那么可以省略<code>=</code>。这时候没有返回值，函数也可以叫做过程。【2.13.0已废弃，能编过不过会提示。】</p>
</li>
<li><p>无参函数如果声明时没有加<code>()</code>，调用时可以省略<code>()</code>。【如果声明时有<code>()</code>调用也可以省略，不过2.13.3废弃了。】</p>
</li>
<li><p>不关心函数名称时，函数名称和def也可以省略，去掉返回值类型，将&#x3D;修改为&#x3D;&gt;定义为匿名函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> =&gt; &#123; println(<span class="hljs-string">&quot;name&quot;</span>) &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>匿名函数：</p>
<ul>
<li><p>没有名称的函数，可以被赋值给一个量。也叫lambda表达式</p>
</li>
<li><p><code>val fun = (name: String) =&gt; &#123; println(&quot;name&quot;) &#125;</code></p>
</li>
<li><p>匿名函数定义时不能有函数的返回值类型。</p>
</li>
<li><p>简化原则：</p>
<ul>
<li>参数的类型可以省略，如果可以根据高阶函数形参自动推导。</li>
<li>类型省略之后如果只有一个参数，那么可以省略参数列表的<code>()</code>，<code>name =&gt; println(name)</code>。</li>
<li>匿名函数函数体只要一行，那么<code>&#123;&#125;</code>可以省略。</li>
<li>如果参数只出现一次，则参数可以省略，后面出现的参数用<code>_</code>代替，<code>println(_)</code>也是一个lambda，表示<code>name =&gt; &#123;println(name)&#125;</code>。</li>
<li>如果可以推断出当前传入的<code>println</code>是一个函数体，而不是函数调用语句，那么可以省略下划线。也就是省略了转调，直接将函数名称作为参数传递。</li>
</ul>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">func</span>: <span class="hljs-variable">String</span> =&gt; <span class="hljs-variable">Unit</span>): <span class="hljs-variable">Unit</span> = &#123;</span><br><span class="hljs-function">    <span class="hljs-title">func</span>(<span class="hljs-string">&quot;alice&quot;</span>)</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">f</span>((<span class="hljs-variable">name</span>: <span class="hljs-variable">String</span>) =&gt; &#123; <span class="hljs-title">println</span>(<span class="hljs-variable">name</span>) &#125;)</span><br><span class="hljs-function"><span class="hljs-title">f</span>((<span class="hljs-variable">name</span>) =&gt; <span class="hljs-title">println</span>(<span class="hljs-variable">name</span>))</span><br><span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">println</span>(<span class="hljs-variable">_</span>))</span><br><span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">println</span>)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>例子：省得太极端就没有可读性了。</p>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">def dual<span class="hljs-constructor">Op(<span class="hljs-params">func</span>: (Int, Int)</span> =&gt; Int): Int = &#123;<br>    func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>&#125;<br>println(dual<span class="hljs-constructor">Op((<span class="hljs-params">a</span>: Int, <span class="hljs-params">b</span>: Int)</span> =&gt; a + b))<br>println(dual<span class="hljs-constructor">Op((<span class="hljs-params">a</span>: Int, <span class="hljs-params">b</span>: Int)</span> =&gt; a - b))<br>println(dual<span class="hljs-constructor">Op((<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> =&gt; a - b))<br>println(dual<span class="hljs-constructor">Op(<span class="hljs-params">_</span> + <span class="hljs-params">_</span>)</span>) <span class="hljs-comment">// a + b</span><br>println(dual<span class="hljs-constructor">Op(-<span class="hljs-params">_</span> + <span class="hljs-params">_</span>)</span>) <span class="hljs-comment">// -a + b</span><br></code></pre></td></tr></table></figure>

<p>高阶函数：</p>
<ul>
<li>三种形式：函数作为值传递、函数作为参数、函数作为返回值。</li>
<li>作为值传递：经过赋值之后在底层变成一个lambda对象。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> define <span class="hljs-keyword">function</span><br>def foo(n: Int): Int = &#123;<br>    println(<span class="hljs-string">&quot;call foo&quot;</span>)<br>    n + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span> assign to value, also a object<br>val <span class="hljs-keyword">func</span> = foo _ <span class="hljs-regexp">//</span> represent the <span class="hljs-keyword">function</span> foo, not <span class="hljs-keyword">function</span> call<br>val func1: Int =&gt; Int = foo <span class="hljs-regexp">//</span> specify the type of func1<br>println(<span class="hljs-keyword">func</span>) <span class="hljs-regexp">//</span> Main$$<span class="hljs-variable">$Lambda</span><span class="hljs-variable">$674</span>/<span class="hljs-number">0</span>x000000080103c588@<span class="hljs-number">770</span>beef5<br>println(<span class="hljs-keyword">func</span> == func1) <span class="hljs-regexp">//</span> false, not a same object<br></code></pre></td></tr></table></figure>

<ul>
<li>函数作为参数，上面展示过了。可以传匿名函数、函数名称、lambda对象。</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">function</span> <span class="hljs-keyword">as</span> arguments<br>def dualEval(op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) = &#123;<br>    op(a, b)<br>&#125;<br>def <span class="hljs-keyword">add</span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = a + b<br>println(dualEval(<span class="hljs-keyword">add</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>))<br>val mul:(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span> = _ * _<br>println(dualEval(mul, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>))<br>println(dualEval((a, b) =&gt; a + b, <span class="hljs-number">1000</span>, <span class="hljs-number">24</span>))<br></code></pre></td></tr></table></figure>

<ul>
<li>函数作为返回值：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// function as return value</span><br>def <span class="hljs-built_in">outerFunc</span>(): Int =&gt; Unit = &#123;<br>    def <span class="hljs-built_in">inner</span>(a: Int): Unit = &#123;<br>        <span class="hljs-built_in">println</span>(s&quot;call inner with argument $&#123;a&#125;&quot;)<br>    &#125;<br>    inner <span class="hljs-comment">// return a function</span><br>&#125;<br><span class="hljs-built_in">println</span>(outerFunc()(<span class="hljs-number">10</span>)) <span class="hljs-comment">// inner return ()</span><br></code></pre></td></tr></table></figure>

<ul>
<li>现在就可以套娃了，比如定义一个返回一个返回函数的函数的函数。</li>
</ul>
<p>高阶函数举例：</p>
<ul>
<li>使用特定操作处理数组元素，得到新数组。也就是集合处理的map（映射）操作。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// deal with an array, get a new array</span><br><span class="hljs-comment">// map operation of array</span><br>def <span class="hljs-built_in">array</span><span class="hljs-constructor">Op(<span class="hljs-params">arr</span>: Array[Int], <span class="hljs-params">op</span>: Int =&gt; Int)</span>: Array<span class="hljs-literal">[I<span class="hljs-identifier">nt</span>]</span> = &#123;<br>    <span class="hljs-keyword">for</span> (elem &lt;- arr) yield op(elem) <span class="hljs-comment">// the whole for expression get a new array</span><br>&#125;<br><span class="hljs-keyword">val</span> arr = <span class="hljs-constructor">Array(1, 2, 3, 4)</span><br>def add<span class="hljs-constructor">One(<span class="hljs-params">elem</span>: Int)</span>: Int = elem + <span class="hljs-number">1</span><br>println(<span class="hljs-built_in">array</span><span class="hljs-constructor">Op(<span class="hljs-params">arr</span>, <span class="hljs-params">addOne</span> <span class="hljs-params">_</span>)</span>.mk<span class="hljs-constructor">String(<span class="hljs-string">&quot;, &quot;</span>)</span>) <span class="hljs-comment">// pass addOne also work</span><br>println(<span class="hljs-built_in">array</span><span class="hljs-constructor">Op(<span class="hljs-params">arr</span>, <span class="hljs-params">elem</span> =&gt; <span class="hljs-params">elem</span> <span class="hljs-operator">*</span> 2)</span>.mk<span class="hljs-constructor">String(<span class="hljs-string">&quot;, &quot;</span>)</span>)<br>println(<span class="hljs-built_in">array</span><span class="hljs-constructor">Op(<span class="hljs-params">arr</span>, <span class="hljs-params">_</span> <span class="hljs-operator">*</span> 3)</span>.mk<span class="hljs-constructor">String(<span class="hljs-string">&quot;, &quot;</span>)</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>套娃：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> func(a: <span class="hljs-keyword">Int</span>): String =&gt; (<span class="hljs-keyword">Char</span> =&gt; <span class="hljs-keyword">Boolean</span>) = &#123;<br>    <span class="hljs-keyword">def</span> f1(s: String): <span class="hljs-keyword">Char</span> =&gt; <span class="hljs-keyword">Boolean</span> = &#123;<br>        <span class="hljs-keyword">def</span> f2(c: <span class="hljs-keyword">Char</span>): <span class="hljs-keyword">Boolean</span> = &#123; <br>            <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> &amp;&amp; s == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; c == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">false</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">true</span><br>        &#125;<br>        f2<br>    &#125;<br>    f1<br>&#125;<br><span class="hljs-keyword">println</span>(func(<span class="hljs-number">0</span>)(<span class="hljs-string">&quot;&quot;</span>)(<span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-keyword">println</span>(func(<span class="hljs-number">1</span>)(<span class="hljs-string">&quot;hello&quot;</span>)(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li>上面的例子经过极致简写：只能说类型推导也太强大了。<strong>内层函数可以使用外层函数的参数</strong>。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// simplify to anonymous function</span><br>def func1(a: Int): <span class="hljs-function"><span class="hljs-params">String</span> =&gt;</span> (<span class="hljs-function"><span class="hljs-params">Char</span> =&gt;</span> <span class="hljs-built_in">Boolean</span>) = &#123;<br>    s =&gt; <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> !(a == <span class="hljs-number">0</span> &amp;&amp; s == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; c == <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br>println(func1(<span class="hljs-number">0</span>)(<span class="hljs-string">&quot;&quot;</span>)(<span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-comment">// false</span><br>println(func1(<span class="hljs-number">1</span>)(<span class="hljs-string">&quot;hello&quot;</span>)(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li>柯里化之后：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// Currying </span><br><span class="hljs-keyword">def</span> func2(a: <span class="hljs-keyword">Int</span>)(s: String)(c: <span class="hljs-keyword">Char</span>): <span class="hljs-keyword">Boolean</span> = !(a == <span class="hljs-number">0</span> &amp;&amp; s == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; c == <span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-keyword">println</span>(func2(<span class="hljs-number">0</span>)(<span class="hljs-string">&quot;&quot;</span>)(<span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-comment">// false</span><br><span class="hljs-keyword">println</span>(func2(<span class="hljs-number">1</span>)(<span class="hljs-string">&quot;hello&quot;</span>)(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong>函数柯里化</strong>和<strong>闭包</strong>：<strong>重点</strong>。</p>
<p>闭包：如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包</a>的定义：</li>
</ul>
<blockquote>
<p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0">头等函数</a>的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。</p>
</blockquote>
<ul>
<li>因为外层调用结束返回内层函数后，经过堆栈调整(比如在C中主调或者被调清理)，外层函数的参数已经被释放了，所以内层是获取不到外层的函数参数的。为了能够将环境（函数中用到的并非该函数参数的变量和他们的值）保存下来（需要考虑释放问题，可以通过GC可以通过对象生命周期控制，GC是一个常见选择），这时会将执行的环境打一个包保存到堆里面。</li>
</ul>
<p>函数<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>（Currying）：将一个参数列表的多个参数，变成多个参数列表的过程。也就是将普通多参数函数变成高阶函数的过程。</p>
<ul>
<li>定义：</li>
</ul>
<blockquote>
<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。在直觉上，柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数”。柯里化是一种处理函数中附有多个参数的方法，并在只允许单一参数的框架中使用这些函数。</p>
</blockquote>
<ul>
<li>scala中的柯里化函数定义：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// Currying </span><br><span class="hljs-keyword">def</span> add(a: <span class="hljs-keyword">Int</span>)(b: <span class="hljs-keyword">Int</span>): <span class="hljs-keyword">Int</span> = a + b<br><span class="hljs-keyword">println</span>(add(<span class="hljs-number">4</span>)(<span class="hljs-number">3</span>))<br>val addFour = add(<span class="hljs-number">4</span>) _<br><span class="hljs-comment">// val addFour: Int =&gt; int = add(4)</span><br><span class="hljs-keyword">println</span>(addFour(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure>

<p>递归：</p>
<ul>
<li>太常见了，不用过多介绍。</li>
<li>方法调用自身。</li>
<li>递归要有结束逻辑。</li>
<li>调用自身时，传递参数要有规律。</li>
<li>scala中递归定义函数必须声明返回值类型，因为无法通过推导获得。</li>
<li>纯函数式语言比如Haskell，连循环都没有，很多操作都需要通过递归来做，性能比较依赖尾递归优化。</li>
<li>scala中的尾递归优化例子：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">factorial</span>(n: Int) : Int = &#123;<br>    if (n &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span><br>    <span class="hljs-built_in">if</span>(n == <span class="hljs-number">0</span>)<br>        return <span class="hljs-number">1</span> <br>    <span class="hljs-built_in">factorial</span>(n-<span class="hljs-number">1</span>) * n<br>&#125;<br><span class="hljs-comment">// tail recusion implementation of factorial</span><br>def <span class="hljs-built_in">tailFact</span>(n: Int): Int = &#123;<br>    if (n &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">@annotation</span>.tailrec<br>    def loop(<span class="hljs-attribute">n</span>: Int, <span class="hljs-attribute">curRes</span>: Int): Int = &#123;<br>        if (n == <span class="hljs-number">0</span>)<br>            return curRes<br>        <span class="hljs-built_in">loop</span>(n - <span class="hljs-number">1</span>, curRes * n)<br>    &#125;<br>    <span class="hljs-built_in">loop</span>(n, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制抽象：</p>
<ul>
<li>值调用：按值传递参数，计算值后再传递。多数语言中一般函数调用都是这个方式，C++还存在引用传递。</li>
<li>名调用：按名称传递参数，直接用实参替换函数中使用形参的地方。能想到的只有C语言中的带参宏函数，其实并不是函数调用，预处理时直接替换。</li>
<li>例子：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// pass by value</span><br>def <span class="hljs-built_in">f0</span>(a: Int): Unit = &#123;<br>    <span class="hljs-built_in">println</span>(&quot;a: &quot; + a)<br>    <span class="hljs-built_in">println</span>(&quot;a: &quot; + a)<br>&#125;<br><span class="hljs-built_in">f0</span>(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// pass by name, argument can be a code block that return to Int</span><br>def <span class="hljs-built_in">f1</span>(a: =&gt; Int): Unit = &#123;<br>    <span class="hljs-built_in">println</span>(&quot;a: &quot; + a)<br>    <span class="hljs-built_in">println</span>(&quot;a: &quot; + a)<br>&#125;<br>def <span class="hljs-built_in">f2</span>(): Int = &#123;<br>    <span class="hljs-built_in">println</span>(&quot;call f2()&quot;)<br>    <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-built_in">f1</span>(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">f1</span>(f2()) <span class="hljs-comment">// pass by name, just replace a with f2(), then will call f2() twice</span><br><span class="hljs-built_in">f1</span>(&#123;<br>    println(&quot;code block&quot;) <span class="hljs-comment">// print twice</span><br>    <span class="hljs-number">30</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>应用：使用传名参数实现一个函数相当于while的功能。</li>
</ul>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-comment">// built-in while</span><br><span class="hljs-variable">var</span> <span class="hljs-variable">n</span> = <span class="hljs-number">10</span><br><span class="hljs-variable"><span class="hljs-keyword">while</span></span> (<span class="hljs-variable">n</span> &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">s</span><span class="hljs-string">&quot;$n &quot;</span>)</span><br>    <span class="hljs-variable">n</span> -= <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">println</span>()</span><br><br><span class="hljs-comment">// application: self-defined while, implement a function just like while keyword</span><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">myWhile</span>(<span class="hljs-variable">condition</span>: =&gt; <span class="hljs-variable">Boolean</span>): (=&gt; <span class="hljs-variable">Unit</span>) =&gt; <span class="hljs-variable">Unit</span> = &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">def</span> <span class="hljs-title">doLoop</span>(<span class="hljs-variable">op</span>: =&gt; <span class="hljs-variable">Unit</span>): <span class="hljs-variable">Unit</span> = &#123;</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">condition</span>) &#123;</span><br><span class="hljs-function">            <span class="hljs-variable">op</span></span><br><span class="hljs-function">            <span class="hljs-title">myWhile</span>(<span class="hljs-variable">condition</span>)(<span class="hljs-variable">op</span>)</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-variable">doLoop</span> <span class="hljs-variable">_</span><br>&#125;<br><span class="hljs-variable">n</span> = <span class="hljs-number">10</span><br><span class="hljs-variable">myWhile</span> (<span class="hljs-variable">n</span> &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">s</span><span class="hljs-string">&quot;$n &quot;</span>)</span><br>    <span class="hljs-variable">n</span> -= <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">println</span>()</span><br><br><span class="hljs-comment">// simplfy</span><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">myWhile2</span>(<span class="hljs-variable">condition</span>: =&gt; <span class="hljs-variable">Boolean</span>): (=&gt; <span class="hljs-variable">Unit</span>) =&gt; <span class="hljs-variable">Unit</span> = &#123;</span><br><span class="hljs-function">    <span class="hljs-variable">op</span> =&gt; &#123;</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">condition</span>) &#123;</span><br><span class="hljs-function">            <span class="hljs-variable">op</span></span><br><span class="hljs-function">            <span class="hljs-title">myWhile2</span>(<span class="hljs-variable">condition</span>)(<span class="hljs-variable">op</span>)</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable">n</span> = <span class="hljs-number">10</span><br><span class="hljs-variable">myWhile</span> (<span class="hljs-variable">n</span> &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">s</span><span class="hljs-string">&quot;$n &quot;</span>)</span><br>    <span class="hljs-variable">n</span> -= <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">println</span>()</span><br><br><span class="hljs-comment">// use currying</span><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">myWhile3</span>(<span class="hljs-variable">condition</span>: =&gt; <span class="hljs-variable">Boolean</span>)(<span class="hljs-variable">op</span>: =&gt; <span class="hljs-variable">Unit</span>): <span class="hljs-variable">Unit</span> = &#123;</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">condition</span>) &#123;</span><br><span class="hljs-function">        <span class="hljs-variable">op</span></span><br><span class="hljs-function">        <span class="hljs-title">myWhile3</span>(<span class="hljs-variable">condition</span>)(<span class="hljs-variable">op</span>)</span><br>    &#125;<br>&#125;<br><span class="hljs-variable">n</span> = <span class="hljs-number">10</span><br><span class="hljs-variable">myWhile3</span> (<span class="hljs-variable">n</span> &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">s</span><span class="hljs-string">&quot;$n &quot;</span>)</span><br>    <span class="hljs-variable">n</span> -= <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">println</span>()</span><br></code></pre></td></tr></table></figure>

<p>惰性加载：</p>
<ul>
<li>当函数返回值被声明为<code>lazy</code>时，函数的执行将会被推迟，知道我们首次对此取值，该函数才会被执行。这种函数成为惰性函数。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> main(args: Array[String]): Unit = &#123;<br>    <span class="hljs-comment">// just like pass by name</span><br>    lazy val result: <span class="hljs-keyword">Int</span> = sum(<span class="hljs-number">13</span>, <span class="hljs-number">47</span>)<br>    <span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;before lazy load&quot;</span>)<br>    <span class="hljs-keyword">println</span>(s<span class="hljs-string">&quot;result = $&#123;result&#125;&quot;</span>) <span class="hljs-comment">// first call sum(13, 47)</span><br>    <span class="hljs-keyword">println</span>(s<span class="hljs-string">&quot;result = $&#123;result&#125;&quot;</span>) <span class="hljs-comment">// result has been evaluated</span><br>&#125;<br><span class="hljs-keyword">def</span> sum(a: <span class="hljs-keyword">Int</span>, b: <span class="hljs-keyword">Int</span>): <span class="hljs-keyword">Int</span> = &#123;<br>    <span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;call sum&quot;</span>)<br>    a + b<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>有点像传名参数，但懒加载只是推迟求值到第一次使用时，而不是单纯替换。</li>
</ul>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>关于Scala面向对象：</p>
<ul>
<li>Scala的面向对象思想源自Java，很多概念是一致的。</li>
<li>语法和java不同，补充了更多功能。</li>
</ul>
<p>包：</p>
<ul>
<li><p><code>package name</code></p>
</li>
<li><p>作用：</p>
<ul>
<li>区分相同名字类，避免名称冲突。</li>
<li>类很多时，分模块管理。</li>
<li>访问权限控制。</li>
</ul>
</li>
<li><p>命名：包名称只能是常规的标识符（字母数字下划线，数字不能开头）。同样<code>.</code>作为不同层级分割符，整体作为包名。</p>
</li>
<li><p>命名规范：一般情况下按照如下规则命名<code>com.company.projectname.modulename</code>，视项目规定而定，只是一个名称而已。</p>
</li>
<li><p>scala中的两种包管理方式：</p>
<ul>
<li>第一种，java风格，每个源文件声明一个包，写在源文件最上方。但源文件位置不需要和包名目录层级一致，只代表逻辑层级关系，不像java一样源文件也必须按照包名目录层级关系放置。当然惯例是和java一样按照包名目录层级来放置。</li>
<li>第二种，用<code>&#123;&#125;</code>嵌套风格定义包：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package com &#123;<br>    // code <span class="hljs-keyword">in</span> com package<br>    <span class="hljs-keyword">object</span> <span class="hljs-keyword">Outer</span> &#123;<br>        var <span class="hljs-type">name</span> = &quot;Outer&quot;<br>    &#125;<br>    package <span class="hljs-keyword">inner</span> &#123;<br>        // code <span class="hljs-keyword">in</span> com.<span class="hljs-keyword">inner</span> package<br>        package scala &#123;<br>            // code <span class="hljs-keyword">in</span> com.innner.scala package<br>            <span class="hljs-keyword">object</span> <span class="hljs-keyword">Inner</span> &#123;<br>                def main(args: <span class="hljs-keyword">Array</span>[String]):Unit = &#123;<br>                    println(<span class="hljs-keyword">Outer</span>.name)<br>                    <span class="hljs-keyword">Outer</span>.name = &quot;Inner&quot;<br>                    println(<span class="hljs-keyword">Outer</span>.name)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<ul>
<li>嵌套风格好处：<ul>
<li>一个源文件可以声明多个并列的最顶层的包。</li>
<li>子包中的类可以访问父包中的内容，无需导入。但外层是不能直接访问内层的，需要导入。</li>
</ul>
</li>
<li>如果单文件VsCode测试嵌套包，而不是用IDE的话，那定义了包就不能直接执行了，需要<code>scalac</code>先编译，并指定入口类运行。编译后的字节码文件和java一样会自动按照包层级关系排列。</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scalac </span>PackageManagement.<span class="hljs-keyword">scala</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scala </span>com.inner.<span class="hljs-keyword">scala.Inner </span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>包对象：</p>
<ul>
<li>为scala包定义一个同名的单例包对象，定义在包对象中的成员，作为其对应包下的所有类和对象的共享变量，可以被直接访问，无需导入。</li>
<li>关键字<code>package object</code>，需要和包在同一层级下。比如为<code>com.inner</code>包定义包对象的话，必须在<code>com</code>包中，定义形式<code>package obejct inner &#123; ... &#125;</code>。</li>
</ul>
<p>包的导入：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> users.<span class="hljs-literal">_</span>      <span class="hljs-comment">// 导入包 users 中的所有成员</span><br><span class="hljs-keyword">import</span> users.User   <span class="hljs-comment">// 导入类 User</span><br><span class="hljs-keyword">import</span> users.&#123;User, UserPreferences&#125;      <span class="hljs-comment">// 仅导入选择的成员</span><br><span class="hljs-keyword">import</span> users.&#123;UserPreferences =&gt; UPrefs&#125;  <span class="hljs-comment">// 导入类并且设置别名</span><br><span class="hljs-keyword">import</span> users.&#123;User =&gt; <span class="hljs-literal">_</span>, <span class="hljs-literal">_</span>&#125;               <span class="hljs-comment">// 导入出User类以外的所有users包中的内容</span><br></code></pre></td></tr></table></figure>

<ul>
<li>可以在任意位置导入（作用于代码块），可以设置别名，可以选择性导入想要导入的内容，可以屏蔽某个类。</li>
<li>所有scala源文件默认导入：</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> java.lang._<br><span class="hljs-keyword">import</span> scala._<br><span class="hljs-keyword">import</span> scala.Predef._<br></code></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类定义：</p>
<ul>
<li>回顾java中，如果是<code>public</code>向外公开的，那么必须和文件名一致，也只能有一个。不写访问修饰符则可以定义多个，包访问权限。</li>
<li>scala中没有<code>public</code>关键字，默认就是公有，不能加<code>public</code>，一个文件可以写多个类，不要求和文件名一致。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[descriptor]</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">classname</span> &#123;<br>    <span class="hljs-comment">// body: fields &amp; methods</span><br><span class="hljs-string">    [descriptor]</span> var/val name: Type = _<br><span class="hljs-string">    [descriptor]</span> method(args: ArgsType): RetType = &#123;<br>        <span class="hljs-comment">// method body</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>访问修饰符可以是：<code>private</code> <code>protected</code> <code>private [pacakgeName]</code>，默认就是公有，不需要加。</li>
<li>成员如果需要Java Bean规范的getter和setter的话可以加<code>@scala.beans.BeanProperty</code>相当于自动创建，不需要显式写出。</li>
<li>成员给初值<code>_</code>会赋默认值，scala中定义变量必须赋值，可以这样做。值类型的值0，引用则是<code>null</code>。定义常量的话不能用<code>_</code>，因为只能初始化一次，编译器会提示。</li>
</ul>
<p>封装：</p>
<ul>
<li>Java的封装：私有化，提供getter和setter。</li>
<li>scala中考虑到Java太冗余了，脱裤子放屁一样。scala中的公有属性，底层实际为<code>private</code>，并通过get方法<code>obj.field()</code>和set方法<code>obj.field_=(value)</code>对其进行操作。所以scala不推荐设置为<code>private</code>。如果需要和其他框架互操作，必须提供Java Bean规范的getter和setter的话可以加<code>@scala.beans.BeanProperty</code>注解。</li>
</ul>
<p>访问权限：</p>
<ul>
<li>Java中<code>private protected public</code>和默认包访问权限。</li>
<li>scala中属性和方法默认公有，并且不提供<code>public</code>关键字。</li>
<li><code>private</code>私有，类内部和伴生对象内可用。</li>
<li><code>protected</code>保护权限，scala中比java中严格，只有同类、子类可访问，同包无法访问。【因为java中说实话有点奇怪】</li>
<li><code>private [pacakgeName]</code>增加包访问权限，在包内可以访问。</li>
</ul>
<p>构造器：</p>
<ul>
<li>包括主构造器和辅助构造器。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> [<span class="hljs-title">descriptor</span>] [</span>([descriptor][<span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span>] arg1: Arg1Type, [descriptor][<span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span>] arg2: ...)] &#123; <span class="hljs-comment">// main constructor, only one, like record in java</span><br>    <span class="hljs-comment">// assist constructor</span><br>    def <span class="hljs-keyword">this</span>(argsList1) &#123;<br>        <span class="hljs-keyword">this</span>(args) <span class="hljs-comment">// call main constructor</span><br>    &#125;<br>    def <span class="hljs-keyword">this</span>(argsList2) &#123; <span class="hljs-comment">// overload constrcutor</span><br>        <span class="hljs-keyword">this</span>(argsList1) <span class="hljs-comment">// can call main constructor or other constructor that call main constructor directly or indirectly</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> Constructor &#123;<br>    def main(args: Array[String]): <span class="hljs-built_in">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> p: Person = new Person()<br>        p.Person() <span class="hljs-comment">// call main constructor</span><br><br>        <span class="hljs-keyword">val</span> p1 = new Person(<span class="hljs-string">&quot;alice&quot;</span>)<br>        <span class="hljs-keyword">val</span> p2 = new Person(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">25</span>)<br>        p1.Person()<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String = _<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = _<br>    println(<span class="hljs-string">&quot;call main construtor&quot;</span>)<br><br>    def <span class="hljs-keyword">this</span>(name: String) &#123;<br>        <span class="hljs-keyword">this</span>()<br>        println(<span class="hljs-string">&quot;call assist constructor 1&quot;</span>)<br>        <span class="hljs-keyword">this</span>.name = name<br>        println(s<span class="hljs-string">&quot;Person: <span class="hljs-variable">$name</span> <span class="hljs-variable">$age</span>&quot;</span>)<br>    &#125;<br><br>    def <span class="hljs-keyword">this</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123;<br>        <span class="hljs-keyword">this</span>(name)<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;call assist constructor 2&quot;</span>)<br>        println(s<span class="hljs-string">&quot;Person: <span class="hljs-variable">$name</span> <span class="hljs-variable">$age</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// just a common method, not constructor</span><br>    def Person(): <span class="hljs-built_in">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;call Person.Person() method&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>特点：</p>
<ul>
<li>主构造器写在类定义上，一定是构造时最先被调用的构造器，方法体就是类定义，可以在类中方法定义的同级编写逻辑，都是主构造器一部分，按顺序执行。</li>
<li>辅助构造器用<code>this</code>定义。</li>
<li>辅助构造器必须直接或者间接调用主构造器，调用其他构造必须位于第一行。</li>
<li>主构造器和辅助构造器是重载的方法，所以参数列表不能一致。</li>
<li>可以定义和类名同名方法，就是一个普通方法。</li>
</ul>
</li>
<li><p>主构造器中形参三种形式：不使用任何修饰，</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure>

<p>修饰，</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">val</span><br></code></pre></td></tr></table></figure>

<p>修饰。</p>
<ul>
<li>不使用任何修饰那就是一个形参，但此时在类内都可以访问到这个变量。逻辑上不是一个成员（报错信息这么写），但是可以访问，WTF？？？</li>
<li>使用<code>var val</code>修饰那就是定义为类成员，分别是变量和常量，不需要也不能在类内再定义一个同名字段。调用时传入参数就直接给到该成员，不需要再显式赋值。</li>
<li>主构造器中的<code>var val</code>成员也可以添加访问修饰符。</li>
<li>不加参数列表相当于为空，<code>()</code>可以省略。</li>
<li>主构造器的访问修饰符添加到参数列表<code>()</code>前。</li>
</ul>
</li>
<li><p>实践指南：</p>
<ul>
<li>推荐使用scala风格的主构造器<code>var val</code>修饰参数的编写方法，而不要被Java毒害！</li>
<li>如果需要多种重载的构造器那么就添加新的的辅助构造器。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String) &#123;<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = _<br>    println(<span class="hljs-string">&quot;call main construtor&quot;</span>)<br><br>    def <span class="hljs-keyword">this</span>(name: String, age: <span class="hljs-built_in">Int</span>) = &#123;<br>        <span class="hljs-keyword">this</span>(name)<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;call assist constructor 2&quot;</span>)<br>        println(s<span class="hljs-string">&quot;Person: <span class="hljs-variable">$name</span> <span class="hljs-variable">$age</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// just a common method, not constructor</span><br>    def Person(): <span class="hljs-built_in">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;call Person.Person() method&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承：</p>
<ul>
<li><code>class ChildClassName[(argList1)] extends BaseClassName[(args)] &#123; body &#125;</code></li>
<li>子类继承父类属性和方法。</li>
<li>可以调用父类构造器，但感觉好像很局限，子类中只可能调用到主构造或者辅助构造中的其中一个构造器。那如果父类有多种构造方式，子类想继承也没有办法？只能是其中一种。</li>
<li>不考虑太多负担，按照scala惯用写法来写起来还是挺轻松的。</li>
</ul>
<p>多态：</p>
<ul>
<li>java中属性静态绑定，根据变量的引用类型确定，方法是动态绑定。</li>
<li>但scala中<strong>属性和方法都是动态绑定</strong>。就属性而言，其实也不应该在子类和父类中定义同名字段。</li>
<li>同java一样，所有实例方法都是虚方法，都可以被子类覆写。</li>
<li><code>override</code>关键字覆写。</li>
<li>scala中<strong>属性（字段）也可以被重写</strong>，加<code>override</code>关键字。</li>
</ul>
<p>抽象类：</p>
<ul>
<li><code>abstract calss ClassName</code></li>
<li>抽象属性：<code>val/var name: Type</code>，不给定初始值。</li>
<li>抽象方法：<code>def methodName(): RetType</code>，只声明不实现。</li>
<li>子类如果没有覆写全部父类未定义的属性和方法，那么就必须定义为抽象类。老生常谈了。</li>
<li>重写非抽象方法属性必须加<code>override</code>，重写抽象方法则可以不加<code>override</code>。</li>
<li>子类调用父类中方法使用<code>super</code>关键字。</li>
<li>子类重写父类抽象属性，父类抽象属性可以用<code>var</code>修饰，<code>val var</code>都可以。因为父类没有实现嘛，需要到子类中来实现。</li>
<li>如果是<strong>重写非抽象属性</strong>，则父类非抽象属性只支持<code>val</code>，不支持<code>var</code>。因为<code>var</code>修饰为可变量，子类继承后可以直接使用修改，没有必要重写。<code>val</code>不可变才有必要重写。</li>
<li>实践建议是重写就加<code>override</code>，都是很自然的东西，理解就好，不必纠结于每一个细节。</li>
</ul>
<p>匿名子类；</p>
<ul>
<li>和java如出一辙。重写所有抽象字段和方法。</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">val</span><span class="hljs-operator">/</span>var p<span class="hljs-operator">:</span> baseClass <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">baseClass</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-operator">...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>伴生对象（Companion Object）：</p>
<ul>
<li>取代<code>static</code>语义。</li>
<li>编译后其实会生成两个类，伴生对象是伴生类（类名为对应类后加<code>$</code>符号）的单例对象。</li>
<li><code>obejct</code>，名称和类一致，必须放同一个文件，前面已经说过了。</li>
<li>常见用法：构造器私有化，用伴生对象中的工厂方法。和静态工厂方法使用起来也没有什么区别。</li>
<li>伴生对象实现<code>apply</code>方法后调用时可以省略<code>.apply</code>，直接使用<code>className(args)</code>。库中很多这种用法创建实例，是一个语法糖。</li>
<li>测试伴生对象时就在该对象内定义<code>main</code>函数编译时会出现的奇怪的访问权限问题。可能对包含入口的伴生对象做了特殊处理，具体细节尚不清楚。最好将<code>main</code>定义在单独的伴生对象内。</li>
</ul>
<p>Trait（特征&#x2F;特质）：</p>
<ul>
<li>替代java接口的概念。但比接口更为灵活，一种实现多继承的手段。</li>
<li>多个类具有相同的特征时，就可以将这个特征提取出来，用继承的方式来复用。</li>
<li>用关键字<code>trait</code>声明。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">trait</span> traitName &#123;<br>    <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>引入&#x2F;混入(mixin)特征：<ul>
<li>有父类<code>class extends baseClass with trait1 with trait2 ... &#123;&#125;</code></li>
<li>没有父类<code>class extends trait1 with trait2 ... &#123;&#125;</code></li>
</ul>
</li>
<li>其中可以定义抽象和非抽象的属性和方法。</li>
<li>匿名子类也可以引入特征。</li>
<li>特征和基类或者多个特征中重名的属性或方法需要在子类中覆写以解决冲突，最后因为动态绑定，所有使用的地方都是子类的字段或方法。属性的话需要类型一致，不然提示不兼容。方法的话参数列表不一致会视为重载而不是冲突。</li>
<li>如果基类和特征中的属性或方法一个是抽象的，一个非抽象，且兼容，那么可以不覆写。很直观，就是不能冲突不能二义就行。</li>
<li>多个特征和基类定义了同名方法的，就需要在子类重写解决冲突。其中可以调用父类和特征的方法，此时<code>super.methodName</code>指代按照顺序最后一个拥有该方法定义的特征或基类。也可以用<code>super[baseClassOrTraitName].methodName</code>直接指代某个基类的方法，注意需要是直接基类，间接基类则不行。</li>
<li>也就是说基类和特征基本是同等地位。</li>
<li>例子：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Person&quot;</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;hello from : <span class="hljs-subst">$name</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Young</span> </span>&#123;<br>    <span class="hljs-comment">// abstract and non-abstract attribute</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;young&quot;</span><br><br>    <span class="hljs-comment">// method</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;young people <span class="hljs-subst">$name</span> is playing&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dating</span></span>(): <span class="hljs-type">Unit</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Knowledge</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> amount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        amount += <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Talent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;increase talent&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Young</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Knowledge</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Talent</span></span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;alice&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dating</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;Sutdent <span class="hljs-subst">$name</span> <span class="hljs-subst">$age</span> is dating&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span></span>(): <span class="hljs-type">Unit</span> = println(<span class="hljs-string">s&quot;Student <span class="hljs-subst">$name</span> is studying&quot;</span>)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">super</span>.sayHi()<br>        println(<span class="hljs-string">s&quot;hello from : student <span class="hljs-subst">$name</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increase</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">super</span>.increase() <span class="hljs-comment">// call Talent.increase(), just the last</span><br>        println(<span class="hljs-string">s&quot;studnet <span class="hljs-subst">$name</span> knowledge increase: <span class="hljs-subst">$amount</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Trait</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> s = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>()<br>        s.sayHi()<br>        s.increase()<br><br>        s.study()<br>        s.increase()<br><br>        s.play()<br>        s.increase()<br><br>        s.dating()<br>        s.increase()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>特征的继承：<code>trait childTrait extends baseTrait</code></li>
<li>特征的<strong>菱形继承</strong>解决方式：转换为线性的继承链条，在前面的成为基类，后面的成为子类。</li>
<li>例子：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = <span class="hljs-string">&quot;ball&quot;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ColorBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;red&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = color + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">CategoryBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> category: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;foot&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = category + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-keyword">super</span>.describe()<br>&#125;<br><br><span class="hljs-comment">// equals to MyFootBall -&gt; ColorBall -&gt; CategoryBall -&gt; Ball</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFootBall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CategoryBall</span> <span class="hljs-keyword">with</span> <span class="hljs-title">ColorBall</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(): <span class="hljs-type">String</span> = <span class="hljs-keyword">super</span>.describe()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TraitInheritance</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">MyFootBall</span>()<br>        println(b.describe()) <span class="hljs-comment">// red_foot_ball</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>其实特征的多继承和C++的多继承已经很像了，只是名称冲突的解决方式不一样，菱形继承的解决方式也不一样，而且不能访问间接基类。</li>
<li>scala<strong>单继承多实现</strong>，实现体现在特征上。基类主要用于一个对象比较核心比较本质的部分上。</li>
<li><strong>继承特征与类的区别</strong>：特征构造时不能给参数。其他都是同样的，都可以实现多态。</li>
</ul>
<p>自身类型（self type）：</p>
<ul>
<li>可实现<strong>依赖注入</strong>的功能。</li>
<li>一个类或者特征指定了自身类型的话，它的对象和子类对象就会拥有这个自身类型中的所有属性和方法。</li>
<li>是将一个类或者特征插入到另一个类或者特征中，属性和方法都就像直接复制插入过来一样，能直接使用。但不是继承，不能用多态。</li>
<li>语法，在类或特征中：<code>_: SelfType =&gt;</code>，其中<code>_</code>的位置是别名定义，也可以是其他，<code>_</code>指代<code>this</code>。插入后就可以用<code>this.xxx</code>来访问自身类型中的属性和方法了。</li>
<li>注入进来的目的是让你能够使用，可见，提前使用应该拥有的属性和方法。最终只要自身类型和注入目标类型同时被继承就能够得到定义了。</li>
<li>例子：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span>, val password: <span class="hljs-type">String</span></span>)</span><br><span class="hljs-comment">// user database access object</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// dependency injection from external</span><br>    _: <span class="hljs-type">User</span> =&gt; <span class="hljs-comment">// self type</span><br>    <span class="hljs-comment">// simulate insert data to databse</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;insert into db: <span class="hljs-subst">$name</span> <span class="hljs-subst">$password</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// register user</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterUser</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, password</span>) <span class="hljs-keyword">with</span> <span class="hljs-title">UserDao</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">SelfType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> u = <span class="hljs-keyword">new</span> <span class="hljs-type">RegisterUser</span>(<span class="hljs-string">&quot;catholly&quot;</span>, <span class="hljs-string">&quot;nephren&quot;</span>)<br>        u.insert()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行时类型识别RTTI：</p>
<ul>
<li>判断类型：<code>obj.isInstanceOf[T]</code>，确切匹配的类型或者父类都返回true。</li>
<li>转换类型：<code>obj.asInstance[T]</code>，转换为目标类型。</li>
<li>获取类名：<code>classOf[T]</code>，得到类对应的<code>Class</code>对象<code>Class[T]</code>，转字符串结果是<code>class package.xxx.className</code>。</li>
<li>获取对象的类：<code>obj.getClass</code></li>
</ul>
<p>枚举类：</p>
<ul>
<li>继承<code>Enumeration</code>。</li>
<li>用<code>Value</code>类型定义枚举值。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">WorkDay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">MONDAY</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Monday&quot;</span>)<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">TUESDAY</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>)<br>    <span class="hljs-keyword">val</span> <span class="hljs-type">THURSDAy</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Thrusday&quot;</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">EnumClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-type">WorkDay</span>.<span class="hljs-type">MONDAY</span>)<br>        println(<span class="hljs-type">WorkDay</span>.<span class="hljs-type">TUESDAY</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>应用类：</p>
<ul>
<li>继承<code>App</code>，包装了<code>main</code>方法，就不需要显式定义<code>main</code>方法了，可以直接执行。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>    println(<span class="hljs-string">&quot;hello,world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义类型别名：<code>type SelfDefineType = TargetType</code>。</p>
<p>密封类： <code>sealed</code>，子类只能定义在同一个文件内。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java集合：</p>
<ul>
<li>三大类型：列表<code>List</code>、集合<code>Set</code>、映射<code>Map</code>，有多种不同实现。</li>
</ul>
<p>Scala集合三大类型：</p>
<ul>
<li><p>序列<code>Seq</code>，集合<code>Set</code>，映射<code>Map</code>，所有集合都扩展自<code>Iterable</code>。</p>
</li>
<li><p>对于几乎所有集合类，都同时提供</p>
<p>可变和不可变</p>
<p>版本。</p>
<ul>
<li>不可变集合：<code>scala.collection.immutable</code></li>
<li>可变集合：<code>scala.collection.mutable</code></li>
<li>两个包中可能有同名的类型，需要注意区分是用的可变还是不可变版本，避免冲突和混淆。</li>
</ul>
</li>
<li><p>对于不可变集合，指该集合长度数量不可修改，每次修改（比如增删元素）都会返回一个新的对象，而不会修改源对象。</p>
</li>
<li><p>可变集合可以对源对象任意修改，一般也提供不可变集合相同的返回新对象的方法，但也可以用其他方法修改源对象。</p>
</li>
<li><p><strong>建议</strong>：操作集合时，不可变用操作符，可变用方法。操作符也不一定就会返回新对象，但大多是这样的，还是要具体看。</p>
</li>
<li><p>scala中集合类的定义比java要清晰不少。</p>
</li>
</ul>
<p>不可变集合：</p>
<ul>
<li><code>scala.collection.immutable</code>包中不可变集合关系一览： <a target="_blank" rel="noopener" href="https://github.com/tch0/notes/blob/master/Images/Scala_immutable_collections_tree.jpg"><img src="https://github.com/tch0/notes/raw/master/Images/Scala_immutable_collections_tree.jpg" srcset="/img/loading.gif" lazyload alt="Scala_mutable_collections_tree"></a></li>
<li>不可变集合没有太多好说的，集合和映射的哈希表和二叉树实现是肯定都有的，序列中分为随机访问序列（数组实现）和线性序列（链表实现），基本数据结构都有了。</li>
<li><code>Range</code>是范围，常用来遍历，有语法糖支持<code>1 to 10 by 2</code> <code>10 until 1 by -1</code>其实就是隐式转换加上方法调用。</li>
<li>scala中的<code>String</code>就是<code>java.lang.String</code>，和集合无直接关系，所以是虚箭头，是通过<code>Perdef</code>中的低优先级隐式转换来做到的。经过隐式转换为一个包装类型后就可以当做集合了。</li>
<li><code>Array</code>和<code>String</code>类似，在图中漏掉了。</li>
<li>此类包装为了兼容java在scala中非常常见，scala中很多类型就是对java类型的包装或者仅仅是别名。</li>
<li>scala中可能会推荐更多地使用不可变集合。能用不可变就用不可变。</li>
</ul>
<p>可变集合：</p>
<ul>
<li><code>scala.collection.mutable</code>包中可变集合关系一览：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_mutable_collections_tree.jpeg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>序列中多了<code>Buffer</code>，整体结构差不多。</li>
</ul>
<p>不可变和可变：</p>
<ul>
<li>不可变指的是对象大小不可变，但是可以修改元素的值（不能修改那创建了也没有用对吧），需要注意这一点。而如果用了<code>val</code>不变量存储，那么指向对象的地址也不可变。</li>
<li>不可变集合在原集合上个插入删除数据是做不到的，只能返回新的集合。</li>
</ul>
<p>泛型：</p>
<ul>
<li>集合类型大多都是支持泛型，使用泛型的语法是<code>[Type]</code>，不同于java的<code>&lt;Type&gt;</code>。</li>
</ul>
<p>不可变数组：</p>
<ul>
<li>访问元素使用<code>()</code>运算符，通过<code>apply/update</code>方法实现，源码中的实现只是抛出错误作为<strong>存根方法</strong>（stab method），具体逻辑由编译器填充。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 1. new</span><br>val arr = new Array<span class="hljs-selector-attr">[Int]</span>(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 2. factory method in companion obejct</span><br>val arr1 = Array<span class="hljs-selector-attr">[Int]</span>(<span class="hljs-number">5</span>)<br>val arr2 = <span class="hljs-built_in">Array</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// 3. traverse, range for</span><br><span class="hljs-keyword">for</span> (<span class="hljs-selector-tag">i</span> &lt;- <span class="hljs-number">0</span> until arr.length) <span class="hljs-built_in">arr</span>(i) = <span class="hljs-selector-tag">i</span><br><span class="hljs-keyword">for</span> (<span class="hljs-selector-tag">i</span> &lt;- arr.indices) <span class="hljs-built_in">print</span>(s<span class="hljs-string">&quot;$&#123;arr(i)&#125; &quot;</span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// 4. tarverse, foreach</span><br><span class="hljs-keyword">for</span> (elem &lt;- arr) <span class="hljs-built_in">print</span>(s<span class="hljs-string">&quot;$elem &quot;</span>) <span class="hljs-comment">// elem is a val</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// 5. tarverse, use iterator</span><br>val iter = arr<span class="hljs-selector-class">.iterator</span><br>while (iter.hasNext)<br>    <span class="hljs-built_in">print</span>(s<span class="hljs-string">&quot;$&#123;iter.next()&#125; &quot;</span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// 6. traverse, use foreach method, pass a function</span><br>arr<span class="hljs-selector-class">.foreach</span>((elem: Int) =&gt; <span class="hljs-built_in">print</span>(s<span class="hljs-string">&quot;$elem &quot;</span>))<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">()</span></span><br><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr2.mkString(<span class="hljs-string">&quot;, &quot;</span>)</span></span>) <span class="hljs-comment">// to string directly</span><br><br><span class="hljs-comment">// 7. add element, return a new array, : should toward to object</span><br>val newArr = arr :+ <span class="hljs-number">10</span> <span class="hljs-comment">//  arr.:+(10) add to end</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(newArr.mkString(<span class="hljs-string">&quot;, &quot;</span>)</span></span>)<br>val newArr2 = <span class="hljs-number">20</span> +: <span class="hljs-number">10</span> +: arr :+ <span class="hljs-number">30</span> <span class="hljs-comment">// arr.+:(10).+:(20).:+(30)</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(newArr2.mkString(<span class="hljs-string">&quot;, &quot;</span>)</span></span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>可以看到自定义运算符可以非常灵活，规定如果运算符首尾有<code>:</code>那么<code>:</code>一定要指向对象。</li>
<li>下标越界当然会抛出异常，使用前应该检查。</li>
<li>通过<code>Predef</code>中的隐式转换为一个混入了集合相关特征的包装类型从而得以使用scala的集合相关特征，<code>Array</code>类型中并没有相关混入。</li>
</ul>
<p>可变数组：</p>
<ul>
<li>类型<code>ArrayBuffer</code>。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 1. create</span><br>val arr: ArrayBuffer<span class="hljs-selector-attr">[Int]</span> = new ArrayBuffer<span class="hljs-selector-attr">[Int]</span>()<br>val arr1: ArrayBuffer<span class="hljs-selector-attr">[Int]</span> = <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr.mkString(<span class="hljs-string">&quot;, &quot;</span>)</span></span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr1)</span></span> <span class="hljs-comment">// call toString ArrayBuffer(10, 20, 30)</span><br><br><span class="hljs-comment">// 2. visit</span><br><span class="hljs-function"><span class="hljs-title">arr1</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span> = <span class="hljs-number">10</span><br><span class="hljs-comment">// 3. add element to tail</span><br><span class="hljs-selector-tag">var</span> newArr = arr :+ <span class="hljs-number">15</span> :+ <span class="hljs-number">20</span> <span class="hljs-comment">// do not change arr</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(newArr)</span></span><br>newArr = arr += <span class="hljs-number">15</span> <span class="hljs-comment">// modify arr itself, add to tail return itself, do notrecommand assign to other var</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr)</span></span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(newArr == arr)</span></span> <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 4. add to head</span><br><span class="hljs-number">77</span> +=: arr <span class="hljs-comment">// WTF?</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr)</span></span><br><span class="hljs-comment">// 5. insert to middle</span><br>arr<span class="hljs-selector-class">.insert</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr)</span></span><br><span class="hljs-comment">// 6. remove element</span><br>arr<span class="hljs-selector-class">.remove</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// startIndex, count</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr)</span></span><br>arr -= <span class="hljs-number">15</span> <span class="hljs-comment">// remove specific element</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(arr)</span></span><br><span class="hljs-comment">// 7. convert to Array</span><br>val newImmuArr: Array<span class="hljs-selector-attr">[Int]</span> = arr<span class="hljs-selector-class">.toArray</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(newImmuArr.mkString(<span class="hljs-string">&quot;, &quot;</span>)</span></span>)<br><span class="hljs-comment">// 8. Array to ArryBuffer</span><br>val buffer: scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span><span class="hljs-selector-class">.Buffer</span><span class="hljs-selector-attr">[Int]</span> = newImmuArr<span class="hljs-selector-class">.toBuffer</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(buffer)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>推荐：不可变集合用运算符，可变集合直接调用对应方法。运算符容易迷惑。</li>
<li>更多方法查看文档和源码用到去找就行。</li>
<li>可变数组和不可变数组可以调用方法互相转换。</li>
</ul>
<p>二维数组：</p>
<ul>
<li>就是数组的数组。</li>
<li>使用<code>Array.ofDim[Type](firstDim, secondDim, ...)</code>方法。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// create 2d array</span><br>val arr: Array<span class="hljs-selector-attr">[Array[Int]</span>] = Array<span class="hljs-selector-class">.ofDim</span><span class="hljs-selector-attr">[Int]</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-function"><span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span> = <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">100</span><br> <br><span class="hljs-comment">// traverse</span><br>arr<span class="hljs-selector-class">.foreach</span>(v =&gt; <span class="hljs-built_in">println</span>(v<span class="hljs-selector-class">.mkString</span>(<span class="hljs-string">&quot;,&quot;</span>)))<br></code></pre></td></tr></table></figure>

<p>不可变列表：</p>
<ul>
<li><code>List</code>，抽象类，不能直接<code>new</code>，使用伴生对象<code>apply</code>传入元素创建。</li>
<li><code>List</code>本身也有<code>apply</code>能随机访问（做了优化），但是不能<code>update</code>更改。</li>
<li><code>foreach</code>方法遍历。</li>
<li>支持<code>+: :+</code>首尾添加元素。</li>
<li><code>Nil</code>空列表，<code>::</code>添加元素到表头。</li>
<li>常用<code>Nil.::(elem)</code>创建列表，换一种写法就是<code>10 :: 20 :: 30 :: Nil</code>得到结果<code>List(10, 20, 30)</code>，糖是真滴多！</li>
<li>合并两个列表：<code>list1 ::: list2</code> 或者<code>list1 ++ list2</code>。</li>
</ul>
<p>可变列表：</p>
<ul>
<li>可变列表<code>ListBuffer</code>，和<code>ArrayBuffer</code>很像。</li>
<li><code>final</code>的，可以直接<code>new</code>，也可以伴生对象<code>apply</code>传入元素创建（总体来说scala中更推荐这种方式）。</li>
<li>方法：<code>append prepend insert remove</code></li>
<li>添加元素到头或尾：<code>+=: +=</code></li>
<li>合并：<code>++</code>得到新的列表，<code>++=</code>合并到源上。</li>
<li>删除元素也可以用<code>-=</code>运算符。</li>
<li>具体操作很多，使用时阅读文档即可。</li>
</ul>
<p>不可变集合：</p>
<ul>
<li>数据无序，不可重复。</li>
<li>可变和不可变都叫<code>Set</code>，需要做区分。默认<code>Set</code>定义为<code>immutable.Set</code>别名。</li>
<li>创建时重复数据会被去除，可用来去重。</li>
<li>添加元素：<code>set + elem</code></li>
<li>合并：<code>set1 ++ set2</code></li>
<li>移除元素：<code>set - elem</code></li>
<li>不改变源集合。</li>
</ul>
<p>可变集合：</p>
<ul>
<li>操作基于源集合做更改。</li>
<li>为了与不可变集合区分，<code>import scala.collection.mutable</code>并用<code>mutable.Set</code>。</li>
<li>不可变集合有的都有。</li>
<li>添加元素到源上：<code>set += elem</code> <code>add</code></li>
<li>删除元素：<code>set -= elem</code> <code>remove</code></li>
<li>合并：<code>set1 ++= set2</code></li>
<li>都很简单很好理解，多看文档和源码就行。</li>
</ul>
<p>不可变映射：</p>
<ul>
<li><code>Map</code>默认就是<code>immutable.Map</code>别名。</li>
<li>两个泛型类型。</li>
<li>基本元素是一个二元组。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// create Map</span><br>val map: Map<span class="hljs-selector-attr">[String, Int]</span> = <span class="hljs-built_in">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">13</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">20</span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map)</span></span><br><span class="hljs-comment">// traverse</span><br>map<span class="hljs-selector-class">.foreach</span>((kv: (String, Int)) =&gt; <span class="hljs-built_in">println</span>(kv))<br>map<span class="hljs-selector-class">.foreach</span>(kv =&gt; <span class="hljs-built_in">println</span>(s<span class="hljs-string">&quot;$&#123;kv._1&#125; : $&#123;kv._2&#125;&quot;</span>))<br><span class="hljs-comment">// get keys and values</span><br><span class="hljs-keyword">for</span> (key &lt;- map.keys) &#123;<br>    <span class="hljs-built_in">println</span>(s<span class="hljs-string">&quot;$&#123;key&#125; : $&#123;map.get(key)&#125;&quot;</span>)<br>&#125;<br><span class="hljs-comment">// get value of given key</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map.get(<span class="hljs-string">&quot;a&quot;</span>)</span></span>.get)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map.getOrElse(<span class="hljs-string">&quot;c&quot;</span>, -<span class="hljs-number">1</span>)</span></span>) <span class="hljs-comment">// avoid excption</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map(<span class="hljs-string">&quot;a&quot;</span>)</span></span>) <span class="hljs-comment">// if no such key will throw exception</span><br><span class="hljs-comment">// merge</span><br>val map2 = map ++ <span class="hljs-built_in">Map</span>(<span class="hljs-string">&quot;e&quot;</span> -&gt; <span class="hljs-number">1024</span>)<br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map2)</span></span><br></code></pre></td></tr></table></figure>

<p>可变映射：</p>
<ul>
<li><code>mutable.Map</code></li>
<li>不可变的都支持。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// create mutable Map</span><br>val map: mutable<span class="hljs-selector-class">.Map</span><span class="hljs-selector-attr">[String, Int]</span> = mutable<span class="hljs-selector-class">.Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">20</span>)<br><span class="hljs-comment">// add element</span><br>map<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">30</span>)<br>map += ((<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">40</span>)) <span class="hljs-comment">// two () represent tuple to avoid ambiguity</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map)</span></span><br><span class="hljs-comment">// remove element</span><br>map<span class="hljs-selector-class">.remove</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>map -= <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-comment">// just need key</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map)</span></span><br><span class="hljs-comment">// modify element</span><br>map<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// call update, add/modify</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map)</span></span><br><span class="hljs-comment">// merge Map</span><br>map ++= <span class="hljs-built_in">Map</span>(<span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-number">20</span>, <span class="hljs-string">&quot;c&quot;</span> -&gt; <span class="hljs-number">30</span>) <span class="hljs-comment">// add and will override</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(map)</span></span><br></code></pre></td></tr></table></figure>

<p>元组：</p>
<ul>
<li><code>(elem1, elem2, ...)</code> 类型可以不同。</li>
<li>最多只能22个元素，从<code>Tuple1</code>定义到了<code>Tuple22</code>。</li>
<li>使用<code>_1 _2 _3 ...</code>访问。</li>
<li>也可以使用<code>productElement(index)</code>访问，下标从0开始。</li>
<li><code>-&gt;</code>创建二元组。</li>
<li>遍历：<code>for(elem &lt;- tuple.productIterator)</code></li>
<li>可以嵌套，元组的元素也可以是元组。</li>
</ul>
<p>集合通用属性和方法：</p>
<ul>
<li>线性序列才有长度<code>length</code>、所有集合类型都有大小<code>size</code>。</li>
<li>遍历<code>for (elem &lt;- collection)</code>、迭代器<code>for (elem &lt;- collection.iterator)</code>。</li>
<li>生成字符串<code>toString</code> <code>mkString</code>，像<code>Array</code>这种是隐式转换为scala集合的，<code>toString</code>是继承自<code>java.lang.Object</code>的，需要自行处理。</li>
<li>是否包含元素<code>contains</code>。</li>
</ul>
<p>衍生集合的方式：</p>
<ul>
<li>获取集合的头元素<code>head</code>（元素）和剩下的尾<code>tail</code>（集合）。</li>
<li>集合最后一个元素<code>last</code>（元素）和除去最后一个元素的初始数据<code>init</code>（集合）。</li>
<li>反转<code>reverse</code>。</li>
<li>取前后n个元素<code>take(n) takeRight(n)</code></li>
<li>去掉前后n个元素<code>drop(n) dropRight(n)</code></li>
<li>交集<code>intersect</code></li>
<li>并集<code>union</code>，线性序列的话已废弃用<code>concat</code>连接。</li>
<li>差集<code>diff</code>，得到属于自己、不属于传入参数的部分。</li>
<li>拉链<code>zip</code>，得到两个集合对应位置元素组合起来构成二元组的集合，大小不匹配会丢掉其中一个集合不匹配的多余部分。</li>
<li>滑窗<code>sliding(n, step = 1)</code>，框住特定个数元素，方便移动和操作。得到迭代器，可以用来遍历，每个迭代的元素都是一个n个元素集合。步长大于1的话最后一个窗口元素数量可能个数会少一些。</li>
</ul>
<p>集合的简单计算操作：</p>
<ul>
<li>求和<code>sum</code> 求乘积<code>product</code> 最小值<code>min</code> 最大值<code>max</code></li>
<li><code>maxBy(func)</code>支持传入一个函数获取元素并返回比较依据的值，比如元组默认就只会判断第一个元素，要根据第二个元素判断就返回第二个元素就行<code>xxx.maxBy(_._2)</code>。</li>
<li>排序<code>sorted</code>，默认从小到大排序。从大到小排序<code>sorted(Ordering[Int].reverse)</code>。</li>
<li>按元素排序<code>sortBy(func)</code>，指定要用来做排序的字段。也可以再传一个隐式参数逆序<code>sortBy(func)(Ordering[Int].reverse)</code></li>
<li>自定义比较器<code>sortWith(cmp)</code>，比如按元素升序排列<code>sortWith((a, b) =&gt; a &lt; b)</code>或者<code>sortWith(_ &lt; _)</code>，按元组元素第二个元素升序<code>sortWith(_._2 &gt; _._2)</code>。</li>
<li>例子：</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs processing">object Calculations &#123;<br>    def <span class="hljs-title function_">main</span>(args: <span class="hljs-built_in">Array</span>[<span class="hljs-built_in">String</span>]): Unit = &#123;<br>        <span class="hljs-comment">// calculations of collections</span><br>        val list = <span class="hljs-title function_">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>        <br>        <span class="hljs-comment">// sum</span><br>        var sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> (elem &lt;- list) sum += elem<br>        <span class="hljs-built_in">println</span>(sum)<br>        <br>        <span class="hljs-built_in">println</span>(list.<span class="hljs-property">sum</span>)<br>        <span class="hljs-built_in">println</span>(list.<span class="hljs-property">product</span>)<br>        <span class="hljs-built_in">println</span>(list.<span class="hljs-property">min</span>)<br>        <span class="hljs-built_in">println</span>(list.<span class="hljs-property">max</span>)<br><br>        val list2 = <span class="hljs-title function_">List</span>((<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">-3</span>))<br>        <span class="hljs-built_in">println</span>(list2.<span class="hljs-property">maxBy</span>((tuple: (Char, Int)) =&gt; tuple._2))<br>        <span class="hljs-built_in">println</span>(list2.<span class="hljs-property">minBy</span>(_._2))<br><br>        <span class="hljs-comment">// sort, default is ascending</span><br>        val sortedList = list.<span class="hljs-property">sorted</span><br>        <span class="hljs-built_in">println</span>(sortedList)<br>        <span class="hljs-comment">// descending</span><br>        <span class="hljs-built_in">println</span>(list.<span class="hljs-property">sorted</span>(Ordering[Int].<span class="hljs-property">reverse</span>))<br><br>        <span class="hljs-comment">// sortBy</span><br>        <span class="hljs-built_in">println</span>(list2.<span class="hljs-property">sortBy</span>(_._2))<br><br>        <span class="hljs-comment">// sortWith</span><br>        <span class="hljs-built_in">println</span>(list.<span class="hljs-property">sortWith</span>((a, b) =&gt; a &lt; b))<br>        <span class="hljs-built_in">println</span>(list2.<span class="hljs-property">sortWith</span>(_._2 &gt; _._2))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>简单操作还是太少了，不足以应对复杂的需求。</li>
</ul>
<p>集合高级计算函数：</p>
<ul>
<li>大数据的处理核心就是映射（map）和规约（reduce）。</li>
<li>映射操作（广义上的map）：<ul>
<li>过滤：自定义过滤条件，<code>filter(Elem =&gt; Boolean)</code></li>
<li>转化&#x2F;映射（狭义上的map）：自定义映射函数，<code>map(Elem =&gt; NewElem)</code></li>
<li>扁平化（flatten）：将集合中集合元素拆开，去掉里层集合，放到外层中来。<code>flatten</code></li>
<li>扁平化+映射：先映射，再扁平化，<code>flatMap(Elem =&gt; NewElem)</code></li>
<li>分组（group）：指定分组规则，<code>groupBy(Elem =&gt; Key)</code>得到一个Map，key根据传入的函数运用于集合元素得到，value是对应元素的序列。</li>
</ul>
</li>
<li>规约操作（广义的reduce）：<ul>
<li>简化&#x2F;规约（狭义的reduce）：对所有数据做一个处理，规约得到一个结果（比如连加连乘操作）。<code>reduce((CurRes, NextElem) =&gt; NextRes)</code>，传入函数有两个参数，第一个参数是第一个元素（第一次运算）和上一轮结果（后面的计算），第二个是当前元素，得到本轮结果，最后一轮的结果就是最终结果。<code>reduce</code>调用<code>reduceLeft</code>从左往右，也可以<code>reduceRight</code>从右往左（实际上是递归调用，和一般意义上的从右往左有区别，看下面例子）。</li>
<li>折叠（fold）：<code>fold(InitialVal)((CurRes, Elem) =&gt; NextRes)</code>相对于<code>reduce</code>来说其实就是<code>fold</code>自己给初值，从第一个开始计算，<code>reduce</code>用第一个做初值，从第二个元素开始算。<code>fold</code>调用<code>foldLeft</code>，从右往左则用<code>foldRight</code>（翻转之后再<code>foldLeft</code>）。具体逻辑还得还源码。从右往左都有点绕和难以理解，如果要使用需要特别注意。</li>
</ul>
</li>
<li>以上：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">object</span> HighLevelCalculations &#123;<br>    def main(args: Array<span class="hljs-literal">[S<span class="hljs-identifier">tring</span>]</span>): Unit = &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-built_in">list</span> = <span class="hljs-constructor">List(1, 10, 100, 3, 5, 111)</span><br>        <br>        <span class="hljs-comment">// 1. map functions</span><br>        <span class="hljs-comment">// filter</span><br>        <span class="hljs-keyword">val</span> evenList = <span class="hljs-built_in">list</span>.filter(_ % <span class="hljs-number">2</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>        println(evenList)<br><br>        <span class="hljs-comment">// map</span><br>        println(<span class="hljs-built_in">list</span>.map(_<span class="hljs-operator"> * </span><span class="hljs-number">2</span>))<br>        println(<span class="hljs-built_in">list</span>.map(x =&gt; x<span class="hljs-operator"> * </span>x))<br><br>        <span class="hljs-comment">// flatten</span><br>        <span class="hljs-keyword">val</span> nestedList: List<span class="hljs-literal">[L<span class="hljs-identifier">ist</span>[I<span class="hljs-identifier">nt</span>]</span>] = <span class="hljs-constructor">List(List(1, 2, 3)</span>, <span class="hljs-constructor">List(3, 4, 5)</span>, <span class="hljs-constructor">List(10, 100)</span>)<br>        <span class="hljs-keyword">val</span> flatList = nested<span class="hljs-constructor">List(0)</span> ::: nested<span class="hljs-constructor">List(1)</span> ::: nested<span class="hljs-constructor">List(2)</span><br>        println(flatList)<br><br>        <span class="hljs-keyword">val</span> flatList2 = nestedList.flatten<br>        println(flatList2) <span class="hljs-comment">// equals to flatList</span><br><br>        <span class="hljs-comment">// map and flatten</span><br>        <span class="hljs-comment">// example: change a string list into a word list</span><br>        <span class="hljs-keyword">val</span> strings: List<span class="hljs-literal">[S<span class="hljs-identifier">tring</span>]</span> = <span class="hljs-constructor">List(<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-string">&quot;yes no&quot;</span>)</span><br>        <span class="hljs-keyword">val</span> splitList: List<span class="hljs-literal">[A<span class="hljs-identifier">rray</span>[S<span class="hljs-identifier">tring</span>]</span>] = strings.map(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>split(<span class="hljs-string">&quot; &quot;</span>)) <span class="hljs-comment">// divide string to words</span><br>        <span class="hljs-keyword">val</span> flattenList = splitList.flatten<br>        println(flattenList)<br><br>        <span class="hljs-comment">// merge two steps above into one</span><br>        <span class="hljs-comment">// first map then flatten</span><br>        <span class="hljs-keyword">val</span> flatMapList = strings.flat<span class="hljs-constructor">Map(<span class="hljs-params">_</span>.<span class="hljs-params">split</span>(<span class="hljs-string">&quot; &quot;</span>)</span>)<br>        println(flatMapList)<br><br>        <span class="hljs-comment">// divide elements into groups</span><br>        <span class="hljs-keyword">val</span> groupMap = <span class="hljs-built_in">list</span>.group<span class="hljs-constructor">By(<span class="hljs-params">_</span> % 2)</span> <span class="hljs-comment">// keys: 0 &amp; 1</span><br>        <span class="hljs-keyword">val</span> groupMap2 = <span class="hljs-built_in">list</span>.group<span class="hljs-constructor">By(<span class="hljs-params">data</span> =&gt; <span class="hljs-params">if</span> (<span class="hljs-params">data</span> % 2 <span class="hljs-operator">==</span> 0)</span> <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;odd&quot;</span>) <span class="hljs-comment">// keys : &quot;even&quot; &amp; &quot;odd&quot;</span><br>        println(groupMap)<br>        println(groupMap2)<br><br>        <span class="hljs-keyword">val</span> worldList = <span class="hljs-constructor">List(<span class="hljs-string">&quot;China&quot;</span>, <span class="hljs-string">&quot;America&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Curry&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Japan&quot;</span>)</span><br>        println(worldList.group<span class="hljs-constructor">By(<span class="hljs-params">_</span>.<span class="hljs-params">charAt</span>(0)</span>))<br><br>        <span class="hljs-comment">// 2. reduce functions</span><br>        <span class="hljs-comment">// narrowly reduce</span><br>        println(<span class="hljs-constructor">List(1, 2, 3, 4)</span>.reduce(_ + _)) <span class="hljs-comment">// 1+2+3+4 = 10</span><br>        println(<span class="hljs-constructor">List(1, 2, 3, 4)</span>.reduce<span class="hljs-constructor">Left(<span class="hljs-params">_</span> - <span class="hljs-params">_</span>)</span>) <span class="hljs-comment">// 1-2-3-4 = -8</span><br>        println(<span class="hljs-constructor">List(1, 2, 3, 4)</span>.reduce<span class="hljs-constructor">Right(<span class="hljs-params">_</span> - <span class="hljs-params">_</span>)</span>) <span class="hljs-comment">// 1-(2-(3-4)) = -2, a little confusing</span><br><br>        <span class="hljs-comment">// fold</span><br>        println(<span class="hljs-constructor">List(1, 2, 3, 4)</span>.fold(<span class="hljs-number">0</span>)(_ + _)) <span class="hljs-comment">// 0+1+2+3+4 = 10</span><br>        println(<span class="hljs-constructor">List(1, 2, 3, 4)</span>.fold(<span class="hljs-number">10</span>)(_ + _)) <span class="hljs-comment">// 10+1+2+3+4 = 20</span><br>        println(<span class="hljs-constructor">List(1, 2, 3, 4)</span>.fold<span class="hljs-constructor">Right(10)</span>(_ - _)) <span class="hljs-comment">// 1-(2-(3-(4-10))) = 8, a little confusing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>集合应用案例：</p>
<ul>
<li>Map的默认合并操作是用后面的同key元素覆盖前面的，如果要定制为累加他们的值可以用<code>fold</code>。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// merging two Map will override the value of the same key</span><br><span class="hljs-comment">// custom the merging process instead of just override</span><br><span class="hljs-keyword">val</span> map1 = <span class="hljs-constructor">Map(<span class="hljs-string">&quot;a&quot;</span> -&gt; 1, <span class="hljs-string">&quot;b&quot;</span> -&gt; 3, <span class="hljs-string">&quot;c&quot;</span> -&gt; 4)</span><br><span class="hljs-keyword">val</span> map2 = <span class="hljs-keyword">mutable</span>.<span class="hljs-constructor">Map(<span class="hljs-string">&quot;a&quot;</span> -&gt; 6, <span class="hljs-string">&quot;b&quot;</span> -&gt; 2, <span class="hljs-string">&quot;c&quot;</span> -&gt; 5, <span class="hljs-string">&quot;d&quot;</span> -&gt; 10)</span><br><span class="hljs-keyword">val</span> map3 = map1.fold<span class="hljs-constructor">Left(<span class="hljs-params">map2</span>)</span>(<br>   <span class="hljs-function"> (<span class="hljs-params">mergedMap</span>, <span class="hljs-params">kv</span>) =&gt;</span> &#123;<br>        merged<span class="hljs-constructor">Map(<span class="hljs-params">kv</span>.<span class="hljs-params">_1</span>)</span> = mergedMap.get<span class="hljs-constructor">OrElse(<span class="hljs-params">kv</span>.<span class="hljs-params">_1</span>, 0)</span> + kv._2<br>        mergedMap<br>    &#125;<br>)<br>println(map3) <span class="hljs-comment">// HashMap(a -&gt; 7, b -&gt; 5, c -&gt; 9, d -&gt; 10)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>经典案例：单词计数：分词，计数，取排名前三结果。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// count words in string list, and get 3 highest frequency words</span><br>def wordCount(): <span class="hljs-type">Unit </span>= &#123;<br>    val stringList: <span class="hljs-type">List</span>[<span class="hljs-keyword">String</span>] = List(<br>        <span class="hljs-string">&quot;hello&quot;</span>,<br>        <span class="hljs-string">&quot;hello world&quot;</span>,<br>        <span class="hljs-string">&quot;hello scala&quot;</span>,<br>        <span class="hljs-string">&quot;hello spark from scala&quot;</span>,<br>        <span class="hljs-string">&quot;hello flink from scala&quot;</span><br>    )<br><br>    <span class="hljs-comment">// 1. split</span><br>    val wordList: <span class="hljs-type">List</span>[<span class="hljs-keyword">String</span>] = stringList.flatMap(<span class="hljs-literal">_</span>.split(<span class="hljs-string">&quot; &quot;</span>))<br>    println(wordList)<br><br>    <span class="hljs-comment">// 2. group same words</span><br>    val groupMap: <span class="hljs-type">Map</span>[<span class="hljs-keyword">String</span>, List[<span class="hljs-keyword">String</span>]] = wordList.groupBy(word =&gt; word)<br>    println(groupMap)<br><br>    <span class="hljs-comment">// 3. get length of the every word, to (word, length)</span><br>    val countMap: <span class="hljs-type">Map</span>[<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Int</span>] = groupMap.map(kv =&gt; (kv._1, kv._2.length))<br><br>    <span class="hljs-comment">// 4. convert map to list, sort and take first 3</span><br>    val countList: <span class="hljs-type">List</span>[(<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Int</span>)] = countMap.toList<br>        .sortWith(<span class="hljs-literal">_</span>._2 &gt; <span class="hljs-literal">_</span>._2)<br>        .take(<span class="hljs-number">3</span>)<br><br>    println(countList) <span class="hljs-comment">// result</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>单词计数案例扩展，每个字符串都可能出现多次并且已经统计好出现次数，解决方式，先按次数合并之后再按照上述例子处理。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// strings has their frequency</span><br>def wordCountAdvanced(): Unit = &#123;<br>    val tupleList: List[(String, Int)] = List(<br>        (<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-number">2</span>),<br>        (<span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-number">3</span>),<br>        (<span class="hljs-string">&quot;hello spark from scala&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello flink from scala&quot;</span>, <span class="hljs-number">2</span>)<br>    )<br><br>    val newStringList: List[String] = tupleList.<span class="hljs-built_in">map</span>(<br>        <span class="hljs-function"><span class="hljs-params">kv</span> =&gt;</span> (kv._1.<span class="hljs-built_in">trim</span> + <span class="hljs-string">&quot; &quot;</span>) * kv._2<br>    )<br><br>    <span class="hljs-comment">// just like wordCount</span><br>    val wordCountList: List[(String, Int)] = newStringList<br>        .flatMap(_.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot; &quot;</span>))<br>        .<span class="hljs-built_in">groupBy</span>(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word)<br>        .<span class="hljs-built_in">map</span>(<span class="hljs-function"><span class="hljs-params">kv</span> =&gt;</span> (kv._1, kv._2.<span class="hljs-built_in">length</span>))<br>        .toList<br>        .sortWith(_._2 &gt; _._2)<br>        .take(<span class="hljs-number">3</span>)<br><br>    println(wordCountList) <span class="hljs-comment">// result</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当然这并不高效，更好的方式是利用上已经统计的频率信息。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arcade">def wordCountAdvanced2(): Unit = &#123;<br>    val tupleList: List[(String, Int)] = List(<br>        (<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-number">2</span>),<br>        (<span class="hljs-string">&quot;hello scala&quot;</span>, <span class="hljs-number">3</span>),<br>        (<span class="hljs-string">&quot;hello spark from scala&quot;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&quot;hello flink from scala&quot;</span>, <span class="hljs-number">2</span>)<br>    )<br><br>    <span class="hljs-comment">// first split based on the input frequency</span><br>    val preCountList: List[(String, Int)] = tupleList.flatMap(<br>        <span class="hljs-function"><span class="hljs-params">tuple</span> =&gt;</span> &#123;<br>            val strings: <span class="hljs-built_in">Array</span>[String] = tuple._1.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot; &quot;</span>)<br>            strings.<span class="hljs-built_in">map</span>(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> (word, tuple._2)) <span class="hljs-comment">// Array[(String, Int)]</span><br>        &#125;<br>    )<br><br>    <span class="hljs-comment">// group as words</span><br>    val groupedMap: <span class="hljs-built_in">Map</span>[String, List[(String, Int)]] = preCountList.<span class="hljs-built_in">groupBy</span>(_._1)<br>    println(groupedMap)<br><br>    <span class="hljs-comment">// count frequency of all words</span><br>    val countMap: <span class="hljs-built_in">Map</span>[String, Int] = groupedMap.<span class="hljs-built_in">map</span>(<br>        <span class="hljs-function"><span class="hljs-params">kv</span> =&gt;</span> (kv._1, kv._2.<span class="hljs-built_in">map</span>(_._2).<span class="hljs-built_in">sum</span>)<br>    )<br>    println(countMap)<br><br>    <span class="hljs-comment">// to list, sort and take first 3 words</span><br>    val countList = countMap.toList.sortWith(_._2 &gt; _._2).take(<span class="hljs-number">3</span>)<br>    println(countList)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>队列：</p>
<ul>
<li>可变队列<code>mutable.Queue</code></li>
<li>入队<code>enqueue(Elem*)</code> 出队<code>Elem = dequeue()</code></li>
<li>不可变队列<code>immutable.Queue</code>，使用伴生对象创建，出队入队返回新队列。</li>
</ul>
<p>并行集合（Parllel Collection）：</p>
<ul>
<li>使用并行集合执行时会调用多个线程加速执行。</li>
<li>使用集合类前加一个<code>.par</code>方法。</li>
<li>具体细节待补。</li>
<li>依赖<code>scala.collection.parallel.immutable/mutable</code>，2.13版本后不再在标准库中提供，需要单独下载，暂未找到编好的jar的下载地址，从源码构造需要sbt，TODO。</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><code>match-case</code>中的模式匹配：</p>
<ul>
<li>用于替代传统C&#x2F;C++&#x2F;Java的<code>switch-case</code>结构，但补充了更多功能，拥有更强的能力。</li>
<li>语法：（Java中现在也支持<code>=&gt;</code>的写法了）</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">value <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-built_in">case</span> caseVal1 =&gt; returnVal1<br>    <span class="hljs-built_in">case</span> caseVal2 =&gt; returnVal2<br>    ...<br>    <span class="hljs-built_in">case</span> <span class="hljs-keyword">_</span> =&gt; defaultVal<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>每一个case条件成立才返回，否则继续往下走。</li>
<li><code>case</code>匹配中可以添加模式守卫，用条件判断来代替精确匹配。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">def abs(<span class="hljs-built_in">num</span>: Int): Int= &#123;<br>    <span class="hljs-built_in">num</span> match &#123;<br>        <span class="hljs-keyword">case</span> i <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> =&gt; i<br>        <span class="hljs-keyword">case</span> i <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> =&gt; -i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>模式匹配支持类型：所有类型字面量，包括字符串、字符、数字、布尔值、甚至数组列表等。</li>
<li>你甚至可以传入<code>Any</code>类型变量，匹配不同类型常量。</li>
<li>需要注意默认情况处理，<code>case _</code>也需要返回值，如果没有但是又没有匹配到，就抛出运行时错误。默认情况<code>case _</code>不强制要求通配符（只是在不需要变量的值建议这么做），也可以用<code>case abc</code>一个变量来接住，可以什么都不做，可以使用它的值。</li>
<li>通过指定匹配变量的类型（用特定类型变量接住），可以匹配类型而不匹配值，也可以混用。</li>
<li>需要注意类型匹配时由于泛型擦除，可能并不能严格匹配泛型的类型参数，编译器也会报警告。但<code>Array</code>是基本数据类型，对应于java的原生数组类型，能够匹配泛型类型参数。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// match type</span><br><span class="hljs-keyword">def</span> describeType(x: <span class="hljs-keyword">Any</span>) = x match &#123;<br>    <span class="hljs-keyword">case</span> i: <span class="hljs-keyword">Int</span> =&gt; <span class="hljs-string">&quot;Int &quot;</span> + i<br>    <span class="hljs-keyword">case</span> s: String =&gt; <span class="hljs-string">&quot;String &quot;</span> + s<br>    <span class="hljs-keyword">case</span> list: List[String] =&gt; <span class="hljs-string">&quot;List &quot;</span> + list<br>    <span class="hljs-keyword">case</span> array: Array[<span class="hljs-keyword">Int</span>] =&gt; <span class="hljs-string">&quot;Array[Int] &quot;</span> + array<br>    <span class="hljs-keyword">case</span> a =&gt; <span class="hljs-string">&quot;Something else &quot;</span> + a <br>&#125;<br><span class="hljs-keyword">println</span>(describeType(<span class="hljs-number">20</span>)) <span class="hljs-comment">// match</span><br><span class="hljs-keyword">println</span>(describeType(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// match</span><br><span class="hljs-keyword">println</span>(describeType(List(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>))) <span class="hljs-comment">// match</span><br><span class="hljs-keyword">println</span>(describeType(List(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>))) <span class="hljs-comment">// match</span><br><span class="hljs-keyword">println</span>(describeType(Array(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))) <span class="hljs-comment">// match</span><br><span class="hljs-keyword">println</span>(describeType(Array(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>))) <span class="hljs-comment">// not match</span><br><span class="hljs-keyword">println</span>(describeType((<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))) <span class="hljs-comment">// not match</span><br></code></pre></td></tr></table></figure>

<ul>
<li>对于数组可以定义多种匹配形式，可以定义模糊的元素类型匹配、元素数量匹配或者精确的某个数组元素值匹配，非常强大。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">for</span> (arr &lt;- <span class="hljs-built_in">List</span>(<br>    Array(<span class="hljs-number">0</span>),<br>    Array(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>    Array(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>    Array(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>),<br>    Array(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>)<br>)) &#123;<br>    val result = arr match &#123;<br>        <span class="hljs-keyword">case</span> Array(<span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;0&quot;</span><br>        <span class="hljs-keyword">case</span> Array(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;Array(1, 0)&quot;</span><br>        <span class="hljs-keyword">case</span> Array(x: Int, y: Int) =&gt; s<span class="hljs-string">&quot;Array(<span class="hljs-subst">$x</span>, <span class="hljs-subst">$y</span>)&quot;</span> <span class="hljs-comment">// Array of two elements</span><br>        <span class="hljs-keyword">case</span> Array(<span class="hljs-number">0</span>, _*) =&gt; s<span class="hljs-string">&quot;an array begin with 0&quot;</span><br>        <span class="hljs-keyword">case</span> Array(x, <span class="hljs-number">1</span>, z) =&gt; s<span class="hljs-string">&quot;an array with three elements, no.2 is 1&quot;</span><br>        <span class="hljs-keyword">case</span> Array(x:<span class="hljs-built_in">String</span>, _*) =&gt; s<span class="hljs-string">&quot;array that first element is a string&quot;</span><br>        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;somthing else&quot;</span><br>    &#125;<br>    println(result)<br></code></pre></td></tr></table></figure>

<ul>
<li>List匹配和Array差不多，也很灵活。还可用用集合类灵活的运算符来匹配。<ul>
<li>比如使用<code>::</code>运算符匹配<code>first :: second :: rest</code>，将一个列表拆成三份，第一个第二个元素和剩余元素构成的列表。</li>
</ul>
</li>
<li>注意模式匹配不仅可以通过返回值当做表达式来用，也可以仅执行语句类似于传统<code>switch-case</code>语句不关心返回值，也可以既执行语句同时也返回。</li>
<li>元组匹配：<ul>
<li>可以匹配n元组、匹配元素类型、匹配元素值。如果只关心某个元素，其他就可以用通配符或变量。</li>
<li>元组大小固定，所以不能用<code>_*</code>。</li>
</ul>
</li>
</ul>
<p>变量声明匹配：</p>
<ul>
<li>变量声明也可以是一个模式匹配的过程。</li>
<li>元组常用于批量赋值。</li>
<li><code>val (x, y) = (10, &quot;hello&quot;)</code></li>
<li><code>val List(first, second, _*) = List(1, 3, 4, 5)</code></li>
<li><code>val List(first :: second :: rest) = List(1, 2, 3, 4)</code></li>
</ul>
<p><code>for</code>推导式中也可以进行模式匹配：</p>
<ul>
<li>元组中取元素时，必须用<code>_1 _2 ...</code>，可以用元组赋值将元素赋给变量，更清晰一些。</li>
<li><code>for ((first, second) &lt;- tupleList)</code></li>
<li><code>for ((first, _) &lt;- tupleList)</code></li>
<li>指定特定元素的值，可以实现类似于循环守卫的功能，相当于加一层筛选。比如<code>for ((10, second) &lt;- tupleList)</code></li>
<li>其他匹配也同样可以用，可以关注数量、值、类型等，相当于做了筛选。</li>
<li>元组列表匹配、赋值匹配、<code>for</code>循环中匹配非常灵活，灵活运用可以提高代码可读性。</li>
</ul>
<p>匹配对象：</p>
<ul>
<li>对象内容匹配。</li>
<li>直接<code>match-case</code>中匹配对应引用变量的话语法是有问题的。编译报错信息提示：不是样例类也没有一个合法的<code>unapply/unapplySeq</code>成员实现。</li>
<li>要匹配对象，需要实现伴生对象<code>unapply</code>方法，用来对对象属性进行拆解以做匹配。</li>
</ul>
<p>样例类：</p>
<ul>
<li>第二种实现对象匹配的方式是样例类。</li>
<li><code>case class className</code>定义样例类，会直接将打包<code>apply</code>和拆包<code>unapply</code>的方法直接定义好。</li>
<li>样例类定义中主构造参数列表中的<code>val</code>甚至都可以省略，如果是<code>var</code>的话则不能省略，最好加上的感觉，奇奇怪怪的各种边角简化。</li>
</ul>
<p>对象匹配和样例类例子：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">object</span> MatchObject &#123;<br>    def main(args: Array<span class="hljs-literal">[S<span class="hljs-identifier">tring</span>]</span>): Unit = &#123;<br>        <span class="hljs-keyword">val</span> person = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person(<span class="hljs-string">&quot;Alice&quot;</span>, 18)</span><br><br>        <span class="hljs-keyword">val</span> result: String = person <span class="hljs-keyword">match</span> &#123;<br>            case <span class="hljs-constructor">Person(<span class="hljs-string">&quot;Alice&quot;</span>, 18)</span> =&gt; <span class="hljs-string">&quot;Person: Alice, 18&quot;</span><br>            case<span class="hljs-function"> <span class="hljs-params">_</span> =&gt;</span> <span class="hljs-string">&quot;something else&quot;</span><br>        &#125;<br>        println(result)<br><br>        <span class="hljs-keyword">val</span> s = <span class="hljs-constructor">Student(<span class="hljs-string">&quot;Alice&quot;</span>, 18)</span><br>        <span class="hljs-keyword">val</span> result2: String = s <span class="hljs-keyword">match</span> &#123;<br>            case <span class="hljs-constructor">Student(<span class="hljs-string">&quot;Alice&quot;</span>, 18)</span> =&gt; <span class="hljs-string">&quot;Student: Alice, 18&quot;</span><br>            case<span class="hljs-function"> <span class="hljs-params">_</span> =&gt;</span> <span class="hljs-string">&quot;something else&quot;</span><br>        &#125;<br>        println(result2)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-constructor">Person(<span class="hljs-params">val</span> <span class="hljs-params">name</span>: String, <span class="hljs-params">val</span> <span class="hljs-params">age</span>: Int)</span><br><span class="hljs-keyword">object</span> Person &#123;<br>    def apply(name: String, age: Int) = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span><br>    def unapply(person: Person): Option<span class="hljs-literal">[(S<span class="hljs-identifier">tring</span>, I<span class="hljs-identifier">nt</span>)]</span> = &#123;<br>        <span class="hljs-keyword">if</span> (person<span class="hljs-operator"> == </span>null) &#123; <span class="hljs-comment">// avoid null reference</span><br>            None<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-constructor">Some((<span class="hljs-params">person</span>.<span class="hljs-params">name</span>, <span class="hljs-params">person</span>.<span class="hljs-params">age</span>)</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br>case <span class="hljs-keyword">class</span> <span class="hljs-constructor">Student(<span class="hljs-params">name</span>: String, <span class="hljs-params">age</span>: Int)</span> <span class="hljs-comment">// name and age are vals</span><br></code></pre></td></tr></table></figure>

<p>偏函数：</p>
<ul>
<li>偏函数是函数的一种，通过偏函数我们可以方便地对参数做更精确的检查，例如偏函数输入类型是<code>List[Int]</code>，需要第一个元素是0的集合，也可以通过模式匹配实现的。</li>
<li>定义：</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">val partialFuncName: PartialFunction[List[<span class="hljs-type">Int</span>], <span class="hljs-keyword">Option</span>[<span class="hljs-type">Int</span>]] = &#123;<br>    <span class="hljs-keyword">case</span> x :: y :: _ =&gt; <span class="hljs-keyword">Some</span>(y)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过一个变量定义方式定义，<code>PartialFunction</code>的泛型类型中，前者是参数类型，后者是返回值类型。函数体中用一个<code>case</code>语句来进行模式匹配。上面例子返回输入的<code>List</code>集合中的第二个元素。</li>
<li>一般一个偏函数只能处理输入的一部分场景，实际中往往需要定义多个偏函数用以组合使用。</li>
<li>例子：</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs haxe">object PartialFunctionTest &#123;<br>    def main(args: <span class="hljs-type">Array</span>[<span class="hljs-keyword">String</span>]): <span class="hljs-type">Unit </span>= &#123;<br>        val list: <span class="hljs-type">List</span>[(<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Int</span>)] = List((<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">100</span>), (<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">5</span>))<br><br>        <span class="hljs-comment">// keep first constant and double second value of the tuple</span><br>        <span class="hljs-comment">// 1. use map</span><br>        val <span class="hljs-keyword">new</span><span class="hljs-type">List</span> = list.map(tuple =&gt; (tuple._1, tuple._2 * <span class="hljs-number">2</span>))<br>        println(<span class="hljs-keyword">new</span><span class="hljs-type">List</span>)<br><br>        <span class="hljs-comment">// 2. pattern matching</span><br>        val <span class="hljs-keyword">new</span><span class="hljs-type">List1</span> = list.map(<br>            tuple =&gt; &#123;<br>                tuple match &#123;<br>                    <span class="hljs-keyword">case</span> (x, y) =&gt; (x, y * <span class="hljs-number">2</span>)<br>                &#125;<br>            &#125;<br>        )<br>        println(<span class="hljs-keyword">new</span><span class="hljs-type">List1</span>)<br><br>        <span class="hljs-comment">// simplify to partial function</span><br>        val <span class="hljs-keyword">new</span><span class="hljs-type">List2</span> = list.map &#123;<br>            <span class="hljs-keyword">case</span> (x, y) =&gt; (x, y * <span class="hljs-number">2</span>) <span class="hljs-comment">// this is a partial function</span><br>        &#125;<br>        println(<span class="hljs-keyword">new</span><span class="hljs-type">List2</span>)<br><br>        <span class="hljs-comment">// application of partial function</span><br>        <span class="hljs-comment">// get absolute value, deal with: negative, 0, positive</span><br>        val positiveAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-keyword">Int</span>, <span class="hljs-keyword">Int</span>] = &#123;<br>            <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> =&gt; x<br>        &#125;<br>        val negativeAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-keyword">Int</span>, <span class="hljs-keyword">Int</span>] = &#123;<br>            <span class="hljs-keyword">case</span> x <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> =&gt; -x<br>        &#125;<br>        val zeroAbs: <span class="hljs-type">PartialFunction</span>[<span class="hljs-keyword">Int</span>, <span class="hljs-keyword">Int</span>] = &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0</span><br>        &#125;<br><br>        <span class="hljs-comment">// combine a function with three partial functions</span><br>        def abs(x: <span class="hljs-type">Int</span>): <span class="hljs-type">Int </span>= (positiveAbs orElse negativeAbs orElse zeroAbs) (x)<br>        println(abs(<span class="hljs-number">-13</span>))<br>        println(abs(<span class="hljs-number">30</span>))<br>        println(abs(<span class="hljs-number">0</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>scala异常处理整体上的语法和底层处理细节和java非常类似。</p>
<p>Java异常处理：</p>
<ul>
<li>用<code>try</code>语句包围要捕获异常的块，多个不同<code>catch</code>块用于捕获不同的异常，<code>finally</code>块中是捕获异常与否都会执行的逻辑。</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">try &#123;<br>    int a <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    int b <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    int c <span class="hljs-operator">=</span> a / b<span class="hljs-comment">;</span><br>&#125; catch (ArithmeticException e) &#123;<br>    e.printStackTrace()<span class="hljs-comment">;</span><br>&#125; catch (Exception e) &#123;<br>    e.printStackTrace()<span class="hljs-comment">;</span><br>&#125; finally &#123;<br>    System.out.println(<span class="hljs-string">&quot;finally&quot;</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>scala异常处理：</p>
<ul>
<li><code>try</code>包围要捕获异常的内容，<code>catch</code>仅仅是关键字，将捕获异常的所有逻辑包围在<code>catch</code>块中。<code>finally</code>块和java一样都会执行，一般用于对象的清理工作。</li>
<li>scala中没有编译期异常，所有异常都是运行时处理。</li>
<li>scala中也是用<code>throw</code>关键字抛出异常，所有异常都是<code>Throwable</code>的子类，<code>throw</code>表达式是有类型的，就是<code>Nothing</code>。<code>Nothing</code>主要用在一个函数总是不能正常工作，总是抛出异常的时候用作返回值类型。</li>
<li>java中用了<code>throws</code>关键字声明此方法可能引发的异常信息，在scala中对应地使用<code>@throws[ExceptionList]</code>注解来声明，用法差不多。</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing">object Exceptionstest &#123;<br>    def <span class="hljs-title function_">main</span>(args: <span class="hljs-built_in">Array</span>[<span class="hljs-built_in">String</span>]): Unit = &#123;<br>        <span class="hljs-comment">// test of exceptions</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            val n = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">catch</span> &#123;<br>            <span class="hljs-keyword">case</span> e: ArithmeticException =&gt; &#123;<br>                <span class="hljs-built_in">println</span>(s<span class="hljs-string">&quot;ArithmeticException raised.&quot;</span>)<br>            &#125;<br>            <span class="hljs-keyword">case</span> e: Exception =&gt; &#123;<br>                <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Normal Exceptions raised.&quot;</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;finally&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>前面说了很多了，编译器做隐式转换的时机：</p>
<ul>
<li>编译器第一次编译失败时，会在当前环境中查找能让代码编译通过的方法，将类型隐式转换，尝试二次编译。</li>
</ul>
<p>隐式函数：</p>
<ul>
<li>函数定义前加上<code>implicit</code>声明为隐式转换函数。</li>
<li>当编译错误时，编译器会尝试在当前作用域范围查找能调用对应功能的转换规则，这个过程由编译器完成，称之为隐式转换或者自动转换。</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// convert <span class="hljs-built_in">Int</span> to MyRichInt<br><span class="hljs-keyword">implicit</span> def convert(arg: <span class="hljs-built_in">Int</span>): MyRichInt = &#123;<br>    new MyRickInt(arg)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在当前作用域定义时需要在使用前定义才能找到。</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran">object  ImplicitConversion &#123;<br>    def main(args: Array[String]): <span class="hljs-keyword">Unit</span> = &#123;<br>        <span class="hljs-keyword">implicit</span> def convert(num: <span class="hljs-built_in">Int</span>): MyRichInt = new MyRichInt(num)<br><br>        println(<span class="hljs-number">12.</span>myMax(<span class="hljs-number">15</span>)) // will <span class="hljs-keyword">call</span> convert implicitly<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> MyRichInt(val self: <span class="hljs-built_in">Int</span>) &#123;<br>    // self define compare method<br>    def myMax(n: <span class="hljs-built_in">Int</span>): <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (n &lt; self) self <span class="hljs-keyword">else</span> n<br>    def myMin(n: <span class="hljs-built_in">Int</span>): <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (n &gt; self) self <span class="hljs-keyword">else</span> n<br>&#125;<br></code></pre></td></tr></table></figure>

<p>隐式参数：</p>
<ul>
<li>普通方法或者函数中的参数可以通过<code>implicit</code>关键字声明为隐式参数，调用方法时，如果传入了，那么以传入参数为准。如果没有传入，编译器会在当前作用域寻找复合条件的隐式值。例子：集合排序方法的排序规则就是隐式参数。</li>
<li>隐式值：<ul>
<li>同一个作用域，相同类型隐式值只能有一个。</li>
<li>编译器按照隐式参数的类型去寻找对应隐式值，与隐式值名称无关。</li>
<li>隐式参数优先于默认参数。（也就是说隐式参数和默认参数可以同时存在，加上默认参数之后其实就相当于两个不同优先级的默认参数）</li>
</ul>
</li>
<li>隐式参数有一个很淦的点：<ul>
<li>如果参数列表中只有一个隐式参数，无论这个隐式参数是否提供默认参数，那么如果要用这个隐式参数就应该<strong>将调用隐式参数的参数列表连同括号一起省略掉</strong>。如果调用时又想加括号可以在函数定义的隐式参数列表前加一个空参数列表<code>()</code>，那么<code>()</code>将使用隐式参数，<code>()()</code>将使用默认参数（如果有，没有肯定编不过），<code>()(arg)</code>使用传入参数。</li>
<li>也就是说一个隐式参数时通过是否加括号可以区分隐式参数、默认参数、传入参数三种情况。</li>
<li>那么如果多参数情况下：隐式参数、默认参数、普通参数排列组合在一个参数列表中混用会怎么样呢？没有试验过，不要这么用，思考这些东西搞什么哦！</li>
<li>具体要不要加这个柯里化的空参数列表，那看习惯就行。不加可能更好一点，加了可能有点让人费解。</li>
</ul>
</li>
<li>可以进一步简写隐式参数，在参数列表中直接去掉，在函数中直接使用<code>implicity[Type]</code>（<code>Predef</code>中定义的）。但这时就不能传参数了，有什么用啊？相当于一个在自己作用域范围内起作用的全局量？</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs fortran">object ImplicitArgments &#123;<br>    def main(args: Array[String]): <span class="hljs-keyword">Unit</span> = &#123;<br>        <span class="hljs-keyword">implicit</span> val str: String = <span class="hljs-string">&quot;Alice from implicit argument&quot;</span><br>        <br>        def sayHello()(<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">name</span>: String = <span class="hljs-string">&quot;Alice from default argument&quot;</span>): <span class="hljs-keyword">Unit</span> = &#123;<br>            println(s<span class="hljs-string">&quot;hello $name&quot;</span>)<br>        &#125;<br><br>        sayHello() // <span class="hljs-keyword">implicit</span><br>        sayHello()() // <span class="hljs-keyword">default</span><br>        sayHello()(<span class="hljs-string">&quot;Alice from normal argument&quot;</span>) // normal<br><br>        def sayHi(<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">name</span>: String = <span class="hljs-string">&quot;Alice from default argument&quot;</span>): <span class="hljs-keyword">Unit</span> = &#123;<br>            println(s<span class="hljs-string">&quot;hi $name&quot;</span>)<br>        &#125;<br><br>        sayHi // <span class="hljs-keyword">implicit</span><br>        sayHi() // <span class="hljs-keyword">default</span><br>        sayHi(<span class="hljs-string">&quot;Alice from normal argument&quot;</span>) // normal<br><br>        def sayBye() = &#123;<br>            println(s<span class="hljs-string">&quot;bye $&#123;implicitly[String]&#125;&quot;</span>)<br>        &#125;<br><br>        sayBye()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>隐式类：</p>
<ul>
<li>scala2.10之后提供了隐式类，使用<code>implicit</code>声明为隐式类。将类的构造方法声明为隐式转换函数。</li>
<li>也就是说如果编译通不过，就可能将数据直接传给构造转换为对应的类。</li>
<li>隐式函数的一个扩展。</li>
<li>说明：<ul>
<li>所带构造参数有且只能有一个。</li>
<li>隐式类必须被定义在类或者伴生对象或者包对象中，隐式类不能是顶层的。</li>
</ul>
</li>
<li>同一个作用域定义隐式转换函数和隐式类会冲突，定义一个就行。</li>
</ul>
<p>隐式解析机制的作用域：</p>
<ul>
<li>首先在<strong>当前代码作用域下</strong>查找隐式实体（隐式方法、隐式类、隐式对象）。</li>
<li>如果第一条规查找隐式对象失败，会继续在<strong>隐式参数的类型的作用域</strong>中查找。</li>
<li>类型的作用域是指该类型相关联的全部伴生对象以及该类型所在包的包对象。</li>
</ul>
<p>作用：</p>
<ul>
<li>隐式函数和隐式类可以用于扩充类的功能，常用语比如内建类<code>Int Double String</code>这种。</li>
<li>隐式参数相当于就是一种更高优先级的默认参数。用于多个函数需要同一个默认参数时，就不用每个函数定义时都写一次默认值了。为了简洁无所不用其极啊真是。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型：</p>
<ul>
<li><code>[TypeList]</code>，定义和使用都是。</li>
<li>常用于集合类型中用于支持不同元素类型。</li>
<li>和java一样通过类型擦除&#x2F;擦拭法来实现。</li>
<li>定义时可以用<code>+-</code>表示协变和逆变，不加则是不变。</li>
</ul>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>[+T] &#123;&#125; <span class="hljs-comment">// 协变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>[-T] &#123;&#125; <span class="hljs-comment">// 逆变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>[T] &#123;&#125; <span class="hljs-comment">// 不变</span><br></code></pre></td></tr></table></figure>

<p>协变和逆变：</p>
<ul>
<li>比如Son和Father是父子关系，Son是子类。<ul>
<li>协变（Covariance）：<code>MyList[Son]</code>是<code>MyList[Father]</code>的子类，协同变化。</li>
<li>逆变（Contravariance）：<code>MyList[Son]</code>是<code>MyList[Father]</code>的父类，逆向变化。</li>
<li>不变（Invariant）：<code>MyList[Father] MyList[Son]</code>没有父子关系。</li>
</ul>
</li>
<li>还需要深入了解。</li>
</ul>
<p>泛型上下限：</p>
<ul>
<li>泛型上限：<code>class MyList[T &lt;: Type]</code>，可以传入<code>Type</code>自身或者子类。</li>
<li>泛型下限：<code>class MyList[T &gt;: Type]</code>，可以传入<code>Type</code>自身或者父类。</li>
<li>对传入的泛型进行限定。</li>
</ul>
<p>上下文限定：</p>
<ul>
<li><code>def f[A : B](a: A) = println(a)</code>等同于<code>def f[A](a: A)(implicit arg: B[A])</code></li>
<li>是将泛型和隐式转换结合的产物，使用上下文限定（前者）后，方法内无法使用隐式参数名调用隐式参数，需要通过<code>implicitly[Ordering[A]]</code>获取隐式变量。</li>
<li>了解即可，可能基本不会用到。</li>
</ul>
<h2 id="Style-Guide"><a href="#Style-Guide" class="headerlink" title="Style Guide"></a>Style Guide</h2><p><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/style/index.html">官方的Style Guide</a>中的一些建议：</p>
<ul>
<li>缩进鼓励为2个，当然我上面都是用的4个。Scala中很多时候嵌套层次会很深，也鼓励这样做，模式匹配、匿名函数、循环、条件等各种嵌套，层次深了之后4空格可能会比较折磨。</li>
<li>一个表达式一行放不下要换行时，语义上不会产生歧义就行，比如一个运算符放在末尾将其必需的操作数换到下一行。</li>
<li>多参数函数调用需要换行书写时，将第一个参数放到第二行并缩进2个空格书写，而不是第一个参数放到第一行，然后缩进到对齐（典型java风格）。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> right!<br>val myLongFieldNameWithNoRealPoint =<br>  foo(<br>    someVeryLongFieldName,<br>    andAnotherVeryLongFieldName,<br>    <span class="hljs-string">&quot;this is a string&quot;</span>,<br>    <span class="hljs-number">3.1415</span>)<br><br><span class="hljs-regexp">//</span> wrong!<br>val myLongFieldNameWithNoRealPoint = foo(someVeryLongFieldName,<br>                                         andAnotherVeryLongFieldName,<br>                                         <span class="hljs-string">&quot;this is a string&quot;</span>,<br>                                         <span class="hljs-number">3.1415</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>仅介绍第一页的内容，也没有空去看完，以后真写得多了再去看。</li>
</ul>
<h2 id="sbt"><a href="#sbt" class="headerlink" title="sbt"></a>sbt</h2><p>上面已经简单介绍了IDEA使用Maven项目编写Scala的配置，但学习scala，官方的构建工具sbt还是必须要了解一下的。</p>
<p>关于SBT：</p>
<ul>
<li>SBT是Scala的构建工具，全称Simple Build Tool，类似于 Maven 或 Gradle。</li>
<li><a target="_blank" rel="noopener" href="https://docs.scala-lang.org/getting-started/sbt-track/getting-started-with-scala-and-sbt-on-the-command-line.html">GETTING STARTED WITH SCALA AND SBT ON THE COMMAND LINE</a></li>
<li><a target="_blank" rel="noopener" href="https://www.scala-sbt.org/1.x/docs/index.html">sbt Reference Manual</a> 要使用sbt，阅读完第一章Getting Started with sbt是必要的。下面的内容皆是第一章翻译。</li>
</ul>
<p>特性：</p>
<ul>
<li>简单项目零配置。</li>
<li>用Scala源码管理项目构建。</li>
<li>精确的重编译，节省时间。</li>
<li>使用Coursier的库管理器。</li>
<li>支持Scala和Java的混合项目。</li>
<li>等等等，具体就不列了，总之一个大型项目构建系统该有的东西。</li>
</ul>
<p>安装：</p>
<ul>
<li>sbt依赖Java，确保已经安装了JDK1.8或以上版本。</li>
<li>下载压缩包或者安装包，这里的版本是1.5.5。</li>
<li>解压或者安装。</li>
<li>配置环境变量<code>SBT_HOME</code>，并添加<code>%SBT_HOME%\bin</code>到path环境变量，安装包的话会自动配置。</li>
</ul>
<h3 id="通过案例入门sbt"><a href="#通过案例入门sbt" class="headerlink" title="通过案例入门sbt"></a>通过案例入门sbt</h3><p>创建一个项目hello作为例子：</p>
<ul>
<li>windows上没有的命令按照含义操作即可。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> foo-build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> foo-build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> build.sbt</span><br></code></pre></td></tr></table></figure>

<p>开始sbt shell：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sbt<br>[info] Updated <span class="hljs-keyword">file</span> <span class="hljs-regexp">/tmp/</span>foo-build<span class="hljs-regexp">/project/</span>build.properties: set sbt.version to <span class="hljs-number">1.1</span>.<span class="hljs-number">4</span><br>[info] Loading <span class="hljs-keyword">project</span> definition <span class="hljs-keyword">from</span> <span class="hljs-regexp">/tmp/</span>foo-build/<span class="hljs-keyword">project</span><br>[info] Loading settings <span class="hljs-keyword">from</span> build.sbt ...<br>[info] Set current <span class="hljs-keyword">project</span> to foo-build (in build <span class="hljs-keyword">file</span>:<span class="hljs-regexp">/tmp/</span>foo-build/)<br>[info] sbt server started at local:<span class="hljs-comment">///Users/eed3si9n/.sbt/1.0/server/abc4fb6c89985a00fd95/sock</span><br>sbt:foo-build&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一次初始化时间会很长。</li>
<li>退出shell：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sbt:foo-build&gt; <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<ul>
<li>编译：</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">sb</span><span class="hljs-variable">t:foo</span>-build&gt; compile<br></code></pre></td></tr></table></figure>

<ul>
<li>sbt shell中Tab可以补全。</li>
</ul>
<p>对修改重新编译：</p>
<ul>
<li>在<code>compile</code>命令（或其他命令同理）前加一个<code>~</code>前缀，会进入等待状态，当项目发生修改是会自动重新编译。当然退出这个状态后就不会了。</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">sb</span><span class="hljs-variable">t:foo</span>-build&gt; ~compile<br>[success] Total time: <span class="hljs-number">0</span> s, completed May <span class="hljs-number">6</span>, <span class="hljs-number">2018</span> <span class="hljs-number">3</span>:<span class="hljs-number">52</span>:<span class="hljs-number">08</span> PM<br><span class="hljs-number">1</span>. Waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">source</span> <span class="hljs-keyword">changes</span>... (press enter <span class="hljs-keyword">to</span> interrupt)<br></code></pre></td></tr></table></figure>

<p>创建源文件：</p>
<ul>
<li>执行<code>~compile</code>并保持，创建目录<code>src/main/scala/example</code>新建源文件保存就能看到编译过程了。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// src/main/scala/example/Hello.scala</span><br><span class="hljs-keyword">package</span> example<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>sbt shell常用操作：</p>
<ul>
<li><code>help</code>帮助。</li>
<li><code>help run</code>具体条目的帮助。</li>
<li><code>run</code>运行程序。</li>
<li>上下箭头切换已执行命令。</li>
<li><code>scalaVersion</code> scala版本。</li>
</ul>
<p>配置修改：</p>
<ul>
<li>切换当前项目的scala版本：<code>set ThisBuild / scalaVersion := &quot;2.13.6&quot;</code>。</li>
<li><code>session save</code>保存配置到<code>build.sbt</code>，此时其中就会多出<code>ThisBuild / scalaVersion := &quot;2.13.6&quot;</code>。</li>
<li>编辑<code>build.sbt</code>：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>lazy val hello = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span><br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>重新加载配置<code>reload</code>。</li>
</ul>
<p>测试：</p>
<ul>
<li>添加ScalaTest到依赖</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>lazy val hello = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span> % <span class="hljs-keyword">Test</span>,<br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>执行测试：<code>test</code>。</li>
<li>后续继续运行追加的测试：<code>~testQuick</code></li>
</ul>
<p>编写测试：<code>src/test/scala/HelloSpec.scala</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// src/test/scala/HelloSpec.scala</span><br><span class="hljs-keyword">import</span> org.scalatest.funsuite._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>&#123;<br>  test(<span class="hljs-string">&quot;Hello should start with H&quot;</span>) &#123;<br>    assert(<span class="hljs-string">&quot;hello&quot;</span>.startsWith(<span class="hljs-string">&quot;H&quot;</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>测试结果当然是失败</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sbt:Hello&gt; test<br>[<span class="hljs-built_in">info</span>] HelloSpec:<br>[<span class="hljs-built_in">info</span>] - Hello should start with H *** FAILED ***<br>[<span class="hljs-built_in">info</span>]   <span class="hljs-string">&quot;hello&quot;</span> did <span class="hljs-keyword">not</span> start with <span class="hljs-string">&quot;H&quot;</span> (HelloSpec.scala:5)<br>[<span class="hljs-built_in">info</span>] <span class="hljs-built_in">Run</span> completed <span class="hljs-keyword">in</span> 214 milliseconds.<br>[<span class="hljs-built_in">info</span>] Total number of tests run: 1<br>[<span class="hljs-built_in">info</span>] Suites: completed 1, aborted 0<br>[<span class="hljs-built_in">info</span>] Tests: succeeded 0, failed 1, canceled 0, ignored 0, pending 0<br>[<span class="hljs-built_in">info</span>] *** 1 TEST FAILED ***<br>[<span class="hljs-built_in">error</span>] Failed tests:<br>[<span class="hljs-built_in">error</span>]         HelloSpec<br>[<span class="hljs-built_in">error</span>] (Test / test) sbt.TestsFailedException: Tests unsuccessful<br>[<span class="hljs-built_in">error</span>] Total time: 0 s, completed 2021年9月27日 下午11:58:01<br></code></pre></td></tr></table></figure>

<ul>
<li>改一下源码再测试就能通过了：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// src/test/scala/HelloSpec.scala</span><br><span class="hljs-keyword">import</span> org.scalatest.funsuite._<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyFunSuite</span> </span>&#123;<br>  test(<span class="hljs-string">&quot;Hello should start with H&quot;</span>) &#123;<br>    assert(<span class="hljs-string">&quot;Hello&quot;</span>.startsWith(<span class="hljs-string">&quot;H&quot;</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加库依赖：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// build.sbt</span><br>ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>lazy val hello = (project <span class="hljs-keyword">in</span> <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.typesafe.play&quot;</span> %% <span class="hljs-string">&quot;play-json&quot;</span> % <span class="hljs-string">&quot;2.9.2&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span> % Test,<br>  )<br></code></pre></td></tr></table></figure>

<p>使用REPL（Read-Eval-Print Loop）：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">sb</span><span class="hljs-variable">t:Hello</span>&gt; console<br></code></pre></td></tr></table></figure>

<ul>
<li>在scala的REPL环境中粘贴：<code>:paste</code>。</li>
<li>退出：<code>:q</code></li>
</ul>
<p>修改<code>build.sbt</code>创建一个子项目：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>lazy val hello = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span> % <span class="hljs-keyword">Test</span>,<br>  )<br><br>lazy val helloCore = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li><code>reload</code>时会自动创建目录<code>core/</code>。</li>
<li>列出所有子项目：<code>projects</code></li>
<li>编译子项目：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helloCore/compile<br></code></pre></td></tr></table></figure>

<ul>
<li>子项目添加依赖：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>val scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br><br>lazy val hello = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-keyword">Test</span>,<br>  )<br><br>lazy val helloCore = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-keyword">Test</span>,<br>  )<br></code></pre></td></tr></table></figure>

<p>广播命令、添加依赖：</p>
<ul>
<li>设置<code>.aggregate(...)</code>，这样发送到<code>hello</code>的命令都会被广播到<code>helloCore</code></li>
<li>使用<code>.dependsOn(...)</code>可以设置依赖，下面的设置使<code>hello</code>依赖于<code>helloCore</code></li>
<li>将Gigahorse的依赖移到<code>helloCore</code>。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>val scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br>val gigahorse = <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span><br><br>lazy val hello = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(helloCore)<br>  .dependsOn(helloCore)<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-keyword">Test</span>,<br>  )<br><br>lazy val helloCore = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies += scalaTest % <span class="hljs-keyword">Test</span>,<br>    libraryDependencies += gigahorse,<br>  )<br></code></pre></td></tr></table></figure>

<p>使用Play JSON解析JSON：</p>
<ul>
<li>添加依赖。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css">ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>val scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br>val gigahorse = <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span><br>val playJson  = <span class="hljs-string">&quot;com.typesafe.play&quot;</span> %% <span class="hljs-string">&quot;play-json&quot;</span> % <span class="hljs-string">&quot;2.9.2&quot;</span><br><br>lazy val hello = (project in <span class="hljs-built_in">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .<span class="hljs-built_in">aggregate</span>(helloCore)<br>  .<span class="hljs-built_in">dependsOn</span>(helloCore)<br>  .<span class="hljs-built_in">settings</span>(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % Test,<br>  )<br><br>lazy val helloCore = (project in <span class="hljs-built_in">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br>  .<span class="hljs-built_in">settings</span>(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies ++= <span class="hljs-built_in">Seq</span>(gigahorse, playJson),<br>    libraryDependencies += scalaTest % Test,<br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>重载，添加文件：<code>core/src/main/scala/example/core/Weather.scala</code></li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// core/src/main/scala/example/core/Weather.scala</span><br>package example.core<br><br>import gigahorse._, support.okhttp.Gigahorse<br>import scala.concurrent._, duration._<br>import play.api.libs.json._<br><br><span class="hljs-keyword">object</span> Weather &#123;<br>  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> http = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Gigahorse</span>.</span></span>http(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Gigahorse</span>.</span></span>config)<br><br>  def weather: Future<span class="hljs-literal">[S<span class="hljs-identifier">tring</span>]</span> = &#123;<br>    <span class="hljs-keyword">val</span> baseUrl = <span class="hljs-string">&quot;https://www.metaweather.com/api/location&quot;</span><br>    <span class="hljs-keyword">val</span> locUrl = baseUrl + <span class="hljs-string">&quot;/search/&quot;</span><br>    <span class="hljs-keyword">val</span> weatherUrl = baseUrl + <span class="hljs-string">&quot;/%s/&quot;</span><br>    <span class="hljs-keyword">val</span> rLoc = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Gigahorse</span>.</span></span>url(locUrl).get.<br>      add<span class="hljs-constructor">QueryString(<span class="hljs-string">&quot;query&quot;</span> -&gt; <span class="hljs-string">&quot;New York&quot;</span>)</span><br>    import <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecutionContext</span>.</span><span class="hljs-module"><span class="hljs-identifier">Implicits</span>.</span></span>global<br>    <span class="hljs-keyword">for</span> &#123;<br>      loc &lt;- http.run(rLoc, parse)<br>      woeid = (loc \ <span class="hljs-number">0</span>  \ <span class="hljs-string">&quot;woeid&quot;</span>).get<br>      rWeather = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Gigahorse</span>.</span></span>url(weatherUrl format woeid).get<br>      weather &lt;- http.run(rWeather, parse)<br>    &#125; yield (weather \\ <span class="hljs-string">&quot;weather_state_name&quot;</span>)(<span class="hljs-number">0</span>).<span class="hljs-keyword">as</span><span class="hljs-literal">[S<span class="hljs-identifier">tring</span>]</span>.toLowerCase<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> def parse = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Gigahorse</span>.</span></span>asString andThen <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Json</span>.</span></span>parse<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>修改<code>src/main/scala/example/Hello.scala</code>:</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> scala.concurrent._, duration._<br><span class="hljs-keyword">import</span> core.<span class="hljs-type">Weather</span><br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> w = <span class="hljs-type">Await</span>.result(<span class="hljs-type">Weather</span>.weather, <span class="hljs-number">10.</span>seconds)<br>  println(<span class="hljs-string">s&quot;Hello! The weather in New York is <span class="hljs-subst">$w</span>.&quot;</span>)<br>  <span class="hljs-type">Weather</span>.http.close()<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>运行：<code>run</code></li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">sbt:Hello&gt; <span class="hljs-built_in">run</span><br>[info] <span class="hljs-built_in">running</span> example.Hello<br>Hello! The weather <span class="hljs-keyword">in</span> New York <span class="hljs-keyword">is</span> light cloud.<br>[success] Total <span class="hljs-built_in">time</span>: <span class="hljs-number">5</span> s, completed <span class="hljs-number">2021</span>年<span class="hljs-number">9</span>月<span class="hljs-number">28</span>日 上午<span class="hljs-number">10</span>:<span class="hljs-number">29</span>:<span class="hljs-number">57</span><br></code></pre></td></tr></table></figure>

<p>添加sbt-native-packager插件：</p>
<ul>
<li>创建<code>project/plugins.sbt</code></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addSbtPlugin</span><span class="hljs-params">(<span class="hljs-string">&quot;com.typesafe.sbt&quot;</span> % <span class="hljs-string">&quot;sbt-native-packager&quot;</span> % <span class="hljs-string">&quot;1.3.4&quot;</span>)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>修改<code>build.sbt</code>对<code>Hello</code>项目添加<code>.enablePlugins(JavaAppPackaging)</code></li>
<li>重载，本地没有执行成功，所以下面的<code>dist</code>命令也就不能用。</li>
</ul>
<p>重载并创建.zip分发包：<code>dist</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sbt:Hello&gt; dist<br>[info] Wrote <span class="hljs-regexp">/tmp/</span>foo-build<span class="hljs-regexp">/target/</span>scala-<span class="hljs-number">2.12</span>/hello_2.<span class="hljs-number">12</span>-<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>-SNAPSHOT.pom<br>[info] Wrote <span class="hljs-regexp">/tmp/</span>foo-build<span class="hljs-regexp">/core/</span>target<span class="hljs-regexp">/scala-2.12/</span>hello-core_2.<span class="hljs-number">12</span>-<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>-SNAPSHOT.pom<br>[info] Your <span class="hljs-keyword">package</span> is ready in <span class="hljs-regexp">/tmp/</span>foo-build<span class="hljs-regexp">/target/u</span>niversal/hello-<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>-SNAPSHOT.zip<br></code></pre></td></tr></table></figure>

<p>应用容器化：</p>
<ul>
<li><code>Docker/publishLocal</code></li>
<li>运行容器化后的应用：<code>docker run hello:0.1.0-SNAPSHOT</code></li>
</ul>
<p>设置应用版本：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css">// build<span class="hljs-selector-class">.sbt</span><br>ThisBuild / version      := <span class="hljs-string">&quot;0.1.0&quot;</span><br>ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.13.6&quot;</span><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br><br>val scalaTest = <span class="hljs-string">&quot;org.scalatest&quot;</span> %% <span class="hljs-string">&quot;scalatest&quot;</span> % <span class="hljs-string">&quot;3.2.7&quot;</span><br>val gigahorse = <span class="hljs-string">&quot;com.eed3si9n&quot;</span> %% <span class="hljs-string">&quot;gigahorse-okhttp&quot;</span> % <span class="hljs-string">&quot;0.5.0&quot;</span><br>val playJson  = <span class="hljs-string">&quot;com.typesafe.play&quot;</span> %% <span class="hljs-string">&quot;play-json&quot;</span> % <span class="hljs-string">&quot;2.9.2&quot;</span><br><br>lazy val hello = (project in <span class="hljs-built_in">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .<span class="hljs-built_in">aggregate</span>(helloCore)<br>  .<span class="hljs-built_in">dependsOn</span>(helloCore)<br>  .<span class="hljs-built_in">enablePlugins</span>(JavaAppPackaging)<br>  .<span class="hljs-built_in">settings</span>(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += scalaTest % Test,<br>  )<br><br>lazy val helloCore = (project in <span class="hljs-built_in">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br>  .<span class="hljs-built_in">settings</span>(<br>    name := <span class="hljs-string">&quot;Hello Core&quot;</span>,<br>    libraryDependencies ++= <span class="hljs-built_in">Seq</span>(gigahorse, playJson),<br>    libraryDependencies += scalaTest % Test,<br>  )<br></code></pre></td></tr></table></figure>

<p>临时切换Scala版本：</p>
<ul>
<li><code>++2.12.14</code></li>
</ul>
<p>在Bash中直接运行sbt的命令：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">sbt <span class="hljs-built_in">clean</span> <span class="hljs-string">&quot;testOnly HelloSpec&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这样程序运行起来会慢一些。</li>
<li>连续的开发的话，推荐使用sbt shell或者连续测试比如<code>~testQuick</code>。</li>
</ul>
<p><code>new</code>命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sbt <span class="hljs-keyword">new</span> scala/scala-seed.g8<br>....<br>A minimal Scala <span class="hljs-keyword">project</span>.<br><br>name [My Something <span class="hljs-keyword">Project</span>]: hello<br><br>Template applied in ./hello<br></code></pre></td></tr></table></figure>

<ul>
<li>会创建一个简单的项目，要求输入项目名时输入<code>hello</code>，会在<code>hello/</code>下创建一个新项目。</li>
</ul>
<h3 id="sbt使用"><a href="#sbt使用" class="headerlink" title="sbt使用"></a>sbt使用</h3><p>项目的目录结构：</p>
<ul>
<li>base directory是包含项目的目录，这里称为项目根目录。</li>
<li>sbt使用和Maven一样的源码结构，源文件路径都是基于项目根目录的相对路径。</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stata">src/<br>  main/<br>    resources/<br>       &lt;files to <span class="hljs-keyword">include</span> <span class="hljs-keyword">in</span> main jar here&gt;<br>    <span class="hljs-keyword">scala</span>/<br>       &lt;main <span class="hljs-keyword">Scala</span> sources&gt;<br>    <span class="hljs-keyword">scala</span>-2.12/<br>       &lt;main <span class="hljs-keyword">Scala</span> 2.12 specific sources&gt;<br>    java/<br>       &lt;main Java sources&gt;<br>  <span class="hljs-keyword">test</span>/<br>    resources<br>       &lt;files to <span class="hljs-keyword">include</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">test</span> jar here&gt;<br>    <span class="hljs-keyword">scala</span>/<br>       &lt;<span class="hljs-keyword">test</span> <span class="hljs-keyword">Scala</span> sources&gt;<br>    <span class="hljs-keyword">scala</span>-2.12/<br>       &lt;<span class="hljs-keyword">test</span> <span class="hljs-keyword">Scala</span> 2.12 specific sources&gt;<br>    java/<br>       &lt;<span class="hljs-keyword">test</span> Java sources&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其他<code>src/</code>中的目录会被忽略，所有隐藏目录都会被忽略。</li>
<li>源码可以被放在根目录的<code>hello/app.scala</code>，对小项目是可行的。然而一般来说，人们倾向于将项目放在<code>src/main/</code>下面来保证事情能够有条理地进行。如果你自行管理定制了项目的构建的话，自定义源码的位置也是可行的。</li>
<li>sbt的构建定义文件：<code>build.sbt</code></li>
<li>除此之外，<code>project</code>目录中的<code>.scala</code>文件可以定义项目帮助文件和一次性的插件。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">build.sbt<br><span class="hljs-keyword">project</span>/<br>  <span class="hljs-keyword">Dependencies</span>.scala<br></code></pre></td></tr></table></figure>

<ul>
<li>生成文件：<code>.class</code>，生成的<code>jar</code>，其他文件和文档等会被默认输出到<code>target</code>目录。</li>
<li>一般生成文件应该要排除在版本控制之外，在<code>.gitignore</code>中添加：</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">target</span>/<br></code></pre></td></tr></table></figure>

<p>运行：</p>
<ul>
<li>运行sbt shell：<code>sbt</code>无参数运行，进入sbt的提示符，有tab补全和执行历史。</li>
<li>编译：<code>compile</code></li>
<li>运行：<code>run</code></li>
<li>不进入sbt shell直接运行sbt命令：用<code>&quot;&quot;</code>包起来表示是一个命令，相对来说会慢一些。</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">sbt <span class="hljs-built_in">clean</span> compile <span class="hljs-string">&quot;testOnly TestA TestB&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>会一次执行<code>clean compile testOnly</code>，<code>TestA TestB</code>是传给<code>testOnly</code>的参数。</li>
<li>保存文件时自动重编译运行测试：<code>~testQuick</code>。</li>
<li>命令加上<code>~</code>后会进入循环模式，保存文件都会自动运行。回车退出。</li>
<li>常用命令：</li>
</ul>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clean</td>
<td>Deletes all generated files (in the target directory).</td>
</tr>
<tr>
<td>compile</td>
<td>Compiles the main sources (in src&#x2F;main&#x2F;scala and src&#x2F;main&#x2F;java directories).</td>
</tr>
<tr>
<td>test</td>
<td>Compiles and runs all tests.</td>
</tr>
<tr>
<td>console</td>
<td>Starts the Scala interpreter with a classpath including the compiled sources and all dependencies. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows).</td>
</tr>
<tr>
<td>run argument*</td>
<td>Runs the main class for the project in the same virtual machine as sbt.</td>
</tr>
<tr>
<td>package</td>
<td>Creates a jar file containing the files in src&#x2F;main&#x2F;resources and the classes compiled from src&#x2F;main&#x2F;scala and src&#x2F;main&#x2F;java.</td>
</tr>
<tr>
<td>help command</td>
<td>Displays detailed help for the specified command. If no command is provided, displays brief descriptions of all commands.</td>
</tr>
<tr>
<td>reload</td>
<td>Reloads the build definition (build.sbt, project&#x2F;<em>.scala, project&#x2F;</em>.sbt files). Needed if you change the build definition.</td>
</tr>
</tbody></table>
<h3 id="build-sbt"><a href="#build-sbt" class="headerlink" title="build.sbt"></a>build.sbt</h3><p><code>build.sbt</code>构建定义：</p>
<ul>
<li>指定sbt版本，这样就使用不同版本的sbt构建同一个项目了。如果指定的版本不可用，那么会自动下载。</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sbt</span>.version=<span class="hljs-number">1</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<ul>
<li>构建定义（build definition）：</li>
<li>包含了一系列项目（<a target="_blank" rel="noopener" href="https://www.scala-sbt.org/1.x/api/sbt/Project.html">Scala中的Project类型</a>），项目这个名词有一定的模糊性，所以其中的一个个项目一般将之称为子项目。</li>
<li>在<code>build.sbt</code>中可以定义一个在当前目录中的子项目：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">lazy val root = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    scalaVersion := <span class="hljs-string">&quot;2.12.7&quot;</span><br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>项目的名称在<code>.setting</code>方法中用一个键值对定义，key是<code>name</code>，值是一个字符串表示项目名称。</li>
<li><code>build.sbt</code>定义所有的子项目，包含一些的键值对称为<code>setting</code>表达式，使用一门build.sbt DSL（本质上其实就是Scala）来定义项目。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br>ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br>ThisBuild / version      := <span class="hljs-string">&quot;0.1.0-SNAPSHOT&quot;</span><br><br>lazy val root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;hello&quot;</span><br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li><p>看一看这门DSL的定义：</p>
<p><img src="https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgScala_sbt_dsl_setting_expression.png" srcset="/img/loading.gif" lazyload></p>
<p>每一个都叫做一个setting expression，其中的一些又被叫做task expression。</p>
</li>
<li><p>一个setting expression包含三部分：</p>
<ol>
<li>左边是key。</li>
<li>操作符，这个例子中是<code>:=</code></li>
<li>右边是setting body。</li>
</ol>
</li>
<li><p>一个key的类型是<code>sbt.SettingKey[T] sbt.TaskKey[T] sbt.InputKey[T]</code>其中一者的实例，T是期望的值类型。</p>
</li>
<li><p>比如<code>name</code>就绑定到了<code>SettingKey[String]</code>类型，给个其他类型比如整数的话就会编译错误。</p>
</li>
<li><p>在<code>build.sbt</code>中可以穿插<code>val</code> <code>lazy val</code> <code>def</code>，但是不能有顶层<code>object class</code>定义。</p>
</li>
</ul>
<p>expression的key：</p>
<ul>
<li>三种类型：<ul>
<li><code>SettingKey[T]</code> 值仅在加载子项目时计算一次，然后保持。</li>
<li><code>TaskKey[T]</code> 值被称为一个任务（task），每次都会重新计算（何时？），存在潜在的副作用。</li>
<li><code>InputKey[T]</code> 值是有命令行输入作为参数的任务，细节见<a target="_blank" rel="noopener" href="https://www.scala-sbt.org/1.x/docs/Input-Tasks.html">Input Tasks</a>。</li>
</ul>
</li>
<li>内建的keys就是<code>sbt.Keys</code>单例伴生对象的域。<code>build.sbt</code>隐式导入<code>import sbt.Keys._</code>，<code>sbt.Keys.name</code>就是<code>name</code>，所以其实就是对这些字段做赋值。</li>
<li>自定义key：使用各自的方法<code>settingKey taskKey inputKey</code>，每个方法需要一个value的类型和描述。key的名称就是被赋值到的引用变量名称。</li>
<li>定义一个自定义key，名称是<code>hello</code>，类型是<code>TaskKey</code>，对应值类型是<code>Unit</code>：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello <span class="hljs-operator">=</span> taskKey[Unit](<span class="hljs-string">&quot;An example task&quot;</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>所有这种定义都在设置前被求值，无论定义在文件什么位置。</li>
<li>一般来说，使用<code>lazy val</code>而不是<code>val</code>来避免初始化顺序导致的问题。</li>
<li>Task和Setting区别：<ul>
<li>Task是任务，比如<code>compile</code> <code>package</code>都是<code>sbt.Keys</code>中的域，同时也是sbt shell中可执行的命令。应该返回<code>Unit</code>或者返回和这个任务相关的值，比如<code>package</code>是<code>TaskKey[File]</code>值是其创建的jar文件。</li>
<li>每一次开始一个任务，比如sbt shell中执行<code>compile</code>，sbt都会重新跑（仅）一次这个任务相关的所有任务。</li>
<li>而Setting仅仅只是一个朴素的设置项。</li>
</ul>
</li>
</ul>
<p>定义任务和设置：</p>
<ul>
<li>使用<code>:=</code>可以将一个设置或者一项计算任务赋值。设置只会在记载项目时计算一次，任务则会在每次执行这个任务被执行时重新执行。</li>
<li>新建一个任务：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello <span class="hljs-operator">=</span> taskKey[Unit](<span class="hljs-string">&quot;An example task&quot;</span>)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> root <span class="hljs-operator">=</span> (project <span class="hljs-keyword">in</span> file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    hello <span class="hljs-operator">:=</span> &#123; println(<span class="hljs-string">&quot;Hello!&quot;</span>) &#125;<br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>任务也在<code>.settings</code>中被赋值。</li>
<li>每次在sbt shell中执行<code>hello</code>都会执行其中<code>println</code>语句。</li>
<li>定义设置的话已经说过。</li>
<li>从类型系统的视角来看，对任务赋值得到一个<code>Setting[Task[T]]</code>，对设置赋值得到<code>Setting[T]</code>。<code>T Task[T]</code>的区别有一层隐含的含义：一个设置不能依赖于一个任务。因为设置仅记载是求值一次不会每次都重新运行。</li>
</ul>
<p>sbt shell中的key：</p>
<ul>
<li>sbt shell中可以输入任何任务名称都会运行该任务，因为这个任务名称是key。运行该任务但并不会显示运行结果值（也就是返回值，类型就是<code>taskKey[T]</code>中的<code>T</code>），要显示结果值，应该使用<code>show &lt;task name&gt;</code>而不是单纯的<code>&lt;task name&gt;</code>。</li>
<li>如果输入设置的key的话，会显示设置的值。</li>
<li>要知道一个key的更多信息，可以使用<code>inspect &lt;keyname&gt;</code>。某些信息现在看起来可能不知道含义，但最顶上有类型和简要描述。</li>
</ul>
<p>在<code>build.sbt</code>中导入信息：</p>
<ul>
<li>比如：</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sbt._<br><span class="hljs-keyword">import</span> Keys._<br></code></pre></td></tr></table></figure>

<ul>
<li>中间不能有空行。</li>
<li>如果有自动插件（<a target="_blank" rel="noopener" href="https://www.scala-sbt.org/1.x/api/sbt/AutoPlugin.html"><code>sbt.AutoPlugin</code></a>，可以从其派生实现自己的插件），那么在其中的<code>autoImport</code>单例对象下的名称会被自动导入。</li>
</ul>
<p>Bare .sbt build definition：</p>
<ul>
<li>也就是裸的构建定义，设置可以被直接写到<code>.sbt</code>而不是项目的<code>.setting(...)</code>调用下，称之为bare style。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ThisBuild / version := <span class="hljs-string">&quot;1.0&quot;</span><br>ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这种语法推荐用来写在<code>ThisBuild</code>作用域下的设置和添加插件。后续会有作用域和插件的说明。</li>
</ul>
<p>添加库依赖：</p>
<ul>
<li>为了能够依赖第三方库，有两种方式：</li>
<li>一是将jar文件直接放在<code>lib/</code>（未管理的依赖）目录下，第二种是添加管理的依赖，通过在<code>.setting(..)</code>调用中对<code>libraryDependencies</code>key做<code>+=</code>操作做到。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">val derby = <span class="hljs-string">&quot;org.apache.derby&quot;</span> %% <span class="hljs-string">&quot;derby&quot;</span> % <span class="hljs-string">&quot;10.4.1.3&quot;</span><br><br>ThisBuild / organization := <span class="hljs-string">&quot;com.example&quot;</span><br>ThisBuild / scalaVersion := <span class="hljs-string">&quot;2.12.14&quot;</span><br>ThisBuild / version      := <span class="hljs-string">&quot;0.1.0-SNAPSHOT&quot;</span><br><br>lazy val root = (project in file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .settings(<br>    name := <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies += derby<br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>包含包的组织、包名、和包的版本。可以定义变量来复用。<code>%</code>运算符被用来从字符串构建一个模块ID。</li>
</ul>
<h3 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h3><p>多个项目定义：</p>
<ul>
<li>在一次构建中编译多个相关联的子项目是很有用的，特别是其间存在依赖，想更改他们所有的时候。</li>
<li>每个子项目都有自己的目录，构建时都会生成自己的jar文件，</li>
<li>项目使用<code>lazy val</code>定义一个<a target="_blank" rel="noopener" href="https://www.scala-sbt.org/1.x/api/sbt/Project.html">sbt.Project</a>来实现。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">lazy val util = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;util&quot;</span>))<br><br>lazy val core = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br></code></pre></td></tr></table></figure>

<ul>
<li>这个<code>val</code>的不变量名称被用做子项目的ID（也即是项目名称），在sbt shell中也用来指代一个子项目。</li>
<li>后面的<code>in file()</code>调用指定他们的base directory是可选的，目录名就是他们的名称。</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util <span class="hljs-operator">=</span> project<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core <span class="hljs-operator">=</span> project<br></code></pre></td></tr></table></figure>

<p>公共设置；</p>
<ul>
<li>为了分离出跨子项目的设置，可以将其定义在<code>ThisBuild</code>范围下。<code>ThisBuild</code>表现的像一个普通的子项目名称一样使用，其下用来定义默认值。</li>
<li>如果定义了多个子项目，并且子项目下没有定义比如<code>scalaVersion</code>这个key，就会查找<code>ThisBuild / scalaVersion</code>。</li>
<li>这样定义的限制是右边的值只能是纯粹的值或者在<code>Global</code>&#x2F;<code>ThisBuild</code>下的设置。</li>
<li>子项目范围下没有默认值。</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">ThisBuild <span class="hljs-operator">/</span> organization <span class="hljs-operator">:=</span> <span class="hljs-string">&quot;com.example&quot;</span><br>ThisBuild <span class="hljs-operator">/</span> version      <span class="hljs-operator">:=</span> <span class="hljs-string">&quot;0.1.0-SNAPSHOT&quot;</span><br>ThisBuild <span class="hljs-operator">/</span> scalaVersion <span class="hljs-operator">:=</span> <span class="hljs-string">&quot;2.12.14&quot;</span><br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core <span class="hljs-operator">=</span> (project <span class="hljs-keyword">in</span> file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    <span class="hljs-comment">// other settings</span><br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util <span class="hljs-operator">=</span> (project <span class="hljs-keyword">in</span> file(<span class="hljs-string">&quot;util&quot;</span>))<br>  .settings(<br>    <span class="hljs-comment">// other settings</span><br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>重载后，现在<code>versoin</code>和其他的设置在所有子项目中都会生效。</li>
</ul>
<p>另一种定义公共设置的方式：</p>
<ul>
<li>将默认设置放在<code>commonSettings</code>下，然后添加到所有子项目中<code>.setting()</code>调用中。</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> commonSettings <span class="hljs-operator">=</span> Seq(<br>  target <span class="hljs-operator">:=</span> &#123; baseDirectory.value <span class="hljs-operator">/</span> <span class="hljs-string">&quot;target2&quot;</span> &#125;<br>)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core <span class="hljs-operator">=</span> (project <span class="hljs-keyword">in</span> file(<span class="hljs-string">&quot;core&quot;</span>))<br>  .settings(<br>    commonSettings,<br>    <span class="hljs-comment">// other settings</span><br>  )<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> util <span class="hljs-operator">=</span> (project <span class="hljs-keyword">in</span> file(<span class="hljs-string">&quot;util&quot;</span>))<br>  .settings(<br>    commonSettings,<br>    <span class="hljs-comment">// other settings</span><br>  )<br></code></pre></td></tr></table></figure>

<p>项目间依赖：</p>
<ul>
<li>项目间可以完全独立，也通常可能会有某种方式的依赖。</li>
<li>有两种方式的依赖：aggregate and classpath，用<code>.aggregate .dependsOn</code>定义。</li>
<li>聚合用来广播命令，类路径依赖则是指项目之间存在依赖关系。</li>
</ul>
<p>聚合（Aggregation）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">lazy val root = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(util, core)<br><br>lazy val util = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;util&quot;</span>))<br><br>lazy val core = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;core&quot;</span>))<br></code></pre></td></tr></table></figure>

<ul>
<li>这种方式在聚合项目上运行任务时会同样在它聚合的所有子项目上运行。</li>
<li>比如上面的子项目定义，编译<code>root</code>是会同时编译<code>util core</code>。</li>
<li>通过在做聚合的项目中定义设置可以修改这种默认行为：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lazy val root = (project <span class="hljs-keyword">in</span> <span class="hljs-built_in">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  <span class="hljs-selector-class">.aggregate</span>(util, core)<br>  <span class="hljs-selector-class">.settings</span>(<br>    update / aggregate := false<br>  )<br><br><span class="hljs-selector-attr">[...]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>上面设置表示在root项目上执行<code>update</code>是就不会在被聚合的子项目上执行。<code>update / aggregate</code>是update作用域下的key。</li>
</ul>
<p>类路径依赖：</p>
<ul>
<li>一个项目可能依赖另一个项目的代码，通过<code>.dependsOn(proj1, proj2, ...)</code>方法调用来定义。依赖之后就会被添加到classpth，从而能够导入。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> core = project.depends<span class="hljs-constructor">On(<span class="hljs-params">util</span>)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>现在在<code>core</code>中就可以调用<code>util</code>中的代码了。这同样也确定了代码编译顺序必然是先<code>util</code>后<code>core</code>。</li>
<li><code>core dependsOn(util)</code>意味着<code>core</code>的编译配置依赖<code>util</code>，也可以显式通过<code>dependsOn(util % &quot;compile-&gt;compile&quot;)</code>这种方式来指定，<code>compile-&gt;compile</code>中的<code>-&gt;</code>意味着依赖。因此如果是<code>&quot;test-&gt;compile&quot;</code>就以为着<code>core</code>的<code>test</code>配置依赖<code>util</code>的<code>compile</code>配置。可以忽略后面的<code>-&gt;config</code>部分意味着就是<code>-&gt;comile</code>。</li>
<li>一个比较有用的定义是<code>test-&gt;test</code>意味着测试<code>core</code>是先测试<code>util</code>。</li>
<li>可以用分好分隔：<code>dependsOn(util % &quot;test-&gt;test;compile-&gt;compile&quot;)</code>。</li>
</ul>
<p>项目间依赖：</p>
<ul>
<li><p>在大项目中，会有许多文件，持续监视文件修改并重新编译将会消耗大量磁盘和IO资源。</p>
</li>
<li><p>sbt使用</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">trackInternalDependencies</span><br></code></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">exportToInternal</span><br></code></pre></td></tr></table></figure>

<p>设置用来控制执行</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">compile</span><br></code></pre></td></tr></table></figure>

<p>任务时是否触发独立子项目的编译。两个key都接受三个输入：</p>
<ul>
<li><code>TrackLevel.NoTracking</code></li>
<li><code>TrackLevel.TrackIfMissing</code></li>
<li><code>TrackLevel.TrackAlways</code> 默认是这一项。</li>
<li>含义显而易见。</li>
</ul>
</li>
<li><p><code>trackInternalDependencies</code>设置如果是<code>TrackLevel.TrackIfMissing</code>，那么sbt将不会尝试自动编译项目间依赖，除非输出目录中的<code>*.class</code>文件缺失了（或者<code>exportJars</code>时jar文件缺失了）。</p>
</li>
<li><p>当被设置为<code>TrackLevel.NoTracking</code>，项目将依赖将被跳过。但是classpth仍然会被添加，依赖图也会显示他们还是依赖的。这么做的目的是为了减小检查文件修改的IO负担。</p>
</li>
<li><p>设置方法：</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">ThisBuild / trackInternalDependencies := TrackLevel.TrackIfMissing<br>ThisBuild / exportJars := <span class="hljs-keyword">true</span><br><br>lazy val root = (<span class="hljs-keyword">project</span> in <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(....)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>exportToInternal</code>设置允许依赖于当前项目的子项目跳过内部追踪。用在一个子项目上，用在当前不关心的依赖于其他项目的子项目，当其他项目发生修改重新编译，它也不会重新编译。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lazy val dontTrackMe = (project <span class="hljs-keyword">in</span> <span class="hljs-built_in">file</span>(<span class="hljs-string">&quot;dontTrackMe&quot;</span>))<br>  <span class="hljs-selector-class">.settings</span>(<br>    exportToInternal := TrackLevel<span class="hljs-selector-class">.NoTracking</span><br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li><code>trackInternalDependencies</code>和<code>exportToInternal</code>，比如当前修改项目时A，A依赖B，C依赖A，那么前者是针对B也就是当前项目依赖的那些子项目，后者针对C也就是依赖当前项目的子项目。这是我的理解，应该是这个样子！</li>
<li>如果没理解错的话，项目的依赖关系（指classpth，会调用的那种依赖）应该是一棵树，而不会有环图。</li>
</ul>
<p>默认的根项目：</p>
<ul>
<li>如果没有为最顶层目录<code>.</code>定义项目，那么sbt会创建一个默认的然后在构建时聚合所有子项目。</li>
</ul>
<p>与项目的交互：</p>
<ul>
<li><code>projects</code>列出所有子项目。</li>
<li><code>proejct</code>列出当前项目，<code>project &lt;projectname&gt;</code>切换项目。运行一个任务比如<code>compile</code>时是针对当前项目。</li>
<li>也可以通过指定项目名称来在某个项目上运行任务：<code>subProjectID / &lt;taskname&gt;</code>。</li>
</ul>
<p>公共代码：</p>
<ul>
<li><code>.sbt</code>文件之间的定义是不共享的。</li>
<li>为了能够在不同<code>.sbt</code>之间共享代码，需要在根目录的<code>project/</code>下面（子目录中的是没有用的，会被忽略，只有根目录中的才会有效）定义一个或多个scala文件。后续会详述。</li>
</ul>
<p>子项目中的<code>.sbt</code>文件：</p>
<ul>
<li>所有的<code>.sbt</code>文件都会被合并到一个整体的构建（build）中来，但是只在他们自己的范围内起作用。定义不会被共享。</li>
<li>比如顶层<code>hello</code>目录中初始化<code>sbt</code>，<code>.</code>定义根项目<code>hello</code>，<code>hello/foo/ hello/bar</code>分别定义项目foo和bar并且有自己的<code>build.sbt</code>并把项目定义在了其中，其中定义了自己的不同版本。</li>
<li>那么执行<code>show version</code>的结果就是这样的：</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">&gt; show version<br>[<span class="hljs-built_in">info</span>] hello-foo/*<span class="hljs-symbol">:ve</span>rsion<br>[<span class="hljs-built_in">info</span>]  <span class="hljs-number">0.7</span><br>[<span class="hljs-built_in">info</span>] hello-bar/*<span class="hljs-symbol">:ve</span>rsion<br>[<span class="hljs-built_in">info</span>]  <span class="hljs-number">0.9</span><br>[<span class="hljs-built_in">info</span>] hello/*<span class="hljs-symbol">:ve</span>rsion<br>[<span class="hljs-built_in">info</span>]  <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure>

<ul>
<li>所有的<code>build.sbt</code>都是整个构建的一部分，但都有自己的作用范围。</li>
<li>可以分开定义，也可以合起来定义<code>build.sbt</code>，项目很多时都定义在根目录中可能就太复杂了，定义在子目录找起来好像又挺麻烦。</li>
<li>风格选择：<ul>
<li>子项目的设置在子项目的<code>.sbt</code>中定义，根<code>build.sbt</code>中只定义最小的项目声明，形如：<code>lazy val foo = (project in file(&quot;foo&quot;))</code>不修改任何设置。</li>
<li>推荐是将所有项目定义全都放在根目录中的<code>build.sbt</code>，保持项目定义在一个文件中。</li>
<li>都可以，这完全取决于你。</li>
</ul>
</li>
</ul>
<h3 id="任务图"><a href="#任务图" class="headerlink" title="任务图"></a>任务图</h3><p>任务图：</p>
<ul>
<li>除了将设置视作一个个键值对，更好的比喻其实是以有向无环图（DAG）。边的方向表示<strong>在之前发生</strong>，称之为任务图（Task Graph） 。</li>
<li>Setting&#x2F;Task expression就是前面的在<code>.setting(...)</code>中定义了设置或者任务的表达式。</li>
</ul>
<p>任务间依赖：</p>
<ul>
<li>使用一个特殊的<code>.value</code>方法调用来解释任务之间的依赖。</li>
<li>直到非常熟悉<code>hello.sbt</code>之前，都推荐将<code>.value</code>调用放在task定义块中最上方。</li>
<li>除了使用一个不变量赋值的方式，也可以使用内联的<code>.value</code>调用，更加间接，也不用去想变量名。</li>
<li><code>.value</code>调用会在进入task body之前被求值，这是需要非常注意的。</li>
<li>测试：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hi <span class="hljs-operator">=</span> taskKey[Unit](<span class="hljs-string">&quot;An example task for dependency&quot;</span>)<br><br><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> hello <span class="hljs-operator">=</span> (project <span class="hljs-keyword">in</span> file(<span class="hljs-string">&quot;.&quot;</span>))<br>  .aggregate(helloCore)<br>  .dependsOn(helloCore)<br>  <span class="hljs-comment">// .enablePlugins(JavaAppPackaging)</span><br>  .settings(<br>    name <span class="hljs-operator">:=</span> <span class="hljs-string">&quot;Hello&quot;</span>,<br>    libraryDependencies <span class="hljs-operator">+=</span> scalaTest <span class="hljs-operator">%</span> Test,<br>    hi <span class="hljs-operator">:=</span> &#123;<br>      <span class="hljs-keyword">val</span> ur <span class="hljs-operator">=</span> update.value <span class="hljs-comment">// streams task happens-before hi</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">val</span> x <span class="hljs-operator">=</span> clean.value <span class="hljs-comment">// clean task happens-before hi</span><br>      &#125;<br>    &#125;<br>  )<br></code></pre></td></tr></table></figure>

<ul>
<li>此时任务<code>hi</code>就会依赖于任务<code>update</code>和<code>clean</code>，并且这两个任务是在进入<code>hi</code>任务体前执行的，且不确定两者先后顺序，可先可后可并行。</li>
<li>在任务体中调用<code>.value</code>仅用来表明任务之间的依赖关系。</li>
<li>先编译项目，执行<code>hi</code>后会发现<code>target/scala-2.13/clsses/</code>被清除，就是因为执行了<code>clean</code>任务。</li>
<li>查看任务间依赖：在<code>Dependencies:</code>后可以看到。</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">inspect hi</span><br></code></pre></td></tr></table></figure>

<ul>
<li>执行<code>inspect tree compile</code>会看到<code>compile</code>命令的依赖树，什么含义暂时不知。</li>
<li>sbt中的构建任务依赖是自动的而不是显式定义的，如果通过<code>.value</code>定义了，那么会造成任务间依赖。</li>
</ul>
<p>任务依赖设置：</p>
<ul>
<li>在任务体定义中调用设置的<code>.value</code>就行。</li>
<li>但设置是不能依赖任务的，因为设置只在重载时执行一次，而任务一直都可以执行。</li>
</ul>
<p>设置依赖设置：</p>
<ul>
<li>可以将设置看做仅在记加载是执行一次的任务，所以设置也可以依赖设置。</li>
<li>同样其中调用<code>.value</code>就可以依赖，并且执行时求值：</li>
<li>一个实际的例子：当Scala版本是2.11时讲将<code>Compile / scalaSource</code>定义到一个不同的目录。</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">Compile / scalaSource := &#123;<br>  val old = (Compile / scalaSource).value<br>  scalaBinaryVersion.value <span class="hljs-keyword">match</span> &#123;<br>    <span class="hljs-built_in">case</span> <span class="hljs-string">&quot;2.11&quot;</span> =&gt; baseDirectory.value / <span class="hljs-string">&quot;src-2.11&quot;</span> / <span class="hljs-string">&quot;main&quot;</span> / <span class="hljs-string">&quot;scala&quot;</span><br>    <span class="hljs-built_in">case</span> <span class="hljs-keyword">_</span>      =&gt; old<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再看<code>build.sbt</code>DSL：</p>
<ul>
<li>构建了一个设置和任务的有向无环图。</li>
<li>设置表达式编码了设置、任务以及他们之间的依赖。</li>
<li>这种结构在Make&#x2F;Ant&#x2F;Rake等构建工具中很常见。</li>
<li>基于流的编程，减少了重复过程，好处：</li>
<li>一个任务仅仅只会执行一次，即使它被多个任务所依赖比如<code>Compile / compile</code>。</li>
<li>基于任务图，任务引擎会安排不相关的任务并行执行。</li>
<li>关注点分离和灵活性，任务图让用户可以将任务以不同的方式连接到一起，sbt和各种插件可以提供各种各样的特性比如库依赖管理等。</li>
</ul>
<p>总结：</p>
<ul>
<li>核心就是任务图，任务之间的关系是一个有向无环图。</li>
<li><code>hello.sbt</code>是一个设计来面向依赖编程（dependency-oriented programming）的DSL，或者叫基于流（flow）的编程。就像Makefile。语法就像Scala，但并不等同于Scala，语义上是有区别的。</li>
<li>基于流的编程的核心是：减少重复过程、并行处理和定制化。</li>
</ul>
<h3 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h3><p>更多内容就不翻译了，官网上第一章也有中文翻译。需要时再去阅读，现阶段感觉都用不到，真写项目了再看不迟。</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>TODO</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：</p>
<ul>
<li>看起来是一门静态类型语言，提供了很其强大的类型推导，可以一定程度上实现隐式静态类型，但写起来如果高度依赖类型推导的话会和动态类型一样简洁，仅需提供少量必须的类型，只是有点牺牲可读性。</li>
<li>函数式编程很有趣。</li>
<li>语法糖太太太多了，虽然看起来更简洁了，但是读起来不一定更简单，学起来心智负担也更大。</li>
<li>运算符非常灵活，目前遇到过的运算符最灵活的语言。</li>
<li>并发编程还没有学，TODO。</li>
<li>Scala语法确实有点太强大了，当然软件工程的东西都是tradeoff，写起来爽用起来复杂学起来难。</li>
</ul>
<p>Scala是我目前学过的最舒服的语言，很多特点简直太棒了，如果此生只能选一门语言的话，那我可能真会选这门刚学了几天的语言。吸引我的点：</p>
<ul>
<li>函数式编程，和集合的映射推导结合起来很有用。</li>
<li>类型推导，像动态语言用起来的感觉，但也有编译期类型检查，再加上隐式类型转换，真我全都要。</li>
<li>各种能简则简的语法糖，初看可能很诧异，习惯之后只能说去**的java，简洁而不简单。</li>
<li>运算符重载，容易被滥用，但用得好会使代码进一步简化，当然各式各样的运算符会进一步增加读代码的难度。</li>
<li>更加纯粹的面向对象，万物皆是对象。</li>
</ul>
</div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "YutingNotFound",
							"blogId": "04372-4551209630277-002",
							"qrcode": "https://raw.githubusercontent.com/YUTING0907/PicGo/main/imgYUTING__PHOTO_.jpg",
							"keyword": "验证码",
							"random": "1",
							"height": "auto",
							"expires": "36500",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": "",
							"tocSelector": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			
              
            </div>
            <hr/>
            
            <!-- donate -->
            <div class="reward-container">
            	
            		<button id="rewardBtn" class="reward-btn">
            			 
            				 Donate
            				
            		</button>
            		<p class="tea">觉得不错的话，给点打赏吧 ୧(๑•̀⌄•́๑)૭</p>
            		<div id="rewardImgContainer" class="reward-img-container">
                     	<div class="singleImgContainer">
                        	<img id="wechatImg" class="reward-img" src="/img/wechatpay.jpg" srcset="/img/loading.gif" lazyload alt="">
                            <p class="wechatPay">wechat pay</p>
                      </div>
                      <div class="singleImgContainer">
                           	<img id="alipayImg" class="reward-img" src="/img/alipay.jpg" srcset="/img/loading.gif" lazyload alt="">
                            <p class="aliPay">alipay</p>
                      </div>
            		</div>
            	
            </div>
            
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Scala/">#Scala</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Scala语言入门</div>
      <div>http://yuting0907.github.io/2022/05/29/Scala语言入门/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Echo Yu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月29日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/29/%E4%B9%A6%E5%8D%95/" title="书单">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">书单</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/28/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0-%E7%BB%93%E6%9D%9F%E8%AF%AD_%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5%EF%BC%8C%E8%A6%81%E5%88%B0%E5%93%AA%E9%87%8C%E5%8E%BB%EF%BC%9F/" title="数据中台-结束语_数据中台从哪里来，要到哪里去？">
                        <span class="hidden-mobile">数据中台-结束语_数据中台从哪里来，要到哪里去？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/reward.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

<!--  -->
<script type="text/javascript" src="/js/love.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>  

<!--浏览器搞笑标题-->
<script type="text/javascript" src="/js/FunnyTitle.js"></script>
