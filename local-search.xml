<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python-应用-实现2048.</title>
    <link href="/2019/12/28/python%E5%AE%9E%E7%8E%B02048/"/>
    <url>/2019/12/28/python%E5%AE%9E%E7%8E%B02048/</url>
    
    <content type="html"><![CDATA[<hr><p>本篇文章是利用python 实现2048小游戏<br>目的：为了提高自己的编程思路</p><p>环境：win8+python3.6+curses模块 Pycharm<br>适用人群：python入门+想用python做点事情的朋友们</p><p>大家可能都玩过2048，我记得那时候还蛮火的。不过那个时候我还没有接触编程，根本想不到自己今天还会写代码。。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>游戏规则</strong>：玩家通过 w s a d 控制数字移动方向，达成 2048 这个数字即获胜。</p><p>每次可以选择一个方向移动，数字便会朝这个方向移动，如果遇到相同数字就相加，遇到不同数字或者边界就停止移动。同时会在空白的地方生成 2 或者 4 的随机数字。通过不断相撞、相加，最后达成 2048 这个数字。</p><p><strong>编程思路：</strong></p><p><strong>1.首先想象一下游戏的几个状态：</strong></p><p>状态1：初始化状态(也就是刚开始游戏）<br>状态2：游戏中(Game ing……)<br>状态3：你赢了(Win)<br>状态4：你输了(Game Over)</p><p><strong>2.用户行为</strong></p><p>用户通过行为(action)改变来完成一个游戏状态到另一个游戏状态的该表，比如用户上移，下移，左移，右移，重置和退出。</p><p><strong>3.由一个状态转化到另一个状态</strong></p><p>分析一下从一个状态到下一个状态的所有可能性：<br>1.当上一个状态是初始化(Init)状态时，下一个状态肯定是游戏中(Game ing…)的状态。</p><p>2.当上一个状态为游戏中(Game ing…)的状态时，下一个状态要根据用户的输入来判断，如用户输入Restart,则下一个状态返回为初始化状态(Init)，如用户输入Exit的时候，下一个状态转换为退出游戏(Exit),</p><p>用户还可以上下左右移动，这时候下一个状态可能是你输了(Game Over)或者你赢了(Win)，再或者继续游戏。</p><p>3.当上一个状态为你输了(Game Over)，用户输入Restart，下一个状态可能为初始化(Init)状态，用户输入Exit的时候，下一个状态转换为退出游戏(Exit)。</p><p>4.当上一个状态为你赢了(Win)，用户输入Restart，下一个状态可能为初始化(Init)状态，用户输入Exit的时候，下一个状态转换为退出游戏(Exit)。</p><p>其中3和4神似，可以合并起来得到not_game的功能。</p><p>上述文字用图表示如下：</p><p>! [ 图片来自实验楼] ( <a href="http://m.qpic.cn/psc?/V10c1VbY1Y4Fvm/3pY6KhS62k*1Vm7UATlxq*dT9N4M9SFdcoa2exyDwTjMQRzdwgQxzI3eywPjhcCPWMtBAbo8u2e.zNSVqh5WGr9RvKTwx9YMevj37h84A.s!/b&amp;bo=ZgKCAQAAAAADF9U!&amp;rf=viewer_4&amp;t=5">http://m.qpic.cn/psc?/V10c1VbY1Y4Fvm/3pY6KhS62k*1Vm7UATlxq*dT9N4M9SFdcoa2exyDwTjMQRzdwgQxzI3eywPjhcCPWMtBAbo8u2e.zNSVqh5WGr9RvKTwx9YMevj37h84A.s!/b&amp;bo=ZgKCAQAAAAADF9U!&amp;rf=viewer_4&amp;t=5</a> )</p><p><strong>另外除非用户按代表退出的按键(Exit)或者游戏被玩死了,否则游戏一直被挂起。</strong></p><p>根据以上分析，下面可以初略的搭建程序大致的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">stdscr</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>        <span class="hljs-comment"># 重置游戏棋盘</span><br>        game_field.reset()<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Game&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">game</span>():<br>        <span class="hljs-comment"># 画出 GameOver 或者 Win 的界面</span><br>        game_field.draw(stdscr)<br>        <span class="hljs-comment"># 读取用户输入得到action，判断是重启游戏还是结束游戏</span><br>        action = get_user_action(stdscr)<br><br>        <span class="hljs-keyword">if</span> action ==<span class="hljs-string">&#x27;Restart&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Init&#x27;</span><br>        <span class="hljs-keyword">if</span> action==<span class="hljs-string">&#x27;Exit&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Exit&#x27;</span><br>        <span class="hljs-keyword">if</span> game_field.move(action):<br>            <span class="hljs-keyword">if</span> game_field.is_win():<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Win&#x27;</span><br>            <span class="hljs-keyword">if</span> game_field.is_gameover():<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Gameover&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Game&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">not_game</span>(<span class="hljs-params">state</span>):<br>        <span class="hljs-comment"># 画出 GameOver 或者 Win 的界面</span><br>        game_field.draw(stdscr)<br>        <span class="hljs-comment"># 读取用户输入得到action，判断是重启游戏还是结束游戏</span><br>        action = get_user_action(stdscr)<br>        responses = defaultdict(<span class="hljs-keyword">lambda</span>:state)<br>        responses[<span class="hljs-string">&#x27;Restart&#x27;</span>], responses[<span class="hljs-string">&#x27;Exit&#x27;</span>] = <span class="hljs-string">&#x27;Init&#x27;</span>,<span class="hljs-string">&#x27;Exit&#x27;</span><br>        <span class="hljs-keyword">return</span> responses[action]<br><br><span class="hljs-comment"># 游戏盘的四种状态</span><br>    state_actions=&#123;<br>        <span class="hljs-string">&#x27;Init&#x27;</span>:init,<br>        <span class="hljs-string">&#x27;Win&#x27;</span>:<span class="hljs-keyword">lambda</span>:not_game(<span class="hljs-string">&#x27;Win&#x27;</span>),<br>        <span class="hljs-string">&#x27;Gameover&#x27;</span>:<span class="hljs-keyword">lambda</span>:not_game(<span class="hljs-string">&#x27;Gameover&#x27;</span>),<br>        <span class="hljs-string">&#x27;Game&#x27;</span>:game<br>    &#125;<br><br>    game_field = GameField(win=<span class="hljs-number">2048</span>)<br>    state = <span class="hljs-string">&#x27;Init&#x27;</span><br>    <span class="hljs-keyword">while</span> state!=<span class="hljs-string">&#x27;Exit&#x27;</span>:<br>        state = state_actions[state]()<br></code></pre></td></tr></table></figure><p>4.丰富框架<br>大体的骨架搭好了，下面让它完善起来。</p><p>分为两类：<br>第一类，把它叫做通用工具类。</p><p>这两个操作主要是用户在操作游戏之后对棋盘状态的变化以及修改，拥有这两个函数能够节省不少的代码量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transpose</span>(<span class="hljs-params">field</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">list</span>(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*field)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">invert</span>(<span class="hljs-params">field</span>):<br>    <span class="hljs-keyword">return</span> [row[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> field]<br></code></pre></td></tr></table></figure><p>如下为用户输入函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">actions = [<span class="hljs-string">&#x27;Up&#x27;</span>, <span class="hljs-string">&#x27;Left&#x27;</span>, <span class="hljs-string">&#x27;Down&#x27;</span>, <span class="hljs-string">&#x27;Right&#x27;</span>, <span class="hljs-string">&#x27;Restart&#x27;</span>, <span class="hljs-string">&#x27;Exit&#x27;</span>]<br><span class="hljs-comment"># 分别用 W（上），A（左），S（下），D（右），R（重置），Q（退出），进行输入来操作游戏，这里考虑到大写锁定键锁定的情况：</span><br>letter_codes = [<span class="hljs-built_in">ord</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;WASDRQwasdrq&#x27;</span>]<br>actions_dict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(letter_codes, actions*<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_action</span>(<span class="hljs-params">keyboard</span>):<br>    char = <span class="hljs-string">&#x27;N&#x27;</span><br>    <span class="hljs-comment">#阻塞＋循环，直到获得用户有效输入才返回对应行为：</span><br>    <span class="hljs-keyword">while</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> actions_dict:<br>        char = keyboard.getch()<br>    <span class="hljs-keyword">return</span> actions_dict[char]<br></code></pre></td></tr></table></figure><p>第二大类：棋盘类<br>包含重置棋盘、棋盘走一步、判断输赢、绘制游戏界面、随机生成一个 2 或者 4、判断能否移动的功能。</p><p>重置棋盘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#重置棋盘</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">if</span> self.score&gt;self.highscore:<br>        self.highscore = self.score<br>    self.score = <span class="hljs-number">0</span><br>    self.field = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.width)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.height)]<br>    self.spawn()<br>    self.spawn()<br></code></pre></td></tr></table></figure><p>棋盘走一步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">self,direction</span>):<br>    <span class="hljs-comment">#一行相左合并</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">move_row_left</span>(<span class="hljs-params">row</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">tighten</span>(<span class="hljs-params">row</span>): <span class="hljs-comment">#把零散的非零单元挤到一块</span><br>            new_row = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> row <span class="hljs-keyword">if</span> i!=<span class="hljs-number">0</span>]<br>            new_row+=[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(row)-<span class="hljs-built_in">len</span>(new_row))]<br>            <span class="hljs-keyword">return</span> new_row<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">row</span>):<br>            pair=<span class="hljs-literal">False</span><br>            new_row=[]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(row)):<br>                <span class="hljs-keyword">if</span> pair:<br>                    <span class="hljs-comment"># 合并后，加入乘 2 后的元素在 0 元素后面</span><br>                    new_row.append(<span class="hljs-number">2</span>*row[i])<br>                    self.score+=<span class="hljs-number">2</span>*row[i]<br>                    pair=<span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">len</span>(row) <span class="hljs-keyword">and</span> row[i]==row[i+<span class="hljs-number">1</span>]:<br>                        pair=<span class="hljs-literal">True</span><br>                        <span class="hljs-comment"># 不能合并，新列表中加入该元素</span><br>                        new_row.append(<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        new_row.append(row[i])<br>            <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(new_row)==<span class="hljs-built_in">len</span>(row)<br>            <span class="hljs-keyword">return</span> new_row<br>        <span class="hljs-comment"># 先挤到一块再合并再挤到一块</span><br>        <span class="hljs-keyword">return</span> tighten(merge(tighten(row)))<br><br>    <span class="hljs-comment"># 创建 moves 字典，把不同的棋盘操作作为不同的 key，对应不同的方法函数</span><br>    moves=&#123;&#125;<br>    moves[<span class="hljs-string">&#x27;Left&#x27;</span>] = <span class="hljs-keyword">lambda</span> filed:[move_row_left(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> filed]<br>    moves[<span class="hljs-string">&#x27;Right&#x27;</span>] = <span class="hljs-keyword">lambda</span> filed:invert(moves[<span class="hljs-string">&#x27;Left&#x27;</span>](invert(filed)))<br>    moves[<span class="hljs-string">&#x27;Up&#x27;</span>] = <span class="hljs-keyword">lambda</span> field:transpose(moves[<span class="hljs-string">&#x27;Left&#x27;</span>](transpose(field)))<br>    moves[<span class="hljs-string">&#x27;Down&#x27;</span>] = <span class="hljs-keyword">lambda</span> field:transpose((moves[<span class="hljs-string">&#x27;Right&#x27;</span>](transpose(field))))<br><br>    <span class="hljs-keyword">if</span> direction <span class="hljs-keyword">in</span> moves:<br>        <span class="hljs-keyword">if</span> self.move_is_possible(direction):<br>            self.field = moves[direction](self.field)<br>            <span class="hljs-comment">#生成一个随机2或者4</span><br>            self.spawn()<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>判断输赢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断输赢</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_win</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(<span class="hljs-built_in">any</span>(i&gt;=self.win_value <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.field)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_gameover</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(self.move_is_possible(move) <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> actions)<br></code></pre></td></tr></table></figure><p>绘制游戏界面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">self, screen</span>):<br>     help_string1 = <span class="hljs-string">&#x27;(W)Up (S)Down (A)Left (D)Right&#x27;</span><br>     help_string2 = <span class="hljs-string">&#x27;     (R)Restart (Q)Exit&#x27;</span><br>     gameover_string = <span class="hljs-string">&#x27;           GAME OVER&#x27;</span><br>     win_string = <span class="hljs-string">&#x27;          YOU WIN!&#x27;</span><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">cast</span>(<span class="hljs-params">string</span>):<br>         screen.addstr(string+<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>     <span class="hljs-comment"># 绘制水平分割线</span><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_hor_separator</span>():<br>         line = <span class="hljs-string">&#x27;+&#x27;</span>+(<span class="hljs-string">&#x27;+------&#x27;</span> * self.width + <span class="hljs-string">&#x27;+&#x27;</span>)[<span class="hljs-number">1</span>:]<br>         <span class="hljs-comment"># defaultdict传入为函数时，可以实现value为某个常量，使用lambda可以使得代码更为简洁</span><br>         separator = defaultdict(<span class="hljs-keyword">lambda</span>: line)<br>         <span class="hljs-comment">#hasattr(object, name) 判断object对象中是否存在name属性</span><br>         <span class="hljs-comment"># python中的函数是一种对象，它有属于对象的属性。函数还可以自定义自己的属性。注意，属性是和对象相关的，和作用域无关。</span><br>         <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(draw_hor_separator,<span class="hljs-string">&#x27;counter&#x27;</span>):<br>             draw_hor_separator.counter=<span class="hljs-number">0</span><br>         cast(separator[draw_hor_separator.counter])<br>         draw_hor_separator.counter+=<span class="hljs-number">1</span><br><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_row</span>(<span class="hljs-params">row</span>):<br>         cast(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-string">&#x27;|&#123;: ^5&#125; &#x27;</span>.<span class="hljs-built_in">format</span>(num) <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;|      &#x27;</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> row) + <span class="hljs-string">&#x27;|&#x27;</span>)<br><br>     screen.clear()<br><br>     cast(<span class="hljs-string">&#x27;SCORE: &#x27;</span> + <span class="hljs-built_in">str</span>(self.score))<br>     <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> != self.highscore:<br>         cast(<span class="hljs-string">&#x27;HGHSCORE: &#x27;</span> + <span class="hljs-built_in">str</span>(self.highscore))<br><br>     <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.field:<br>         draw_hor_separator()<br>         draw_row(row)<br>     draw_hor_separator()<br><br>     <span class="hljs-keyword">if</span> self.is_win():<br>         cast(win_string)<br>     <span class="hljs-keyword">else</span>:<br>         <span class="hljs-keyword">if</span> self.is_gameover():<br>             cast(gameover_string)<br>         <span class="hljs-keyword">else</span>:<br>             cast(help_string1)<br>     cast(help_string2)<br><br></code></pre></td></tr></table></figure><p>随机生成一个 2 或者 4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">self</span>):<br>    new_element = <span class="hljs-number">4</span> <span class="hljs-keyword">if</span> randrange(<span class="hljs-number">100</span>) &gt; <span class="hljs-number">89</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span><br>    (i, j) = choice([(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.width) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.height) <span class="hljs-keyword">if</span> self.field[i][j] == <span class="hljs-number">0</span>])<br>    self.field[i][j] = new_element<br></code></pre></td></tr></table></figure><p>判断能否移动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断是否能移动</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">move_is_possible</span>(<span class="hljs-params">self, dictions</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">row_is_left_moveable</span>(<span class="hljs-params">row</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">i</span>):<br>                <span class="hljs-comment"># 当左边有空位（0），右边有数字时，可以向左移动</span><br>                <span class="hljs-keyword">if</span> row[i] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> row[i + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-comment"># 当左边有一个数和右边的数相等时，可以向左合并</span><br>                <span class="hljs-keyword">if</span> row[i] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> row[i + <span class="hljs-number">1</span>] == row[i]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(change(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(row) - <span class="hljs-number">1</span>))<br><br>        check = &#123;&#125;<br>        <span class="hljs-comment"># 判断矩阵每一行有没有可以左移动的元素</span><br>        check[<span class="hljs-string">&#x27;Left&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: <span class="hljs-built_in">any</span>(row_is_left_moveable(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> field)<br>        <span class="hljs-comment"># 判断矩阵每一行有没有可以右移动的元素。这里只用进行判断，所以矩阵变换之后，不用再变换复原</span><br>        check[<span class="hljs-string">&#x27;Right&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: check[<span class="hljs-string">&#x27;Left&#x27;</span>](invert(field))<br><br>        check[<span class="hljs-string">&#x27;Up&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: check[<span class="hljs-string">&#x27;Left&#x27;</span>](transpose(field))<br><br>        check[<span class="hljs-string">&#x27;Down&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: check[<span class="hljs-string">&#x27;Right&#x27;</span>](transpose(field))<br><br>        <span class="hljs-keyword">if</span> dictions <span class="hljs-keyword">in</span> check:<br>            <span class="hljs-keyword">return</span> check[dictions](self.field)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br></code></pre></td></tr></table></figure><p>附录：</p><ul><li>附所有源代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!user/bin/env/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randrange, choice<br><span class="hljs-keyword">import</span> curses<br><br>actions = [<span class="hljs-string">&#x27;Up&#x27;</span>, <span class="hljs-string">&#x27;Left&#x27;</span>, <span class="hljs-string">&#x27;Down&#x27;</span>, <span class="hljs-string">&#x27;Right&#x27;</span>, <span class="hljs-string">&#x27;Restart&#x27;</span>, <span class="hljs-string">&#x27;Exit&#x27;</span>]<br><span class="hljs-comment"># 分别用 W（上），A（左），S（下），D（右），R（重置），Q（退出），进行输入来操作游戏，这里考虑到大写锁定键锁定的情况：</span><br>letter_codes = [<span class="hljs-built_in">ord</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;WASDRQwasdrq&#x27;</span>]<br>actions_dict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(letter_codes, actions*<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_action</span>(<span class="hljs-params">keyboard</span>):<br>    char = <span class="hljs-string">&#x27;N&#x27;</span><br>    <span class="hljs-comment">#阻塞＋循环，直到获得用户有效输入才返回对应行为：</span><br>    <span class="hljs-keyword">while</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> actions_dict:<br>        char = keyboard.getch()<br>    <span class="hljs-keyword">return</span> actions_dict[char]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">transpose</span>(<span class="hljs-params">field</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">list</span>(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*field)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">invert</span>(<span class="hljs-params">field</span>):<br>    <span class="hljs-keyword">return</span> [row[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> field]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameField</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,height=<span class="hljs-number">4</span>, width=<span class="hljs-number">4</span>, win=<span class="hljs-number">2048</span></span>):<br>        self.height = height<br>        self.width = width<br>        self.win_value =win <span class="hljs-comment">#过关分数</span><br>        self.score = <span class="hljs-number">0</span>      <span class="hljs-comment">#当前分数</span><br>        self.highscore =<span class="hljs-number">0</span>   <span class="hljs-comment">#最高分数</span><br>        self.reset()        <span class="hljs-comment">#棋盘重置</span><br><br>    <span class="hljs-comment">#重置棋盘</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.score&gt;self.highscore:<br>            self.highscore = self.score<br>        self.score = <span class="hljs-number">0</span><br>        self.field = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.width)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.height)]<br>        self.spawn()<br>        self.spawn()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">self,direction</span>):<br>        <span class="hljs-comment">#一行相左合并</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">move_row_left</span>(<span class="hljs-params">row</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">tighten</span>(<span class="hljs-params">row</span>): <span class="hljs-comment">#把零散的非零单元挤到一块</span><br>                new_row = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> row <span class="hljs-keyword">if</span> i!=<span class="hljs-number">0</span>]<br>                new_row+=[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(row)-<span class="hljs-built_in">len</span>(new_row))]<br>                <span class="hljs-keyword">return</span> new_row<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">row</span>):<br>                pair=<span class="hljs-literal">False</span><br>                new_row=[]<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(row)):<br>                    <span class="hljs-keyword">if</span> pair:<br>                        <span class="hljs-comment"># 合并后，加入乘 2 后的元素在 0 元素后面</span><br>                        new_row.append(<span class="hljs-number">2</span>*row[i])<br>                        self.score+=<span class="hljs-number">2</span>*row[i]<br>                        pair=<span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">len</span>(row) <span class="hljs-keyword">and</span> row[i]==row[i+<span class="hljs-number">1</span>]:<br>                            pair=<span class="hljs-literal">True</span><br>                            <span class="hljs-comment"># 不能合并，新列表中加入该元素</span><br>                            new_row.append(<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">else</span>:<br>                            new_row.append(row[i])<br>                <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(new_row)==<span class="hljs-built_in">len</span>(row)<br>                <span class="hljs-keyword">return</span> new_row<br>            <span class="hljs-comment"># 先挤到一块再合并再挤到一块</span><br>            <span class="hljs-keyword">return</span> tighten(merge(tighten(row)))<br><br>        <span class="hljs-comment"># 创建 moves 字典，把不同的棋盘操作作为不同的 key，对应不同的方法函数</span><br>        moves=&#123;&#125;<br>        moves[<span class="hljs-string">&#x27;Left&#x27;</span>] = <span class="hljs-keyword">lambda</span> filed:[move_row_left(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> filed]<br>        moves[<span class="hljs-string">&#x27;Right&#x27;</span>] = <span class="hljs-keyword">lambda</span> filed:invert(moves[<span class="hljs-string">&#x27;Left&#x27;</span>](invert(filed)))<br>        moves[<span class="hljs-string">&#x27;Up&#x27;</span>] = <span class="hljs-keyword">lambda</span> field:transpose(moves[<span class="hljs-string">&#x27;Left&#x27;</span>](transpose(field)))<br>        moves[<span class="hljs-string">&#x27;Down&#x27;</span>] = <span class="hljs-keyword">lambda</span> field:transpose((moves[<span class="hljs-string">&#x27;Right&#x27;</span>](transpose(field))))<br><br>        <span class="hljs-keyword">if</span> direction <span class="hljs-keyword">in</span> moves:<br>            <span class="hljs-keyword">if</span> self.move_is_possible(direction):<br>                self.field = moves[direction](self.field)<br>                <span class="hljs-comment">#生成一个随机2或者4</span><br>                self.spawn()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 判断输赢</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_win</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(<span class="hljs-built_in">any</span>(i&gt;=self.win_value <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.field)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_gameover</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">any</span>(self.move_is_possible(move) <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> actions)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">self, screen</span>):<br>        help_string1 = <span class="hljs-string">&#x27;(W)Up (S)Down (A)Left (D)Right&#x27;</span><br>        help_string2 = <span class="hljs-string">&#x27;     (R)Restart (Q)Exit&#x27;</span><br>        gameover_string = <span class="hljs-string">&#x27;           GAME OVER&#x27;</span><br>        win_string = <span class="hljs-string">&#x27;          YOU WIN!&#x27;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">cast</span>(<span class="hljs-params">string</span>):<br>            screen.addstr(string+<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>        <span class="hljs-comment"># 绘制水平分割线</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_hor_separator</span>():<br>            line = <span class="hljs-string">&#x27;+&#x27;</span>+(<span class="hljs-string">&#x27;+------&#x27;</span> * self.width + <span class="hljs-string">&#x27;+&#x27;</span>)[<span class="hljs-number">1</span>:]<br>            <span class="hljs-comment"># defaultdict传入为函数时，可以实现value为某个常量，使用lambda可以使得代码更为简洁</span><br>            separator = defaultdict(<span class="hljs-keyword">lambda</span>: line)<br>            <span class="hljs-comment">#hasattr(object, name) 判断object对象中是否存在name属性</span><br>            <span class="hljs-comment"># python中的函数是一种对象，它有属于对象的属性。函数还可以自定义自己的属性。注意，属性是和对象相关的，和作用域无关。</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(draw_hor_separator,<span class="hljs-string">&#x27;counter&#x27;</span>):<br>                draw_hor_separator.counter=<span class="hljs-number">0</span><br>            cast(separator[draw_hor_separator.counter])<br>            draw_hor_separator.counter+=<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_row</span>(<span class="hljs-params">row</span>):<br>            cast(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-string">&#x27;|&#123;: ^5&#125; &#x27;</span>.<span class="hljs-built_in">format</span>(num) <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;|      &#x27;</span> <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> row) + <span class="hljs-string">&#x27;|&#x27;</span>)<br><br>        screen.clear()<br><br>        cast(<span class="hljs-string">&#x27;SCORE: &#x27;</span> + <span class="hljs-built_in">str</span>(self.score))<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> != self.highscore:<br>            cast(<span class="hljs-string">&#x27;HGHSCORE: &#x27;</span> + <span class="hljs-built_in">str</span>(self.highscore))<br><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.field:<br>            draw_hor_separator()<br>            draw_row(row)<br>        draw_hor_separator()<br><br>        <span class="hljs-keyword">if</span> self.is_win():<br>            cast(win_string)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> self.is_gameover():<br>                cast(gameover_string)<br>            <span class="hljs-keyword">else</span>:<br>                cast(help_string1)<br>        cast(help_string2)<br><br>    <span class="hljs-comment"># 随机生成一个 2 或者 4</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">self</span>):<br>        new_element = <span class="hljs-number">4</span> <span class="hljs-keyword">if</span> randrange(<span class="hljs-number">100</span>) &gt; <span class="hljs-number">89</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span><br>        (i, j) = choice([(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.width) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.height) <span class="hljs-keyword">if</span> self.field[i][j] == <span class="hljs-number">0</span>])<br>        self.field[i][j] = new_element<br><br>    <span class="hljs-comment"># 判断是否能移动</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">move_is_possible</span>(<span class="hljs-params">self, dictions</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">row_is_left_moveable</span>(<span class="hljs-params">row</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">i</span>):<br>                <span class="hljs-comment"># 当左边有空位（0），右边有数字时，可以向左移动</span><br>                <span class="hljs-keyword">if</span> row[i] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> row[i + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-comment"># 当左边有一个数和右边的数相等时，可以向左合并</span><br>                <span class="hljs-keyword">if</span> row[i] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> row[i + <span class="hljs-number">1</span>] == row[i]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(change(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(row) - <span class="hljs-number">1</span>))<br><br>        check = &#123;&#125;<br>        <span class="hljs-comment"># 判断矩阵每一行有没有可以左移动的元素</span><br>        check[<span class="hljs-string">&#x27;Left&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: <span class="hljs-built_in">any</span>(row_is_left_moveable(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> field)<br>        <span class="hljs-comment"># 判断矩阵每一行有没有可以右移动的元素。这里只用进行判断，所以矩阵变换之后，不用再变换复原</span><br>        check[<span class="hljs-string">&#x27;Right&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: check[<span class="hljs-string">&#x27;Left&#x27;</span>](invert(field))<br><br>        check[<span class="hljs-string">&#x27;Up&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: check[<span class="hljs-string">&#x27;Left&#x27;</span>](transpose(field))<br><br>        check[<span class="hljs-string">&#x27;Down&#x27;</span>] = <span class="hljs-keyword">lambda</span> field: check[<span class="hljs-string">&#x27;Right&#x27;</span>](transpose(field))<br><br>        <span class="hljs-keyword">if</span> dictions <span class="hljs-keyword">in</span> check:<br>            <span class="hljs-keyword">return</span> check[dictions](self.field)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">stdscr</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>        <span class="hljs-comment"># 重置游戏棋盘</span><br>        game_field.reset()<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Game&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">game</span>():<br>        <span class="hljs-comment"># 画出 GameOver 或者 Win 的界面</span><br>        game_field.draw(stdscr)<br>        <span class="hljs-comment"># 读取用户输入得到action，判断是重启游戏还是结束游戏</span><br>        action = get_user_action(stdscr)<br><br>        <span class="hljs-keyword">if</span> action ==<span class="hljs-string">&#x27;Restart&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Init&#x27;</span><br>        <span class="hljs-keyword">if</span> action==<span class="hljs-string">&#x27;Exit&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Exit&#x27;</span><br>        <span class="hljs-keyword">if</span> game_field.move(action):<br>            <span class="hljs-keyword">if</span> game_field.is_win():<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Win&#x27;</span><br>            <span class="hljs-keyword">if</span> game_field.is_gameover():<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Gameover&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Game&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">not_game</span>(<span class="hljs-params">state</span>):<br>        <span class="hljs-comment"># 画出 GameOver 或者 Win 的界面</span><br>        game_field.draw(stdscr)<br>        <span class="hljs-comment"># 读取用户输入得到action，判断是重启游戏还是结束游戏</span><br>        action = get_user_action(stdscr)<br>        responses = defaultdict(<span class="hljs-keyword">lambda</span>:state)<br>        responses[<span class="hljs-string">&#x27;Restart&#x27;</span>], responses[<span class="hljs-string">&#x27;Exit&#x27;</span>] = <span class="hljs-string">&#x27;Init&#x27;</span>,<span class="hljs-string">&#x27;Exit&#x27;</span><br>        <span class="hljs-keyword">return</span> responses[action]<br><br><span class="hljs-comment"># 游戏盘的四种状态</span><br>    state_actions=&#123;<br>        <span class="hljs-string">&#x27;Init&#x27;</span>:init,<br>        <span class="hljs-string">&#x27;Win&#x27;</span>:<span class="hljs-keyword">lambda</span>:not_game(<span class="hljs-string">&#x27;Win&#x27;</span>),<br>        <span class="hljs-string">&#x27;Gameover&#x27;</span>:<span class="hljs-keyword">lambda</span>:not_game(<span class="hljs-string">&#x27;Gameover&#x27;</span>),<br>        <span class="hljs-string">&#x27;Game&#x27;</span>:game<br>    &#125;<br><br>    curses.use_default_colors()<br><br>    game_field = GameField(win=<span class="hljs-number">2048</span>)<br>    state = <span class="hljs-string">&#x27;Init&#x27;</span><br>    <span class="hljs-keyword">while</span> state!=<span class="hljs-string">&#x27;Exit&#x27;</span>:<br>        state = state_actions[state]()<br><br>curses.wrapper(main)<br></code></pre></td></tr></table></figure><ul><li>curses包的安装：<br>问题：windows系统如果直接用pip install下载会报错<br>解决办法：<br>去网址下载<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#curses">http://www.lfd.uci.edu/~gohlke/pythonlibs/#curses</a>(如果点击下载出现file not find，请fq下载)</li></ul><p>在下载目录运行如下命令：<br>pip install –upgrade curses-2.2+utf8-cp36-cp36m-win_amd64.whl</p><ul><li>可视化游戏网址：<a href="https://play2048.co/">https://play2048.co/</a></li></ul><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参加市北-GMIS 2019的感悟和总结.md</title>
    <link href="/2019/07/20/%E5%8F%82%E5%8A%A0%E5%B8%82%E5%8C%97-GMIS%202019%E7%9A%84%E6%84%9F%E6%82%9F%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2019/07/20/%E5%8F%82%E5%8A%A0%E5%B8%82%E5%8C%97-GMIS%202019%E7%9A%84%E6%84%9F%E6%82%9F%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>市北-GMIS-2019全球数据智能峰会</strong>，由机器之心主办，上海市市北高新技术服务业园区承办。 </p><p> 大会以【拥抱数智经济，赋能产业生态】为主题，共进行24场主题演讲、2个主论坛、2个圆桌论坛、4个session、1场AI画展，举行了为期2天的行业峰会。不仅带来联邦学习、认知智能、AutoML等前瞻技术，同时关注技术的落地工程运用。</p><p><strong>1day AM：主论坛-Data That Empowers</strong><br>[外链图片转存失败(img-BZe2nmqa-1563797092570)(<a href="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/hcNHN.1Ba57CNGmcrIvPH*7obf64Bf2lB5dkBTgDCHc!/b/dL4AAAAAAAAA&amp;bo=*gc4BAAAAAARF.U!&amp;rf=viewer_4&amp;t=5)%5D">http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/hcNHN.1Ba57CNGmcrIvPH*7obf64Bf2lB5dkBTgDCHc!/b/dL4AAAAAAAAA&amp;bo=*gc4BAAAAAARF.U!&amp;rf=viewer_4&amp;t=5)]</a></p><p><strong>1day PM： 2个session</strong></p><ul><li>Session1:前沿研究与技术趋势</li><li>Session2:数据智能落地项目与发展启示</li></ul><p>[外链图片转存失败(img-2Me63GjJ-1563797125923)(<a href="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/8mK4OkX..1hzROHhRLQEQd4LWkQqSJIy.dW9vcjIlmU!/b/dFIBAAAAAAAA&amp;bo=cwY4BAAAAAARF2k!&amp;rf=viewer_4&amp;t=5)%5D">http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/8mK4OkX..1hzROHhRLQEQd4LWkQqSJIy.dW9vcjIlmU!/b/dFIBAAAAAAAA&amp;bo=cwY4BAAAAAARF2k!&amp;rf=viewer_4&amp;t=5)]</a></p><p><strong>2day AM：主论坛-Data That Empowers</strong></p><p><strong>2day PM： 2个session</strong></p><ul><li>Session1：数据思维与工程实践</li><li>Session2：智能应用与产业生态</li></ul><hr><h2 id="正文：参加峰会的笔记"><a href="#正文：参加峰会的笔记" class="headerlink" title="正文：参加峰会的笔记"></a>正文：参加峰会的笔记</h2><h2 id="【POWER-AI】"><a href="#【POWER-AI】" class="headerlink" title="【POWER AI】"></a>【POWER AI】</h2><p>  <em><strong>[空间信息技术及在大数据中的应用]（中科院院士王建宇分享）</strong></em></p><p>现在的空间信息技术</p><ul><li>王建宇院士对曾经的报道称美国的卫星的分辨率可以达到将地面报纸的标题看清的新闻进行了辟谣。</li><li>虽然不能看清报纸，但是全球顶尖卫星可以做到0.1m的分辨率，也就是说可以清晰的识别车辆行人、建筑。人的运动轨迹也能一览无遗。</li></ul><p> 空间信息技术可以做以下用途：</p><ul><li>卫星监控的图像可以用来分析人口密度，从而反映出城市发展的模式</li><li>对军事打击的评估</li><li>分析高光谱、叶绿素、蛋白氮等的含量预测农作物的产量</li><li>农场主可以足不出户的观察农作物的涨势，并且可以及时发现病虫害</li></ul><p>展望：技术转换成落地应用还需一段时间</p><hr><h2 id="【AI-for-Smarter-Enterprises】（Hans-Uszkoreit-欧洲科学院院士、德国人工智能研究中心-DFKI-科学董事-）"><a href="#【AI-for-Smarter-Enterprises】（Hans-Uszkoreit-欧洲科学院院士、德国人工智能研究中心-DFKI-科学董事-）" class="headerlink" title="【AI for Smarter Enterprises】（Hans Uszkoreit 欧洲科学院院士、德国人工智能研究中心(DFKI)科学董事 ）"></a>【AI for Smarter Enterprises】（Hans Uszkoreit 欧洲科学院院士、德国人工智能研究中心(DFKI)科学董事 ）</h2><ul><li><p><strong>两种不同类型的学习系统</strong><br> Systems based on knowledge 学习知识<br> Systems based on behaviour   学习行为</p></li><li><p><strong>两种不同类型的学习系统的区别</strong></p></li></ul><p> [谷歌的机器学习翻译系统并不能理解你的语句，但却能够完成翻译工作，这是因为它的算法从大量数据中学习人类的翻译方法，从而让阅读的人类可以理解翻译后的内容。」</p><p>[现在的自动驾驶系统,它并不了解交通法规，但能够通过多次的训练，让它获得自动驾驶的能力]</p><p>不管是谷歌翻译器还是自动驾驶系统，它们都不是了解了规则，他们学习的是行为，而非知识。</p><p><strong>「想要实现超越人类的 AI 能力，我们要在基于知识、基于规则和机器学习系统中找到交叉的部分，真正的超级 AI 是超越人类的，但仍然不是人类形式的智能——它不会是伊隆·马斯克所说的超级智能。」</strong></p><p><strong>AI研究会经过4个阶段：</strong></p><p><em><strong>第一是  启发式系统 Heuristic Systems<br>第二是  基于知识的系统 Knowledge-Based Systems<br>第三是  学习系统 Learning Systems<br>第四是 认知系统 Cognitive Systems</strong></em><br>[外链图片转存失败(img-wEVoZ71H-1565490762322)(<a href="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/tHS5INhlTE.E*EA1lAa7b24LfO.SPqJEvDBULjGGws8!/b/dEgBAAAAAAAA&amp;bo=PAY4BAAAAAARFyY!&amp;rf=viewer_4&amp;t=5)%5D">http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/tHS5INhlTE.E*EA1lAa7b24LfO.SPqJEvDBULjGGws8!/b/dEgBAAAAAAAA&amp;bo=PAY4BAAAAAARFyY!&amp;rf=viewer_4&amp;t=5)]</a></p><p>[目前我们正处于第三阶段中，我们开发了例如神经网络、深度学习这样的学习系统，现阶段面临的挑战就是如何把这些就是整合起来建立认知系统。]</p><p>「商业决策需要思考大量不同来源的内容。世界是动态变化的，我们不能简单地使用过去知识训练过的算法来对现在的问题进行决策，总会有意外发生，所以这里需要人类把关。」</p><hr><h2 id="【不要让机器假装智能】（李航-字节跳动科技有限公司人工智能实验室总监、IEEE会士、ACM杰出科学家"><a href="#【不要让机器假装智能】（李航-字节跳动科技有限公司人工智能实验室总监、IEEE会士、ACM杰出科学家" class="headerlink" title="【不要让机器假装智能】（李航 字节跳动科技有限公司人工智能实验室总监、IEEE会士、ACM杰出科学家)"></a>【不要让机器假装智能】（李航 字节跳动科技有限公司人工智能实验室总监、IEEE会士、ACM杰出科学家)</h2><p>这次峰会主要是去看李航老师和吴恩达老师的，想必大家都知道李航老师的《统计学习方法》、吴恩达老师的《机器学习》和《深度学习》课程。在业内基本大家都看过的课程和书籍。</p><p><strong>对话机器人领域</strong><br>李航老师说在对话机器人领域，实现开放式对话仍然面临巨大挑战，现在对话机器人还只能做到一问一答式的对话。</p><p>对话是两个人需要交流感情，交换信息，在真实的对话场景中，聊天不断被终止，设置、恢复。要做到真正的像人一样去定义任务、产生任务、完成任务，这涉及到人工智能的方方面面，是非常具有挑战性的问题。</p><p>结合在字节跳动与华为对话系统的开发经验，李航老师总结了设计对话系统的四条规则：</p><ul><li>1.要能够在一个场景中自封闭，让用户不论怎么说，能够完成一件事情、一个功能。</li><li>2.机器不可能 100% 理解，失败的时候，一定要能比较自然地应对。</li><li>3.对话不仅仅是语言的问题，也包括情感和文化因素，需要加入社交因素让对话更富情感。</li><li>4.不要让系统装智能。</li></ul><p>李航老师还提到一句话那就是优雅的失败，虽然现阶段对话机器人还做不到那么智能，但有的时候机器的不智能并不是一种缺陷，还反而更显可爱。</p><hr><h2 id="【人工智能多模态的未来】-贾佳亚-香港中文大学终身教授、腾讯优图实验室杰出科学家"><a href="#【人工智能多模态的未来】-贾佳亚-香港中文大学终身教授、腾讯优图实验室杰出科学家" class="headerlink" title="【人工智能多模态的未来】(贾佳亚 香港中文大学终身教授、腾讯优图实验室杰出科学家)"></a>【人工智能多模态的未来】(贾佳亚 香港中文大学终身教授、腾讯优图实验室杰出科学家)</h2><p>当我们对机器人是说，请给我拿桌子上左边的那个瓶子。机器人要做哪些事情。<br>首先需要识别语音、识别图像、再需要3D建模、分析结构化信息。<br>对于人类来说非常简单的一个问题，对于机器人来说却是非常难完成的。AI 解决这个问题需要语言模型、三维建模、自动导航、图像分析等多种能力。</p><p>在多模态 AI 方面，腾讯正在开发一套手语翻译器。</p><hr><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python -笔记 -内部类&amp;日期格式</title>
    <link href="/2019/04/13/Python%20-%E7%AC%94%E8%AE%B0%20-%E5%86%85%E9%83%A8%E7%B1%BB&amp;%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F/"/>
    <url>/2019/04/13/Python%20-%E7%AC%94%E8%AE%B0%20-%E5%86%85%E9%83%A8%E7%B1%BB&amp;%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>本文适用对象：</strong></p><p>python初级打怪～</p><p>本文介绍两个python的小知识点，内部类和日期格式转换</p><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h3><p>内部类顾名思义就是类内部包含的类，就叫内部类</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>: <span class="hljs-comment">#外部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Door</span>: <span class="hljs-comment"># 内部类</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>            print(<span class="hljs-string">&quot;open door&quot;</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wheel</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>            print(<span class="hljs-string">&quot;car run&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    car = Car() <span class="hljs-comment">#实例化外部类</span><br>    backDoor = Car.Door()  <span class="hljs-comment"># 实例化内部类 第一种方法</span><br>    frontDoor = car.Door()  <span class="hljs-comment"># 因为car已经实例化外部类，再次实例化Car的内部类 第二种方法</span><br>    backDoor.open()<br>    frontDoor.open()<br></code></pre></td></tr></table></figure><p>以上代码列举了调用内部类的两种方法<br>第一种调用内部类的方法是：<br><strong>通过外部类直接调用，不实例化外部类。</strong><br>第二种调用内部类的方法是：<br><strong>通过外部类的实例化对象调用</strong></p><hr><h4 id="日期格式："><a href="#日期格式：" class="headerlink" title="日期格式："></a><strong>日期格式：</strong></h4><p>字符格式转换成日期格式</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">import datetime<br>datetime.datetime.strp<span class="hljs-meta">time</span>(<span class="hljs-string">&#x27;2019-04-13&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>＃<span class="hljs-keyword">output</span>：2019-04-1３ 00:00:00<br></code></pre></td></tr></table></figure><p>六天后的时间</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import datetime<br>now = datetime<span class="hljs-selector-class">.datetime</span><span class="hljs-selector-class">.strptime</span>(<span class="hljs-string">&#x27;2019-04-13&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>times = <span class="hljs-string">&#x27;2019-04-13&#x27;</span><br>endnow = now+datetime<span class="hljs-selector-class">.timedelta</span>(days=<span class="hljs-number">6</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(endnow)</span></span><br>＃output：<span class="hljs-number">2019</span>-<span class="hljs-number">04</span>-<span class="hljs-number">19</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>时间转换成字符串</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import datetime<br>now = datetime<span class="hljs-selector-class">.datetime</span><span class="hljs-selector-class">.strptime</span>(<span class="hljs-string">&#x27;2019-04-13&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>times = <span class="hljs-string">&#x27;2019-04-13&#x27;</span><br>endnow = now+datetime<span class="hljs-selector-class">.timedelta</span>(days=<span class="hljs-number">6</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(endnow.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)</span></span>)<br>＃output：<span class="hljs-number">2019</span>-<span class="hljs-number">04</span>-<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python -笔记 -单例模式(Singleton)实现</title>
    <link href="/2019/04/13/Python%20-%E7%AC%94%E8%AE%B0%20-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(Singleton)%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/04/13/Python%20-%E7%AC%94%E8%AE%B0%20-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(Singleton)%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>本文适用对象：</strong></p><p>python正在进阶的人儿~<br>高级 Python 语法，涉及装饰器</p><hr><p>  不管是编写类还是函数都是变量之间的传来传去，最简单粗暴的方式就是全局变量。确实在很多场景下用全局变量很方便。不过如果代码规模增大，并且有多个文件的时候，全局变量就会变得比较混乱。你可能不知道在哪个文件中定义了相同类型甚至重名的全局变量，造成悲剧。</p><p>这里介绍一种设计模式，<strong>单例模式</strong></p><h3 id="What"><a href="#What" class="headerlink" title="What"></a><strong>What</strong></h3><p><strong>单例模式是什么？</strong>单例是一种设计模式，应用该模式的类只会生成一个实例。</p><p>单例模式保证了在程序的不同位置都可以且仅可以取到同一个对象实例：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。因为单例是一个类，所以你也可以为其提供相应的操作方法，以便于对这个实例进行管理。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a><strong>Why</strong></h3><p><strong>那么为什么要用单例设计模式呢？</strong><br>举个例子来说，比如你开发一款游戏软件，游戏中需要有“场景管理器”这样一种东西，用来管理游戏场景的切换、资源载入、网络连接等等任务。这个管理器需要有多种方法和属性，在代码中很多地方会被调用，且被调用的必须是同一个管理器，否则既容易产生冲突，也会浪费资源。这种情况下，单例模式就是一个很好的实现方法。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a><strong>How</strong></h3><p>怎么实现单例设计模式？<br>下面提供３种实现方法：</p><ul><li>使用函数装饰器实现单例</li><li>使用类装饰器实现单例</li><li>使用 <strong>new</strong> 关键字实现单例</li></ul><h4 id="使用函数装饰器实现单例："><a href="#使用函数装饰器实现单例：" class="headerlink" title="使用函数装饰器实现单例："></a><strong>使用函数装饰器实现单例</strong>：</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">def singleton(cls):<br>    _instance = &#123;&#125;<br><br>    def inner():<br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:<br>            _instance[cls] = cls()<br>        <span class="hljs-keyword">return</span> _instance[cls]<br><br>    <span class="hljs-keyword">return</span> inner<br><br>@singleton<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Cla</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">pass</span><br><br><span class="hljs-symbol">cls1</span> = <span class="hljs-symbol">Cla</span>()<br><span class="hljs-symbol">cls2</span> = <span class="hljs-symbol">Cla</span>()<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">id</span>(<span class="hljs-symbol">cls1</span>) == <span class="hljs-symbol">id</span>(<span class="hljs-symbol">cls2</span>))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在 Python 中，id 关键字可用来查看对象在内存中的存放位置，这里 cls1 和 cls2 的 id 值相同，说明他们指向了同一个对象。</p><p>代码的设计思路是使用<strong>不可变的类地址</strong>作为键，其<strong>实例</strong>作为值。每次创造实例时，首先查看该类是否存在实例。存在的话直接返回该实例即可，否则新建一个实例并存放在字典中。</p><h4 id="使用类装饰器实现单例"><a href="#使用类装饰器实现单例" class="headerlink" title="使用类装饰器实现单例"></a><strong>使用类装饰器实现单例</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, cls</span>):<br>        self._cls = cls<br>        self._instance = &#123;&#125;<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> self._cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self._instance:<br>            self._instance[self._cls] = self._cls()<br>        <span class="hljs-keyword">return</span> self._instance[self._cls]<br><br><span class="hljs-meta">@Singleton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cla1</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>cls1 = Cla1()<br>cls2 = Cla1()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(cls1)==<span class="hljs-built_in">id</span>(cls2))<br></code></pre></td></tr></table></figure><p>使用 类装饰器实现单例的原理和 函数装饰器 实现的原理相似<br>－－－－－－－－－－－－－－－－－－－－－－<br><strong>补充：装饰器</strong><br>简单地说：他们是修改其他函数的功能的函数<br>他们有助于让我们的代码更简短，也更Pythonic（Python范儿）</p><p>首先在理解装饰器之前我们要先理解，<strong>从函数中返回函数</strong>，<strong>将函数作为参数传给另一个函数</strong>这两个概念。<br><strong>１.从函数中返回函数</strong><br>举个例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hi</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;yasoob&quot;</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>():<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;now you are in the greet() function&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">welcome</span>():<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;now you are in the welcome() function&quot;</span><br><br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;yasoob&quot;</span>:<br>        <span class="hljs-keyword">return</span> greet<br>    <span class="hljs-symbol">else:</span><br>        <span class="hljs-keyword">return</span> welcome<br><br>a = hi()<br>print(a)<br><br><span class="hljs-comment">#outputs: &lt;function hi.&lt;locals&gt;.greet at 0x000000B36FE96488&gt;</span><br><br><span class="hljs-comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span><br><span class="hljs-comment">#现在试试这个</span><br><span class="hljs-comment">#outputs: now you are in the greet() function</span><br><br></code></pre></td></tr></table></figure><p>再次看看这个代码。在 if&#x2F;else 语句中我们返回 greet 和 welcome，而不是 greet() 和 welcome()。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；<br>然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。<br>当我们写下 a &#x3D; hi()，hi() 会被执行，而由于 name 参数默认是 yasoob，所以函数 greet 被返回了。如果我们把语句改为 a &#x3D; hi(name &#x3D; “ali”)，那么 welcome 函数将被返回。我们还可以打印出 hi()()，这会输出 now you are in the greet() function。</p><p><strong>２.将函数作为参数传给另一个函数</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">hi</span>():</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">&#x27;Hello Big data industry!!!!!&#x27;</span>)</span><br><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">dosomethingBeforehi</span>(<span class="hljs-variable">func</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">&quot;I am echo!!!!!!&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">func</span>()</span><br><br><span class="hljs-function"><span class="hljs-title">dosomethingBeforehi</span>(<span class="hljs-variable">hi</span>)</span><br></code></pre></td></tr></table></figure><p>现在你已经具备所有必需知识，来进一步学习装饰器真正是什么了。装饰器让你在一个函数的前后去执行代码。<br><strong>你的第一个装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a_new_decorator</span>(<span class="hljs-params">a_func</span>):<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapTheFunction</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work before executing a_func()&quot;</span>)<br> <br>        a_func()<br> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work after executing a_func()&quot;</span>)<br> <br>    <span class="hljs-keyword">return</span> wrapTheFunction<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a_function_requiring_decoration</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)<br><br>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)<br><span class="hljs-comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span><br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs:I am doing some boring work before executing a_func()</span><br><span class="hljs-comment">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="hljs-comment">#        I am doing some boring work after executing a_func()</span><br></code></pre></td></tr></table></figure><p>现在你也许疑惑，我们在代码里并没有使用 @ 符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用 @ 来运行之前的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a_new_decorator</span>(<span class="hljs-params">a_func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapTheFunction</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work before executing a_func()&quot;</span>)<br><br>        a_func()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work after executing a_func()&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> wrapTheFunction<br><span class="hljs-meta">@a_new_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a_function_requiring_decoration</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am the function which needs some decoration to &quot;</span><br>          <span class="hljs-string">&quot;remove my foul smell&quot;</span>)<br><br>a_function_requiring_decoration()<br><span class="hljs-comment"># outputs: I am doing some boring work before executing a_func()</span><br><span class="hljs-comment">#         I am the function which needs some decoration to remove my foul smell</span><br><span class="hljs-comment">#         I am doing some boring work after executing a_func()</span><br></code></pre></td></tr></table></figure><p>蓝本规范:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator_name</span>(<span class="hljs-params">f</span>):<br><span class="hljs-meta">    @wraps(<span class="hljs-params">f</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorated</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> can_run:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Function will not run&quot;</span><br>        <span class="hljs-keyword">return</span> f(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> decorated<br> <br><span class="hljs-meta">@decorator_name</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">return</span>(<span class="hljs-string">&quot;Function is running&quot;</span>)<br> <br>can_run = <span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(func())<br><span class="hljs-comment"># Output: Function is running</span><br> <br>can_run = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(func())<br><span class="hljs-comment"># Output: Function will not run</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性</p><p>－－－－－－－－－－－－－－－－－－－－－－</p><h4 id="使用-new-关键字实现单例"><a href="#使用-new-关键字实现单例" class="headerlink" title="使用 new 关键字实现单例"></a><strong>使用 <strong>new</strong> 关键字实现单例</strong></h4><p>在说这个实现之前，首先我们需要知道Python 中一个类和一个实例是通过哪些方法以怎样的顺序被创造的。</p><p>简单来说，<strong>元类(metaclass)</strong> 可以通过方法 <strong>metaclass</strong> 创造了类(class)，而**类(class)**通过方法 <strong>new</strong> 创造了实例(instance)。</p><p>元类可以理解成类的爸爸，在python世界，拥有一个永恒的道，那就是“type”。type就是道。如此广袤无垠的python生态圈，都是由type产生出来的。在这里有一句很太极生两仪，两仪生四象，四象生八卦的话帮助理解python生态圈～</p><p><strong>道生一，一生二，二生三，三生万物。</strong><br>－道 即是 type<br>－一 即是 metaclass(元类，或者叫类生成器)<br>－二 即是 class(类，或者叫实例生成器)<br>－三 即是 instance(实例)<br>－万物 即是 实例的各种属性与方法，我们平常使用python时，调用的就是它们。</p><p>在单例模式应用中，在创造类的过程中或者创造实例的过程中稍加控制达到最后产生的实例都是一个对象的目的。</p><p>使用 <strong>new</strong> 方法在创造实例时进行干预，达到实现单例模式的目的</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">class</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-variable"><span class="hljs-class">object</span></span>):</span><br><span class="hljs-function">    <span class="hljs-variable">_instance</span> = <span class="hljs-variable">None</span></span><br><span class="hljs-function">    <span class="hljs-variable">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-variable">cls</span>):</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">cls._instance</span> <span class="hljs-variable">is</span> <span class="hljs-variable">None</span>:</span><br><span class="hljs-function">            <span class="hljs-variable">cls._instance</span> = <span class="hljs-variable"><span class="hljs-class">object</span>.__new__</span>(<span class="hljs-variable">cls</span>)</span><br>        <span class="hljs-variable">return</span> <span class="hljs-variable">cls._instance</span><br>    <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">__init__</span>(<span class="hljs-variable">self</span>):</span><br><span class="hljs-function">        <span class="hljs-variable">pass</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">single</span> = <span class="hljs-title">Singleton</span>()</span><br><span class="hljs-variable">single2</span> = <span class="hljs-function"><span class="hljs-title">Singleton</span>()</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">id</span>(<span class="hljs-variable">single</span>)==<span class="hljs-title">id</span>(<span class="hljs-variable">single2</span>))</span><br></code></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><p>１.什么是单例模式？<br>单例是一种设计模式，应用该模式的类只会生成一个实例。<br>２.为什么要用单例模式？<br>举例：一款游戏软件只能有一个控制面板<br>３.怎么实现单例模式？<br>　函数装饰器实现单例<br>　类装饰器实现单例<br>　<strong>new</strong> 关键字实现单例</p><hr><p>参考：<br><a href="https://blog.csdn.net/qq_40523737/article/details/81107089">Python单例模式(Singleton)的N种实现</a><br><a href="http://python.jobbole.com/88795/">两句话掌握 Python 最难知识点——元类</a><br><a href="http://www.runoob.com/w3cnote/python-func-decorators.html">Python 函数装饰器</a></p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning-笔记 -XGBoost教程</title>
    <link href="/2019/03/31/Machine-Learning-%E7%AC%94%E8%AE%B0-XGBoost%E6%95%99%E7%A8%8B/"/>
    <url>/2019/03/31/Machine-Learning-%E7%AC%94%E8%AE%B0-XGBoost%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="【1】前言"><a href="#【1】前言" class="headerlink" title="【1】前言"></a>【1】前言</h3><ul><li>XGBoost, 全名(eXtreme Gradient Boosting)，Kaggle大杀器，在数据挖掘比赛上，Everybody knows it！！！</li><li>XGBoost作者：陈天奇（华盛顿大学）</li><li>XGBoost前身:XGBoost是Boosting算法的其中一种,是在GBDT的基础上进行改进，使之更强大，适用于更大范围.</li><li>算法发布时间在2014年</li></ul><hr><p>本文适用对象：<br>1.了解决策树族群：决策森林，Adaboost，GBDT等<br>2.了解bagging，boosting<br>3.准备在机器学习道路上越走越远的朋友<br>4.高能数学预警：泰勒公式、梯度下降法了解一下下，但是我是不愿意看这些深奥的数学公式。</p><p>链接：<br><a href="https://github.com/YUTING0907/Markdown_pic/blob/master/xgboost/BoostedTree.pdf">【天奇大神PPT传送门】</a></p><hr><h3 id="【2】算法原理简述"><a href="#【2】算法原理简述" class="headerlink" title="【2】算法原理简述"></a>【2】算法原理简述</h3><h5 id="1-Review-of-key-concepts-of-supervised-learning-监督学习到底在学什么"><a href="#1-Review-of-key-concepts-of-supervised-learning-监督学习到底在学什么" class="headerlink" title="(1)Review of key concepts of supervised learning | 监督学习到底在学什么"></a><strong>(1)Review of key concepts of supervised learning | 监督学习到底在学什么</strong></h5><ul><li>label(标签)<br>根据带有标签的数据学习出一套规则，给另外没有标签的测试集打上标签。</li><li>假设函数(Hypothesis)</li><li>目标函数（Objective Function）&#x3D; 损失函数(Cost Function) + 正则化（Regularization）</li><li>minimize Objective Function 最小化目标函数</li></ul><p>在监督学习算法学习的过程中，其实就是最小化目标函数的过程，找到让目标函数最小化的一组参数。其中：</p><ul><li>损失函数表示模型对训练数据的拟合程度，loss越小，代表模型预测的越准.</li><li>正则化项衡量模型的复杂度，regularization越小，代表模型模型的复杂度越低。</li><li>目标函数越小，代表模型越好</li></ul><h5 id="2-Regression-Tree-and-Ensemble-决策树在做什么"><a href="#2-Regression-Tree-and-Ensemble-决策树在做什么" class="headerlink" title="(2) Regression Tree and Ensemble | 决策树在做什么"></a><strong>(2) Regression Tree and Ensemble | 决策树在做什么</strong></h5><ul><li>一种模仿人类做决定的思维方式构建的算法</li><li>信息增益（Information Gain）：决定分裂节点，主要是为了减少损失loss</li><li>最大深度：会影响模型复杂度</li><li>树的剪枝：主要为了减少模型复杂度，而复杂度被‘树枝的数量’影响</li><li>回归树不止用于做回归，还可以做分类、排序等，主要依赖于目标函数的定义</li></ul><h5 id="3-Gradient-Boosting-How-do-we-learn"><a href="#3-Gradient-Boosting-How-do-we-learn" class="headerlink" title="(3) Gradient Boosting(How do we learn)"></a><strong>(3) Gradient Boosting(How do we learn)</strong></h5><p>XGBoost 与前身 GBDT比较优势在于</p><ul><li><strong>1.损失函数</strong>：GBDT是一阶，XGB是二阶泰勒展开</li><li><strong>2.XGB的损失函数可以自定义</strong></li><li><strong>3.XGB加入正则</strong>：XGB的目标函数进行了优化，有正则项，减少过拟合，控制模型复杂度</li><li><strong>4.XGB运行速度快</strong>：决策树的学习最耗时的一个步骤就是对特征的值进行排序,在进行节点的分裂的时候，需要计算每个特征的增益。Xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复使用这个结构，大大减小计算量。各个特征的增益计算就可以开多线程进行。</li><li><strong>5.内置交叉验证</strong>: 允许每轮boosting迭代中用交叉检验，以便获取最优 Boosting_n_round 迭代次数，可利用网格搜索grid search和交叉检验cross validation进行调参。</li><li><strong>6.预剪枝：</strong><br>GBDT：分裂到负损失，分裂停止;<br> XGB：一直分裂到指定的最大深度（max_depth），然后回过头剪枝。如某个点之后不再正值，去除这个分裂。优点是，当一个负损失(-2)后存在一个正损失(+10)，(-2+10&#x3D;8&gt;0)求和为正，保留这个分裂。</li></ul><h3 id="【3】参数说明"><a href="#【3】参数说明" class="headerlink" title="【3】参数说明"></a>【3】参数说明</h3><p>  XGBoost的参数多到让人发指，下面只列举部分常用参数，所有参数的官方说明文档，请点击<a href="https://xgboost.readthedocs.io/en/latest/parameter.html">官方文档说明</a><br>  XGBoost的参数可以归为3类：</p><h5 id="1-General-parameters-通用参数"><a href="#1-General-parameters-通用参数" class="headerlink" title="(1) General parameters 通用参数"></a><strong>(1) General parameters 通用参数</strong></h5><p>该参数控制在提升（boosting）过程中使用哪种booster，常用的booster有树模型（tree）和线性模型（linear model）</p><ul><li><strong>booster [default&#x3D;gbtree]</strong><br> 有两种模型可以选择gbtree和gblinear。gbtree使用基于树的模型进行提升计算，gblinear使用线性模型进行提升计算。缺省值为gbtree</li><li><strong>silent [default&#x3D;0]</strong><br>取0时表示打印出运行时信息，取1时表示以缄默方式运行，不打印运行时的信息。缺省值为0</li><li><strong>nthread</strong> [default to maximum number of threads available if not set] <ul><li>XGBoost运行时的线程数。缺省值是当前系统可以获得的最大线程数。</li><li>如果你希望以最大速度运行，建议不设置这个参数，模型将自动获得最大线程</li></ul></li><li><strong>num_pbuffer</strong> [set automatically by xgboost, no need to be set by user]<br>size of prediction buffer, normally set to number of training instances. The buffers are used to save the prediction results of last boosting step.</li><li><strong>num_feature</strong> [set automatically by xgboost, no need to be set by user]<br>  boosting过程中用到的特征维数，设置为特征个数。XGBoost 会自动设置，不需要手工设置</li></ul><h5 id="2-Booster-parameters参数"><a href="#2-Booster-parameters参数" class="headerlink" title="(2) Booster parameters参数"></a><strong>(2) Booster parameters参数</strong></h5><ul><li><strong>Parameters for Tree Booster</strong><br> - <strong>eta [default&#x3D;0.3]</strong><br>     - 为了防止过拟合，更新过程中用到的收缩步长。在每次提升计算之后，算法会直接获得新特征的权重。 eta通过缩减特征的权重使提升计算过程更加保守。<br> 通常最后设置eta为0.01~0.2<br>     - 取值范围为：[0,1]<ul><li><strong>gamma [default&#x3D;0]</strong><br>  - minimum loss reduction required to make a further partition on a leaf node of the tree. the larger, the more conservative the algorithm will be <strong>；</strong><br>  - range: [0,∞] <strong>；</strong><br> -  模型在默认情况下，对于一个节点的划分只有在其loss function 得到结果大于0的情况下才进行，而gamma 给定了所需的最低loss function的值 <strong>；</strong><br>  - gamma值使得算法更conservation，且其值依赖于loss function ，在模型中应该进行调参 <strong>。</strong></li><li><strong>max_depth [default&#x3D;6]</strong><br>  - 树的最大深度。缺省值为6 <strong>；</strong><br>  - 取值范围为：[1,∞] <strong>；</strong><br>  - 指树的最大深度 <strong>；</strong><br>  - 树的深度越大，则对数据的拟合程度越高（过拟合程度也越高）。即该参数也是控制过拟合 <strong>；</strong><br>   - 建议通过交叉验证（xgb.cv ) 进行调参 <strong>；</strong><br> 通常取值：3-10 <strong>；</strong></li><li><strong>min_child_weight [default&#x3D;1]</strong> <ul><li>孩子节点中最小的样本权重和。如果一个叶子节点的样本权重和小于min_child_weight则拆分过程结束。在现行回归模型中，这个参数是指建立每个模型所需要的最小样本数。该成熟越大算法越conservative。即调大这个参数能够控制过拟合 <strong>;</strong></li><li>取值范围为: [0,∞]</li></ul></li><li><strong>max_delta_step [default&#x3D;0]</strong> <ul><li>如果取值为0，那么意味着无限制。如果取为正数，则其使得xgboost更新过程更加保守。</li><li>取值范围为：[0,∞]</li><li>通常不需要设置这个值，但在使用logistics 回归时，若类别极度不平衡，则调整该参数可能有效果</li></ul></li><li>subsample [default&#x3D;1] <ul><li>用于训练模型的子样本占整个样本集合的比例。如果设置为0.5则意味着XGBoost将随机的从整个样本集合中抽取出50%的子样本建立树模型，这能够防止过拟合。</li><li>取值范围为：(0,1]</li></ul></li><li>colsample_bytree [default&#x3D;1]<br>  在建立树时对特征随机采样的比例。缺省值为1</li><li>colsample_bylevel[default&#x3D;1]<br>通常不使用，因为subsample和colsample_bytree已经可以起到相同的作用了</li></ul></li><li><strong>Parameters for Linear Booster and Tweedie Regression</strong><ul><li><strong>lambda [default&#x3D;0]</strong><br>L2 正则的惩罚系数<br>用于处理XGBoost的正则化部分。通常不使用，但可以用来降低过拟合</li><li><strong>alpha [default&#x3D;0]</strong><br>L1 正则的惩罚系数<br>当数据维度极高时可以使用，使得算法运行更快。</li><li><strong>lambda_bias</strong><br>在偏置上的L2正则。缺省值为0（在L1上没有偏置项的正则，因为L1时偏置不重要）</li></ul></li></ul><h5 id="3-Learning-Task-parameters"><a href="#3-Learning-Task-parameters" class="headerlink" title="(3) Learning Task parameters"></a><strong>(3) Learning Task parameters</strong></h5><ul><li><p><strong>objective [ default&#x3D;reg:linear ]</strong></p><ul><li>“reg:linear” –线性回归。</li><li>“reg:logistic” –逻辑回归。</li><li>“binary:logistic” –二分类的逻辑回归问题，输出为概率。</li><li>“binary:logitraw” –二分类的逻辑回归问题，输出的结果为wTx。</li><li>“count:poisson” –计数问题的poisson回归，输出结果为poisson分布。<br>在poisson回归中，max_delta_step的缺省值为0.7。(used to safeguard optimization)</li><li>“multi:softmax” –让XGBoost采用softmax目标函数处理多分类问题，同时需要设置参数num_class（类别个数）</li><li>“multi:softprob” –和softmax一样，但是输出的是ndata * nclass的向量，可以将该向量reshape成ndata行nclass列的矩阵。每行数据表示样本所属于每个类别的概率。</li><li>“rank:pairwise” –set XGBoost to do ranking task by minimizing the pairwise loss</li></ul></li><li><p><strong>base_score [ default&#x3D;0.5 ]</strong><br>the initial prediction score of all instances, global bias</p></li><li><p><strong>eval_metric [ default according to objective ]</strong><br>校验数据所需要的评价指标，不同的目标函数将会有缺省的评价指标（rmse for regression, and error for classification, mean average precision for ranking）</p><ul><li>“rmse”: root mean square error</li><li>“logloss”: negative log-likelihood</li><li>“error”: Binary classification error rate. It is calculated as #(wrong cases)&#x2F;#(all cases). For the predictions, the evaluation will regard the instances with prediction value larger than 0.5 as positive instances, and the others as negative instances.</li><li>“merror”: Multiclass classification error rate. It is calculated as #(wrong cases)&#x2F;#(all cases).</li><li>“mlogloss”: Multiclass logloss</li><li>“auc”: Area under the curve for ranking evaluation</li><li>“ndcg”:Normalized Discounted Cumulative Gain</li><li>“map”:Mean average precision</li></ul></li><li><p><strong>seed [ default&#x3D;0 ]</strong><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/aOr8BZHt*q6uyFpj2aEFCLoBAyu*6MYDD*iL8zMnsK8!/b/dDQBAAAAAAAA&bo=ZQEYAQAAAAADF08!&rf=viewer_4&t=5"></p></li></ul><hr><h3 id="【4】代码实现：python"><a href="#【4】代码实现：python" class="headerlink" title="【4】代码实现：python"></a>【4】代码实现：python</h3><h5 id="1-API接口说明"><a href="#1-API接口说明" class="headerlink" title="(1)API接口说明"></a><strong>(1)API接口说明</strong></h5><p>目前为止，xgb model 有两个接口</p><ul><li>import xgboost </li><li>from xgboost import XGBClassifier</li></ul><h5 id="2-XGBoost调参"><a href="#2-XGBoost调参" class="headerlink" title="(2) XGBoost调参"></a><strong>(2) XGBoost调参</strong></h5><ul><li>方法一：直接调参，调用 xgboost包 的 XGBClassifier()<br>可以对其参数进行手动修改，default参数如下<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/TLeI9lRonq7NAgF68hz5M8bI.ExHoesibyN39nBmL2w!/b/dL8AAAAAAAAA&bo=PQJ0AAAAAAADF3k!&rf=viewer_4&t=5"></li><li>方法二： 随机调参。<br>使用 xgb.cv，这里同样可以使用KFold()</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">from sklearn.cross_validation import KFold<br>kf = <span class="hljs-constructor">KFold(<span class="hljs-params">len</span>(<span class="hljs-params">train_feat</span>)</span>, n_folds=<span class="hljs-number">5</span>, shuffle=True, random_state=<span class="hljs-number">520</span>)<br><span class="hljs-keyword">for</span> i, (train_index, test_index) <span class="hljs-keyword">in</span> enumerate(kf):<br>        # 将测试集均分 取一份当测试集<br>xgb_train = xgb.<span class="hljs-constructor">DMatrix(<span class="hljs-params">train_feat</span>[<span class="hljs-params">predictors</span>].<span class="hljs-params">iloc</span>[<span class="hljs-params">train_index</span>], <span class="hljs-params">train_feat</span>[<span class="hljs-params">label</span>].<span class="hljs-params">iloc</span>[<span class="hljs-params">train_index</span>])</span><br>xgb_eval = xgb.<span class="hljs-constructor">DMatrix(<span class="hljs-params">train_feat</span>[<span class="hljs-params">predictors</span>].<span class="hljs-params">iloc</span>[<span class="hljs-params">test_index</span>], <span class="hljs-params">train_feat</span>[<span class="hljs-params">label</span>].<span class="hljs-params">iloc</span>[<span class="hljs-params">test_index</span>])</span><br>print(<span class="hljs-string">&quot;..........开始第&#123;&#125;轮训练&quot;</span>.format(i))<br></code></pre></td></tr></table></figure><p>注: xgb.cv()这里的cv()函数是进行了k折叠交叉验证，它不是一个参数搜索功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> xgboost <span class="hljs-keyword">as</span> xgb<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> ggplot <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix,mean_squared_error<br><br>train_path = <span class="hljs-string">&#x27;D:/Pywork/Titanic/train.csv&#x27;</span><br>test_path = <span class="hljs-string">&#x27;D:/Pywork/Titanic/test.csv&#x27;</span><br>train = pd.read_csv(train_path)<br>test = pd.read_csv(test_path)<br><br><br>best_param = <span class="hljs-built_in">list</span>()<br>best_logloss = np.Inf<br>best_logloss_index = <span class="hljs-number">0</span><br>X_hote = pd.get_dummies(X_train)<br><span class="hljs-built_in">print</span>(X_hote.info())<br>dtrain = xgb.DMatrix(X_hote, y_train)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    xgb_params = &#123;<br>        <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&quot;binary:logistic&quot;</span>,<br>        <span class="hljs-string">&#x27;max_depth&#x27;</span>: np.random.randint(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>), <span class="hljs-comment"># 构建树的深度，越大越容易过拟合</span><br>        <span class="hljs-string">&#x27;eta&#x27;</span>: np.random.uniform(<span class="hljs-number">.01</span>, <span class="hljs-number">.3</span>), <span class="hljs-comment"># 如同学习率</span><br>        <span class="hljs-string">&#x27;gamma&#x27;</span>: np.random.uniform(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.2</span>),<span class="hljs-comment"># gamma最小损失调节范围</span><br>        <span class="hljs-string">&#x27;subsample&#x27;</span>: np.random.uniform(<span class="hljs-number">.6</span>, <span class="hljs-number">.9</span>), <span class="hljs-comment"># 随机采样训练样本</span><br>        <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: np.random.uniform(<span class="hljs-number">.5</span>, <span class="hljs-number">.8</span>), <span class="hljs-comment"># 生成树时进行的列采样</span><br>        <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">41</span>),<br>        <span class="hljs-string">&#x27;max_delta_step&#x27;</span>: np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>),<br>        <span class="hljs-string">&#x27;silent&#x27;</span>: <span class="hljs-number">1</span><br>    &#125;<br>    cv_nfold = <span class="hljs-number">5</span><br>    cv_nround = <span class="hljs-number">50</span><br>    bst_cv1 = xgb.cv(params=xgb_params,  <span class="hljs-comment"># 这是一个字典，里面包含着训练中的参数关键字和对应的值</span><br>                     dtrain=dtrain, <span class="hljs-comment"># 训练的数据</span><br>                     num_boost_round=cv_nround, <span class="hljs-comment"># 这是指提升迭代的个数</span><br>                      <span class="hljs-comment"># evals  这是一个列表，用于对训练过程中进行评估列表中的元素 evals = [(dtrain,’train’)]</span><br>                     <span class="hljs-comment"># feval,自定义评估函数</span><br>                     <span class="hljs-comment"># verbose_eval(可以输入布尔型或数值型)，也要求evals 里至少有 一个元素。</span><br>                     <span class="hljs-comment"># 如果为True ,则对evals中元素的评估结果会输出在结果中；如果输入数字，假设为5，则每隔5个迭代输出一次</span><br>                     nfold=cv_nfold,<br>                     seed=<span class="hljs-number">0</span>,<br>                     metrics=[<span class="hljs-string">&quot;auc&quot;</span>, <span class="hljs-string">&quot;rmse&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;logloss&quot;</span>],<br>                     maximize=<span class="hljs-literal">False</span>, <span class="hljs-comment"># 是否对评估函数进行最大化</span><br>                     early_stopping_rounds=<span class="hljs-number">10</span>,<br>                     verbose_eval=<span class="hljs-literal">None</span>,<br>                     )<br><br>    min_logloss = <span class="hljs-built_in">min</span>(bst_cv1[<span class="hljs-string">&#x27;test-logloss-mean&#x27;</span>])<br>    min_logloss_index = bst_cv1.index[bst_cv1[<span class="hljs-string">&#x27;test-logloss-mean&#x27;</span>] == <span class="hljs-built_in">min</span>(bst_cv1[<span class="hljs-string">&#x27;test-logloss-mean&#x27;</span>])][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">if</span> min_logloss &lt; best_logloss:<br>        best_logloss = min_logloss<br>        best_logloss_index = min_logloss_index<br>        best_param = xgb_params<br><br>nround = best_logloss_index<br><span class="hljs-built_in">print</span>(best_logloss)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;best_round = %d&#x27;</span> % (nround))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;best_param : ------------------------------&#x27;</span>)<br><span class="hljs-built_in">print</span>(best_param)  <span class="hljs-comment"># 显示最佳参数组合，到后面真正的模型要用</span><br>plt.figure()<br>plt.plot(bst_cv1[<span class="hljs-string">&#x27;train-logloss-mean&#x27;</span>], <span class="hljs-string">&#x27;g&#x27;</span>, label=<span class="hljs-string">&#x27;train&#x27;</span>)<br>plt.plot(bst_cv1[<span class="hljs-string">&#x27;test-logloss-mean&#x27;</span>], <span class="hljs-string">&#x27;r&#x27;</span>, label=<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-built_in">print</span>(plt.show())<br></code></pre></td></tr></table></figure><ul><li>方法三：使用 gridsearch 和 cross validation</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from sklearn<span class="hljs-selector-class">.grid_search</span> import GridSearchCV<br>params = &#123;<span class="hljs-string">&#x27;max_depth&#x27;</span>:<span class="hljs-selector-attr">[i for i in range(2,7)]</span>,<span class="hljs-string">&#x27;n_estimators&#x27;</span>:<span class="hljs-selector-attr">[j for j in range(100,1100,200)]</span>,<span class="hljs-string">&#x27;learning_rate&#x27;</span>:<span class="hljs-selector-attr">[0.05,0.1,0.25,0.5,0.1]</span><br>         &#125;<br>xgbc_best = <span class="hljs-built_in">XGBClassifier</span>()<br>gs = <span class="hljs-built_in">GridSearchCV</span>(xgbc_best,params,n_jobs=-<span class="hljs-number">1</span>,cv=<span class="hljs-number">5</span>,verbose=<span class="hljs-number">1</span>)<br>gs<span class="hljs-selector-class">.fit</span>(X_train,y_train)<br></code></pre></td></tr></table></figure><h5 id="3-绘制-train-x2F-test-的-auc-x2F-rmse-x2F-error"><a href="#3-绘制-train-x2F-test-的-auc-x2F-rmse-x2F-error" class="headerlink" title="(3) 绘制 train&#x2F;test 的 auc&#x2F;rmse&#x2F;error"></a><strong>(3) 绘制 train&#x2F;test 的 auc&#x2F;rmse&#x2F;error</strong></h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def xgb_plot(input, output):<br>    history = input<br>    train_history = history.iloc[:, 8:16].assign(id=[i+1 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> history.index])<br>    train_history[<span class="hljs-string">&#x27;Class&#x27;</span>] = <span class="hljs-string">&#x27;train&#x27;</span><br>    test_history = history.iloc[:, 0:8].assign(id=[i+1 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> history.index])<br>    test_history[<span class="hljs-string">&#x27;Class&#x27;</span>] = <span class="hljs-string">&#x27;test&#x27;</span><br>    train_history.columns = [<span class="hljs-string">&quot;auc_mean&quot;</span>, <span class="hljs-string">&quot;auc_std&quot;</span>, <span class="hljs-string">&quot;error_mean&quot;</span>, <span class="hljs-string">&quot;error_std&quot;</span>, <span class="hljs-string">&quot;logloss_mean&quot;</span>, <span class="hljs-string">&quot;logloss_std&quot;</span>, <span class="hljs-string">&quot;rmse_mean&quot;</span>, <span class="hljs-string">&quot;rmse_std&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;Class&quot;</span>]<br>    test_history.columns = [<span class="hljs-string">&quot;auc_mean&quot;</span>, <span class="hljs-string">&quot;auc_std&quot;</span>, <span class="hljs-string">&quot;error_mean&quot;</span>, <span class="hljs-string">&quot;error_std&quot;</span>, <span class="hljs-string">&quot;logloss_mean&quot;</span>, <span class="hljs-string">&quot;logloss_std&quot;</span>, <span class="hljs-string">&quot;rmse_mean&quot;</span>, <span class="hljs-string">&quot;rmse_std&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;Class&quot;</span>]<br>    his = pd.concat([train_history, test_history])<br><br>    <span class="hljs-keyword">if</span> output == <span class="hljs-string">&quot;auc&quot;</span>:<br>        his[<span class="hljs-string">&#x27;y_min_auc&#x27;</span>] = his[<span class="hljs-string">&#x27;auc_mean&#x27;</span>]-his[<span class="hljs-string">&#x27;auc_std&#x27;</span>]<br>        his[<span class="hljs-string">&#x27;y_man_auc&#x27;</span>] = his[<span class="hljs-string">&#x27;auc_mean&#x27;</span>]+his[<span class="hljs-string">&#x27;auc_std&#x27;</span>]<br>        auc = ggplot(his, aes(<span class="hljs-attribute">x</span>=<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;auc_mean&#x27;</span>, <span class="hljs-attribute">ymin</span>=<span class="hljs-string">&#x27;y_min_auc&#x27;</span>, <span class="hljs-attribute">ymax</span>=<span class="hljs-string">&#x27;y_man_auc&#x27;</span>, <span class="hljs-attribute">fill</span>=<span class="hljs-string">&#x27;Class&#x27;</span>))+geom_line()+geom_ribbon(alpha=0.5)+labs(x=&quot;nround&quot;,y=&#x27;&#x27;,title = <span class="hljs-string">&quot;XGB Cross Validation AUC&quot;</span>)<br>        return auc<br>    <span class="hljs-keyword">if</span> output == <span class="hljs-string">&quot;rmse&quot;</span>:<br>        his[<span class="hljs-string">&#x27;y_min_rmse&#x27;</span>] = his[<span class="hljs-string">&#x27;rmse_mean&#x27;</span>] - his[<span class="hljs-string">&#x27;rmse_std&#x27;</span>]<br>        his[<span class="hljs-string">&#x27;y_man_rmse&#x27;</span>] = his[<span class="hljs-string">&#x27;rmse_mean&#x27;</span>] + his[<span class="hljs-string">&#x27;rmse_std&#x27;</span>]<br>        rmse = ggplot(his, aes(<span class="hljs-attribute">x</span>=<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;rmse_mean&#x27;</span>, <span class="hljs-attribute">ymin</span>=<span class="hljs-string">&#x27;y_min_rmse&#x27;</span>, <span class="hljs-attribute">ymax</span>=<span class="hljs-string">&#x27;y_man_rmse&#x27;</span>, <span class="hljs-attribute">fill</span>=<span class="hljs-string">&#x27;Class&#x27;</span>)) + geom_line() + geom_ribbon(<span class="hljs-attribute">alpha</span>=0.5) + labs(<span class="hljs-attribute">x</span>=<span class="hljs-string">&quot;nround&quot;</span>, <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;XGB Cross Validation RMSE&quot;</span>)<br>        return (rmse)<br>    <span class="hljs-keyword">if</span> output == <span class="hljs-string">&quot;error&quot;</span>:<br>        his[<span class="hljs-string">&#x27;y_min_error&#x27;</span>] = his[<span class="hljs-string">&#x27;error_mean&#x27;</span>] - his[<span class="hljs-string">&#x27;error_std&#x27;</span>]<br>        his[<span class="hljs-string">&#x27;y_man_error&#x27;</span>] = his[<span class="hljs-string">&#x27;error_mean&#x27;</span>] + his[<span class="hljs-string">&#x27;error_std&#x27;</span>]<br>        <span class="hljs-built_in">error</span> = ggplot(his, aes(<span class="hljs-attribute">x</span>=<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;error_mean&#x27;</span>, <span class="hljs-attribute">ymin</span>=<span class="hljs-string">&#x27;y_min_error&#x27;</span>, <span class="hljs-attribute">ymax</span>=<span class="hljs-string">&#x27;y_man_error&#x27;</span>, <span class="hljs-attribute">fill</span>=<span class="hljs-string">&#x27;Class&#x27;</span>)) + geom_line() + geom_ribbon(<span class="hljs-attribute">alpha</span>=0.5) + labs(<span class="hljs-attribute">x</span>=<span class="hljs-string">&quot;nround&quot;</span>, <span class="hljs-attribute">y</span>=<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;XGB Cross Validation ERROR&quot;</span>)<br>        return (error)<br></code></pre></td></tr></table></figure><ul><li>横坐标是迭代次数</li><li>train曲线和test曲线的相差程度，可以侧面反映模型复杂度，检验是否过拟合</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">xgb_plot</span><span class="hljs-params">(bst_cv1, <span class="hljs-string">&#x27;auc&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/y8Dm0rNkvvoO4EXLCTQT*qSCvZwyBYPBvkZweT7h6ok!/b/dL4AAAAAAAAA&bo=EgQ3AgAAAAADFxE!&rf=viewer_4&t=5"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">xgb_plot</span><span class="hljs-params">(bst_cv1,<span class="hljs-string">&#x27;rmse&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/0lHqHpsTCuA8173eyPQ7KXVLsk6NQI*DZPFBixu8APk!/b/dDYBAAAAAAAA&bo=HARvAgAAAAADF0c!&rf=viewer_4&t=5"></p><h5 id="4-建模，进行预测，打印评估指标"><a href="#4-建模，进行预测，打印评估指标" class="headerlink" title="(4) 建模，进行预测，打印评估指标"></a><strong>(4) 建模，进行预测，打印评估指标</strong></h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 利用上面调参结果： best_param<br><br>md_1 = xgb.train(best_param, dtrain, num_boost_round=nround)<br>dtest = xgb.<span class="hljs-constructor">DMatrix(X_test)</span><br>xgbc_y_predict = <span class="hljs-literal">[<span class="hljs-number">1</span> <span class="hljs-identifier">if</span> <span class="hljs-identifier">value</span> &gt;= <span class="hljs-number">0.5</span> <span class="hljs-identifier">else</span> <span class="hljs-number">0</span> <span class="hljs-identifier">for</span> <span class="hljs-identifier">value</span> <span class="hljs-identifier">in</span> <span class="hljs-identifier">md_1</span>.<span class="hljs-identifier">predict</span>(<span class="hljs-identifier">dtest</span>)]</span><br><br>accuracy = accuracy<span class="hljs-constructor">_score(<span class="hljs-params">y_test</span>, <span class="hljs-params">xgbc_y_predict</span> )</span><br>f1_score = f1<span class="hljs-constructor">_score(<span class="hljs-params">y_test</span>,<span class="hljs-params">predictions</span>)</span><br>print(<span class="hljs-string">&quot;Accuracy: %.2f%%&quot;</span> %(accuracy<span class="hljs-operator"> * </span><span class="hljs-number">100.0</span>))<br>print(<span class="hljs-string">&quot;F1 Score: %.2f%%&quot;</span> %(f1_score<span class="hljs-operator"> * </span><span class="hljs-number">100.0</span>))<br><br># save model<br>md_1.save<span class="hljs-constructor">_model(&#x27;<span class="hljs-params">xgb</span>.<span class="hljs-params">model</span>&#x27;)</span><br></code></pre></td></tr></table></figure><ul><li>方法二： 使用 XGBClassifier()</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">md_2 = <span class="hljs-constructor">XGBClassifier(<span class="hljs-operator">**</span><span class="hljs-params">best_param</span>)</span>                   # <span class="hljs-number">2</span>个*号，允许直接填入字典格式的param<br>md_2.fit(X_train, y_train)  <br><br>ypred = md_2.predict(X_test)<br>predictions = <span class="hljs-literal">[<span class="hljs-identifier">round</span>(<span class="hljs-identifier">value</span>) <span class="hljs-identifier">for</span> <span class="hljs-identifier">value</span> <span class="hljs-identifier">in</span> <span class="hljs-identifier">ypred</span>]</span><br><br># 打印评估指标<br>MSE = mean<span class="hljs-constructor">_squared_error(<span class="hljs-params">y_test</span>, <span class="hljs-params">predictions</span>)</span><br>print(<span class="hljs-string">&quot;MSE: %.2f%%&quot;</span> % (MSE<span class="hljs-operator"> * </span><span class="hljs-number">100.0</span>))  <br>accuracy = accuracy<span class="hljs-constructor">_score(<span class="hljs-params">y_test</span>, <span class="hljs-params">predictions</span>)</span><br>print(<span class="hljs-string">&quot;Accuracy: %.2f%%&quot;</span> % (accuracy<span class="hljs-operator"> * </span><span class="hljs-number">100.0</span>))<br>f1_score = f1<span class="hljs-constructor">_score(<span class="hljs-params">y_test</span>, <span class="hljs-params">predictions</span>)</span><br>print(<span class="hljs-string">&quot;F1 Score: %.2f%%&quot;</span> % (f1_score<span class="hljs-operator"> * </span><span class="hljs-number">100.0</span>))<br></code></pre></td></tr></table></figure><h5 id="5-绘制Importance排序图"><a href="#5-绘制Importance排序图" class="headerlink" title="(5) 绘制Importance排序图"></a><strong>(5) 绘制Importance排序图</strong></h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ax</span> = xgb.plot_importance(md_1, height=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">fig</span> = ax.figure<br><span class="hljs-attribute">fig</span>.set_size_inches(<span class="hljs-number">25</span>,<span class="hljs-number">20</span>)                  # 可调节图片尺寸和紧密程度<br><span class="hljs-attribute">plt</span>.show()<br></code></pre></td></tr></table></figure><h5 id="6-根据Importance进行特征筛选"><a href="#6-根据Importance进行特征筛选" class="headerlink" title="(6) 根据Importance进行特征筛选"></a><strong>(6) 根据Importance进行特征筛选</strong></h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># sorted(list(selection_model.booster().get_score(importance_type=&#x27;weight&#x27;).values()),reverse = True)</span><br><br>importance_plot = pd.DataFrame(&#123;<span class="hljs-string">&#x27;feature&#x27;</span>:list(X_train.columns),<span class="hljs-string">&#x27;importance&#x27;</span>:md_2.feature_importances_&#125;)<br>importance_plot = importance_plot.sort_values(<span class="hljs-attribute">by</span>=<span class="hljs-string">&#x27;importance&#x27;</span>)<br>importance_plot = importance_plot.reset.index(<span class="hljs-attribute">drop</span>=<span class="hljs-literal">True</span>)<br>thresholds = importance_plot.importance<br>thresholds_valid = np.unique(thresholds[thresholds != 0])<br><br><br><span class="hljs-keyword">for</span> thresh <span class="hljs-keyword">in</span> thresholds_valid:<br><br># select features using threshold<br>selection = SelectFromModel(md_2, <span class="hljs-attribute">threshold</span>=thresh, <span class="hljs-attribute">prefit</span>=<span class="hljs-literal">True</span>)<br>select_X_train = selection.transform(X_train)<br># train model<br>selection_model = XGBClassifier(*<span class="hljs-number">*be</span>st_param)<br>selection_model.fit(select_X_train, y_train)<br># eval model<br>select_X_test = selection.transform(X_test)<br>y_pred = selection_model.predict(select_X_test)<br>predictions = [round(value) <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> y_pred]<br>accuracy = accuracy_score(y_test, predictions)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Thresh=%.4f, n=%d, Accuracy: %.2f%%&quot;</span> % (thresh, select_X_train.shape[1], accuracy<span class="hljs-number">*100</span>.0))<br><br><br>thresh = 0.034<br>selected_features = list(importance_plot[importance_plot.importance &gt; thresh][<span class="hljs-string">&#x27;feature&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;selected features are :\n %s&#x27;</span>%selected_features)<br>select_X_train = X_train[selected_features]                        # 筛选Importance符合阈值的特征集<br><br>n_features = selected_X_train.shape[1]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;total: %d features are selected&#x27;</span> %n_features)<br><br>selection_model = XGBClassifier(*<span class="hljs-number">*be</span>st_param)                                   <br>selection_model.fit(select_X_train, y_train)<br><br>select_X_test = X_test[selected_features]<br>y_pred = selection_model.predict(select_X_test)<br>predictions = [round(value) <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> y_pred]<br>accuracy = accuracy_score(y_test, predictions)<br>f1_score = f1_score(y_test, predictions)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: %.2f%%&quot;</span> % (accuracy * 100.0))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;F1 Score: %.2f%%&quot;</span> % (f1_score * 100.0))<br></code></pre></td></tr></table></figure><p>至于是先调参，再做变量筛选，还是先筛选后调参，或是反复调参反复筛选，纯凭个人喜号。</p><h5 id="7-绘制决策树"><a href="#7-绘制决策树" class="headerlink" title="(7)绘制决策树"></a><strong>(7)绘制决策树</strong></h5><p>参考:<a href="http://codewithzhangyi.com/2018/06/01/XGBOOST%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">codewithzhangyi.com</a><br>这里我没有绘制决策树，参考一个很棒的小姐姐个人网站，她的这篇文章中有写。</p><hr><p>参考：<br><a href="https://xgboost.readthedocs.io/en/latest/">官方使用手册</a><br><a href="http://codewithzhangyi.com/">codewithzhangyi.com</a><br><a href="https://www.cnblogs.com/wj-1314/p/9402324.html">Python机器学习笔记：XgBoost算法</a></p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>XGBoost</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning-实战 Titanic生存预测</title>
    <link href="/2019/03/23/Machine-Learning-%E5%AE%9E%E6%88%98-Titanic%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B/"/>
    <url>/2019/03/23/Machine-Learning-%E5%AE%9E%E6%88%98-Titanic%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>本文是机器学习实战片,例子是kaggle上老经典的例子了，Titanic生存预测<br>目的是了解机器学习的大体流程。文末百度网盘链接中包含本文用到的数据集和代码。</p><p><strong>环境</strong><br>win8, python3,jupyter notebook</p><p><strong>目录</strong></p><ul><li>项目背景</li><li>数据概览</li><li>数据预处理</li><li>特征分析</li><li>特征工程</li><li>构建模型</li></ul><h3 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1.项目背景"></a>1.项目背景</h3><p>泰坦尼克号是当时世界上体积最庞大内部设施最豪华的客运轮船，当时泰坦尼克号的乘船事件可谓轰动全球，相信大家都看过那部经典电影。泰坦尼克号将乘客分为三个等级: 三等舱位于船身较下层也最便宜，一等舱是整艘船最为昂贵奢华的部分，二等舱在其中间。在这次灾难中能否幸存下来难免会有些运气成分, 但是有些人比其他人更可能生存下来, 比如妇女, 儿童和上层阶级。在电影中出现过让”女人和孩子先走“的台词。</p><h3 id="2-数据概览"><a href="#2-数据概览" class="headerlink" title="2.数据概览"></a>2.数据概览</h3><p>项目共提供了两份数据，train.csv文件作为训练集构建与生存相关的模型；另一份test.csv文件则用作测试集, 用我们构建出来的模型预测生存情况.</p><table><thead><tr><th>字段</th><th>字段含义</th></tr></thead><tbody><tr><td>PassengerId</td><td>乘客编号</td></tr><tr><td>Survived</td><td>是否生还，0表示未生还，1表示生还</td></tr><tr><td>Pclass</td><td>船票种类，折射处乘客的社会地位，1表示上层阶级，2表示中层阶级，3表示底层阶级</td></tr><tr><td>Sex</td><td>性别，男性为male，女性为female</td></tr><tr><td>Age</td><td>年龄，不满1岁的年龄为小数</td></tr><tr><td>SibSp</td><td>该乘客同船的兄弟姐妹及配偶的数量</td></tr><tr><td>Parch</td><td>该乘客同船的父母以及儿女的数量</td></tr><tr><td>Ticket</td><td>船票编号</td></tr><tr><td>Fare</td><td>买票的费用</td></tr><tr><td>Cabin</td><td>船舱编号</td></tr><tr><td>Embarked</td><td>代表在哪里上的船</td></tr></tbody></table><h5 id="2-1读取数据："><a href="#2-1读取数据：" class="headerlink" title="2.1读取数据："></a>2.1读取数据：</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">import pandas as pd<br>train = pd.read_csv(&#x27;..\train.csv&#x27;)<br><span class="hljs-keyword">test </span>= pd.read_csv(&#x27;..\test.csv&#x27;)<br></code></pre></td></tr></table></figure><h5 id="2-2查看前五行数据"><a href="#2-2查看前五行数据" class="headerlink" title="2.2查看前五行数据"></a>2.2查看前五行数据</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">train<span class="hljs-selector-class">.head</span>()<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/5y42.3hfvuBqT3H9fdp*wG2wuqDV0eXAxUYHTvF*igc!/b/dL8AAAAAAAAA&bo=0wOxAAAAAAADF1M!&rf=viewer_4&t=5"></p><h5 id="2-3查看数据表整体信息"><a href="#2-3查看数据表整体信息" class="headerlink" title="2.3查看数据表整体信息"></a>2.3查看数据表整体信息</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">train.<span class="hljs-built_in">info</span>()<br>test.<span class="hljs-built_in">info</span>()<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/nLZfras9IrjU4mJwrqA.zvkgTJ5MjqhlIWq4CcHL28A!/b/dLkAAAAAAAAA&bo=kAH.AQAAAAADF1w!&rf=viewer_4&t=5"></p><h3 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3.数据预处理"></a>3.数据预处理</h3><p>训练集中 Age Embarked  Cabin有缺省值<br>测试集中 Age Fare Cabin有缺省值 但根据经验常识Cabin船舱编号排除在特征外</p><pre><code class="hljs">train[&#39;Embarked&#39;].value_counts()</code></pre><h4 id="3-1对缺失值进行填充"><a href="#3-1对缺失值进行填充" class="headerlink" title="3.1对缺失值进行填充"></a>3.1对缺失值进行填充</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Embarked&#x27;</span>]</span><span class="hljs-selector-class">.fillna</span>(<span class="hljs-string">&#x27;S&#x27;</span>,inplace=True)<br>train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span><span class="hljs-selector-class">.fillna</span>(train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span><span class="hljs-selector-class">.mean</span>(),inplace=True)<br>test<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span><span class="hljs-selector-class">.fillna</span>(test<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span><span class="hljs-selector-class">.mean</span>(),inplace=True)<br>test<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Fare&#x27;</span>]</span><span class="hljs-selector-class">.fillna</span>(test<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Fare&#x27;</span>]</span><span class="hljs-selector-class">.mean</span>(),inplace=True)<br></code></pre></td></tr></table></figure><h4 id="3-2类型转换"><a href="#3-2类型转换" class="headerlink" title="3.2类型转换"></a>3.2类型转换</h4><p>数据类型转换格式如下：运用函数astype()</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span>  = train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Age&#x27;</span>]</span><span class="hljs-selector-class">.astype</span>(int)<br></code></pre></td></tr></table></figure><h4 id="4-特征分析"><a href="#4-特征分析" class="headerlink" title="4.特征分析"></a>4.特征分析</h4><p>在11个特征中, 哪些是和幸存相关的呢?</p><ul><li>Sex<br>在泰坦尼克号的电影中，有句台词是让女人和小孩先走，这里的性别肯定相关性高了，我们看看数据</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> mpl<br>mpl.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  #解决seaborn中文字体显示问题<br>plt.rcParams[<span class="hljs-string">&quot;figure.dpi&quot;</span>] =mpl.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span> # 解决保存图像是负号<span class="hljs-string">&#x27;-&#x27;</span>显示为方块的问题<br>%matplotlib <span class="hljs-keyword">inline</span><br>train[train[<span class="hljs-string">&#x27;Survived&#x27;</span>]==<span class="hljs-number">1</span>].groupby(<span class="hljs-string">&#x27;Sex&#x27;</span>)[<span class="hljs-string">&#x27;Survived&#x27;</span>].value_counts()<br><br>sns.barplot(x=<span class="hljs-string">&#x27;Sex&#x27;</span>,y=<span class="hljs-string">&#x27;Survived&#x27;</span>,data=train)<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/kVo0VoSsmHJzFU*SF572VUMNDvlUSNkOImvlrc*Joqc!/b/dL8AAAAAAAAA&bo=ewHfAAAAAAADF5c!&rf=viewer_4&t=5"><br>可以从柱状图中看出男女的生成比例很明显的不一样。所以Sex是一个强特征。</p><ul><li>Pclass 对于船舱等级, 一等舱是整个船最昂贵奢华的地方, 有钱人才能享受, 想必一等舱的有钱人比三等舱的穷人更容易幸存, 到底是不是呢? 用数据说话</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sns<span class="hljs-selector-class">.pointplot</span>(x=<span class="hljs-string">&#x27;Pclass&#x27;</span>,y=<span class="hljs-string">&#x27;Survived&#x27;</span>,hue=<span class="hljs-string">&#x27;Sex&#x27;</span>,data=train<br>              ,palette=&#123;<span class="hljs-string">&#x27;male&#x27;</span>:<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>:<span class="hljs-string">&#x27;pink&#x27;</span>&#125;,markers=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]</span>,linestyles=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-string">&#x27;--&#x27;</span>]</span>)<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/ATQPPmZoeVRZ16JcGmjyBXPZ5OtYtLqjCgWWj6P*BlY!/b/dC8BAAAAAAAA&bo=awHjAAAAAAADF7s!&rf=viewer_4&t=5"><br>可以看到一等舱人员的幸存机会远大于三等舱, 果然和船舱等级相关.</p><ul><li><p>Age<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/O8Bvm6BCCjAFqnEfpKKyP5nODQ0JFDsPgEdDA4HnMSQ!/b/dLYAAAAAAAAA&bo=WAHmAAAAAAADF40!&rf=viewer_4&t=5"><br>可以看到女人普遍存活率都很高，男性在0-10岁之间存活率高，显然年龄是有影响的。</p></li><li><p>SibSp 从之前的描述性统计了解到, 兄弟姐妹与配偶的人数最多为8, 最少为0, 哪个更容易生存呢?<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/nwU24IyRk5CFZqTzKQLk*sv2Kx5Pblpabo86QfuzizA!/b/dL8AAAAAAAAA&bo=TgHjAAAAAAADF54!&rf=viewer_4&t=5"><br>可以看出关键时候，有兄弟姐妹和配偶的会提高存活几率，1到2个为宜，多了容易全部die</p></li><li><p>Parch 该乘客同船的父母以及儿女的数量,看看船上有父母孩子的存活率会不会更高呢？<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/2cyYwyi.A1J1OF0xnM014uLhb3hl8EeQVQifaBNbIYI!/b/dL8AAAAAAAAA&bo=egHkAAAAAAADF60!&rf=viewer_4&t=5"><br>由上图可以看吹1-3个存活率会更高，毕竟人多力量大。但这个力量也不能太大，太大容易翻船哈哈哈。</p></li></ul><h4 id="5-特征工程"><a href="#5-特征工程" class="headerlink" title="5.特征工程"></a>5.特征工程</h4><p>对分类特征进行向量化</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#采用DictVectorizer对特征向量化</span><br><span class="hljs-comment"># DictVectorizer为分类（也称为标称，离散）特征实现所谓的one-of-K或“one-hot（独热）”编码</span><br><span class="hljs-keyword">from</span> sklearn.feature_extraction import DictVectorizer<br>dict_vec = DictVectorizer(<span class="hljs-attribute">sparse</span>=<span class="hljs-literal">False</span>)<br>X_train = dict_vec.fit_transform(X_train.to_dict(<span class="hljs-attribute">orient</span>=<span class="hljs-string">&#x27;record&#x27;</span>))<br>X_test = dict_vec.fit_transform(X_test.to_dict(<span class="hljs-attribute">orient</span>=<span class="hljs-string">&#x27;record&#x27;</span>))<br><br><span class="hljs-comment"># 查看特征：dict_vec.feature_names_</span><br></code></pre></td></tr></table></figure><h4 id="6-构建模型"><a href="#6-构建模型" class="headerlink" title="6.构建模型"></a>6.构建模型</h4><p>使用随机森林和Xgboost分别进行模型训练</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#从sklearn.ensemble中导入RandomForestClassifier<br>from sklearn<span class="hljs-selector-class">.ensemble</span> import RandomForestClassifier<br>#使用默认配置初始化RandomForestClassifier<br>rfc = <span class="hljs-built_in">RandomForestClassifier</span>()<br><br>#使用默认配置的RandomForestClassifier进行预测操作<br>rfc<span class="hljs-selector-class">.fit</span>(X_train,y_train)<br>rfc_y_predict = rfc<span class="hljs-selector-class">.predict</span>(X_test)<br>rfc_submission = pd<span class="hljs-selector-class">.DataFrame</span>(&#123;<span class="hljs-string">&#x27;PassengerId&#x27;</span>:test<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;PassengerId&#x27;</span>]</span>,<span class="hljs-string">&#x27;Survived&#x27;</span>:rfc_y_predict&#125;)<br>rfc_submission<span class="hljs-selector-class">.to_csv</span>(<span class="hljs-string">&#x27;D:\\Pywork\\Titanic\\rfc_submission.csv&#x27;</span>,index=False)<br><br>from sklearn<span class="hljs-selector-class">.cross_validation</span> import cross_val_score<br>#使用<span class="hljs-number">5</span>折交叉验证的方法在训练集上分别对默认配置的RandomForestClassifier以及XGBClassifier进行性能评估，并获得平均分类准确性的得分<br><span class="hljs-function"><span class="hljs-title">cross_val_score</span><span class="hljs-params">(rfc,X_train,y_train,cv=<span class="hljs-number">5</span>)</span></span><span class="hljs-selector-class">.mean</span>()<br><br>#从流行包xgboost中导入XGBClassifier进行交叉验证<br>from xgboost import XGBClassifier<br>xgbc = <span class="hljs-built_in">XGBClassifier</span>()<br><span class="hljs-function"><span class="hljs-title">cross_val_score</span><span class="hljs-params">(xgbc,X_train,y_train,cv=<span class="hljs-number">5</span>)</span></span><span class="hljs-selector-class">.mean</span>()<br></code></pre></td></tr></table></figure><p>使用并行网络的方式寻找更好的超参数组合，以期待进一步提高XGBClassifier的预测性能</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from sklearn<span class="hljs-selector-class">.grid_search</span> import GridSearchCV<br>params = &#123;<span class="hljs-string">&#x27;max_depth&#x27;</span>:<span class="hljs-selector-attr">[i for i in range(2,7)]</span>,<span class="hljs-string">&#x27;n_estimators&#x27;</span>:<span class="hljs-selector-attr">[j for j in range(100,1100,200)]</span>,<span class="hljs-string">&#x27;learning_rate&#x27;</span>:<span class="hljs-selector-attr">[0.05,0.1,0.25,0.5,0.1]</span><br>         &#125;<br>xgbc_best = <span class="hljs-built_in">XGBClassifier</span>()<br>gs = <span class="hljs-built_in">GridSearchCV</span>(xgbc_best,params,n_jobs=-<span class="hljs-number">1</span>,cv=<span class="hljs-number">5</span>,verbose=<span class="hljs-number">1</span>)<br>gs<span class="hljs-selector-class">.fit</span>(X_train,y_train)<br></code></pre></td></tr></table></figure><p>检查优化完成后的超参数配置<br>print(gs.best_score_)<br>print(gs.best_params_)</p><p>最后进行模型预测</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#使用经过超参数配置的XGBClassfier对测试数据的预测结果存储在文件xgbc_best_submission中</span><br>xgbc_best_y_predict = gs.predict(X_test)<br>xgbc_best_submission = pd.DataFrame(&#123;<span class="hljs-string">&#x27;PassengerId&#x27;</span>:test[<span class="hljs-string">&#x27;PassengerId&#x27;</span>],<span class="hljs-string">&#x27;Survived&#x27;</span>:xgbc_best_y_predict&#125;)<br><span class="hljs-comment">#将默认配置的RandomForestClassifier对测试数据的预测结果存储在文件rfc_submission.csv中。</span><br>xgbc_best_submission.to_csv(<span class="hljs-string">&#x27;D:\\Pywork\\Titanic\\xgbc_best_submission.csv&#x27;</span>,<span class="hljs-attribute">index</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>想要以上涉及到的源代码可以联系我<br>邮箱:<a href="mailto:&#121;&#x75;&#x74;&#105;&#x6e;&#103;&#57;&#x35;&#x39;&#55;&#x40;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;">&#121;&#x75;&#x74;&#105;&#x6e;&#103;&#57;&#x35;&#x39;&#55;&#x40;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a><br>百度网盘：<a href="https://pan.baidu.com/s/1vGq4Et2gReM58Dr_1O-v3Q">https://pan.baidu.com/s/1vGq4Et2gReM58Dr_1O-v3Q</a> 密码：uoqv</p><p>参考文章：</p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>XGBoost</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北上广深租房信息的爬取和分析</title>
    <link href="/2019/03/23/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1%E7%A7%9F%E6%88%BF%E4%BF%A1%E6%81%AF%E7%9A%84%E7%88%AC%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <url>/2019/03/23/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1%E7%A7%9F%E6%88%BF%E4%BF%A1%E6%81%AF%E7%9A%84%E7%88%AC%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本文通过爬取链家租房网站的租房信息，对北上广深一线城市的租房信息进行分析。</p><p>以下是本篇的思维导图<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/CINppwwjU78GvqcZ*S*yH7xxzLe5RuJHujdorHtoH.k!/b/dLYAAAAAAAAA&bo=7wUDBAAAAAADJ.8!&rf=viewer_4&t=5"></p><h3 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h3><p>准备工作：安装mongdb数据库，爬取到的数据将保存在mongdb数据库</p><h4 id="1-首先找到爬取数据的路口"><a href="#1-首先找到爬取数据的路口" class="headerlink" title="1.首先找到爬取数据的路口"></a>1.首先找到爬取数据的路口</h4><p>进入链家网的租房网站可以发现规律提取传参<br><a href="https://m.lianjia.com/chuzu/sh/zufang/xujiahui">https://m.lianjia.com/chuzu/sh/zufang/xujiahui</a><br>规律提取如下：<br><a href="https://m.lianjia.com/chuzu/%7B%7D/zufang/%7B%7D">https://m.lianjia.com/chuzu/{}/zufang/{}</a> 其中第一个花括号里面是传入城市的缩写如：上海-sh，广州-gz，北京-bj，深圳-sz,第二个括号里面传入区域例如上海的徐汇区-xuhui</p><p>后面发现如果按照区域爬取每区最多只能获得2000条数据，后来解决的办法是先爬取各区的商圈，最终以各区商圈来爬数据，那么商圈怎么爬取</p><p>可以在网页中查看代码信息发现商圈被写在data-key后面，这样用正则表达式re.findall()就可以获取商圈<br>“data-type&#x3D;&quot;bizcircle&quot; data-key&#x3D;&quot;(.*)&quot; class&#x3D;&quot;oneline &quot;&gt;”</p><h4 id="2-找到api数据接口"><a href="#2-找到api数据接口" class="headerlink" title="2.找到api数据接口"></a>2.找到api数据接口</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">url = <span class="hljs-string">&#x27;https://app.api.lianjia.com/Rentplat/v1/house/list?city_id=&#123;&#125;&amp;condition=&#123;&#125;/rt&#123;&#125;&amp;limit=30&amp;offset=&#123;&#125;&amp;request_ts=&#123;&#125;&amp;scene=list&#x27;</span>.format(<span class="hljs-keyword">info</span>[<span class="hljs-number">0</span>], bc_name,type_code, idx*<span class="hljs-number">30</span>, <span class="hljs-type">int</span>(<span class="hljs-type">time</span>.time()))<br></code></pre></td></tr></table></figure><p>通过分析网页可以找到上面的api数据接口，其中<br>info[0]：110000(北京),310000(上海),440100(广州),440300(深圳)<br>bc_name：上面爬下来的商圈<br>type_code：（整租）200600000001、（合租）200600000002<br>idx:爬取的页数<br>time.time():当前时间戳</p><p>爬取到什么时候停止？当一页返回的条数小于30时，我们判断爬取完成。返回的条数在上面爬取上面链接中的数据里会有一个total，对应存的就是当页的条数</p><p>后面会用到经纬度制作租房地点的热力图，所以还需爬取经纬度信息。经纬度信息包含在上面返回的m_url网页中，还需要再爬取m_url一层，到这里数据爬取的分析工作基本完成</p><h3 id="3-数据保存"><a href="#3-数据保存" class="headerlink" title="3.数据保存"></a>3.数据保存</h3><p>将上面爬取到的数据保存在mongodb中,拿到mongodb连接对象，新建一个表，伪代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> host = os.environ.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;MONGODB_HOST&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>)  # 本地数据库<br><span class="hljs-built_in"> port </span>= os.environ.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;MONGODB_PORT&#x27;</span>, <span class="hljs-string">&#x27;27017&#x27;</span>)  # 数据库端口<br>mongo_url = <span class="hljs-string">&#x27;mongodb://&#123;&#125;:&#123;&#125;&#x27;</span>.format(host, port)<br>mongo_db = os.environ.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;MONGODB_DATABASE&#x27;</span>, <span class="hljs-string">&#x27;Lianjia&#x27;</span>)<span class="hljs-built_in"></span><br><span class="hljs-built_in">client </span>= MongoClient(mongo_url)<br>self.db = client[mongo_db]<br>self.db[<span class="hljs-string">&#x27;zufang&#x27;</span>].create_index(<span class="hljs-string">&#x27;m_url&#x27;</span>, <span class="hljs-attribute">unique</span>=<span class="hljs-literal">True</span>)  # 以m端链接为主键进行去重<br></code></pre></td></tr></table></figure><p>将需要存储的字段封装在item这个字典里，以upsert的方式更新在表里即可。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">self<span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;zufang&#x27;</span>]</span><span class="hljs-selector-class">.update_one</span>(&#123;<span class="hljs-string">&#x27;m_url&#x27;</span>: item<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;m_url&#x27;</span>]</span>&#125;, &#123;<span class="hljs-string">&#x27;$set&#x27;</span>: item&#125;, upsert=True)<br></code></pre></td></tr></table></figure><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>数据清理的步骤一般包括</p><ul><li>去除不需要的数据</li><li>去除&#x2F;补全缺失数据</li><li>去除&#x2F;修改格式和内容错误的数据</li><li>去除&#x2F;修改逻辑错误的数据</li></ul><p><strong>去除不需要的数据</strong>：删除_id</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 数据清洗</span><br><span class="hljs-comment"># 1. 去掉“_id”列</span><br><span class="hljs-built_in">del</span> <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;_id&#x27;</span>]<br></code></pre></td></tr></table></figure><p>一般DataFrame会自动生成_id作为唯一标识，里面是随机生成的一串字符串<br><strong>去除&#x2F;补全缺失数据</strong>：将None值用numpy.nan填充</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># <span class="hljs-string">&#x27;distance&#x27;</span>, <span class="hljs-string">&#x27;latitude&#x27;</span>, <span class="hljs-string">&#x27;longitude&#x27;</span>因为有None，需另外处理<br>def None_distance(<span class="hljs-keyword">data</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">is</span> None:<br>        <span class="hljs-keyword">return</span> np.nan<br>    <span class="hljs-keyword">else</span>:int(<span class="hljs-keyword">data</span>)<br><br>def None_latlon(<span class="hljs-keyword">data</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">is</span> None or <span class="hljs-keyword">data</span>==<span class="hljs-string">&#x27;&#x27;</span>:<br>        <span class="hljs-keyword">return</span> np.nan<br>    <span class="hljs-keyword">else</span>:<span class="hljs-keyword">return</span> float(<span class="hljs-keyword">data</span>)<br><span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;distance&#x27;</span>] = <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;distance&#x27;</span>].apply(None_distance)<br><span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;latitude&#x27;</span>] = <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;latitude&#x27;</span>].apply(None_latlon)<br><span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;longitude&#x27;</span>] = <span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;longitude&#x27;</span>].apply(None_latlon)<br></code></pre></td></tr></table></figure><p><strong>去除&#x2F;修改格式和内容错误的数据</strong>：</p><ul><li>在房屋大小的一列中，包含-，一个范围区间，同样的租金范围那一列里也有，这里将取左边右边两值得平均值.<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># 5. rent_area观察excel里的样例数据发现 有的是个范围带有&#x27;-‘</span><br><span class="hljs-title">def</span> get_aver(<span class="hljs-class"><span class="hljs-keyword">data</span>):</span><br>    <span class="hljs-keyword">if</span> isinstance(<span class="hljs-class"><span class="hljs-keyword">data</span>,str) and &#x27;-&#x27; in <span class="hljs-keyword">data</span>:</span><br>        low,high = <span class="hljs-class"><span class="hljs-keyword">data</span>.split(&#x27;-&#x27;)</span><br>        return (int(low)+int(high))/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">else</span>:<br>        return int(<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br><br><span class="hljs-class"><span class="hljs-keyword">data</span>[&#x27;rent_area&#x27;] = <span class="hljs-keyword">data</span>[&#x27;rent_area&#x27;].apply(<span class="hljs-title">get_aver</span>)</span><br></code></pre></td></tr></table></figure></li><li>数据类型转换<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"># 数据类型转换<br>for <span class="hljs-selector-tag">i</span> in <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;bathroom_num&#x27;</span>,<span class="hljs-string">&#x27;bedroom_num&#x27;</span>,<span class="hljs-string">&#x27;hall_num&#x27;</span>,<span class="hljs-string">&#x27;rent_price_listing&#x27;</span>]</span>:<br>    data[i] = data[i].<span class="hljs-built_in">astype</span>(int)<br></code></pre></td></tr></table></figure><strong>去除&#x2F;修改逻辑错误的数据</strong>:<br>房间小于5平<br>卫生间异常多的数据<br>卧室异常多的数据</li></ul><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="1-各城市的租房分布怎么样？"><a href="#1-各城市的租房分布怎么样？" class="headerlink" title="1.各城市的租房分布怎么样？"></a>1.各城市的租房分布怎么样？</h4><p>看看北上广深房源都在哪个区域分布多，哪个区域少,首先来看看北京<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/GMDN4VjvYjZaZwcfnZxhPhjvA.hKs375oIDgXoyNoCA!/b/dMIAAAAAAAAA&bo=8gMUAgAAAAADN*U!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/N17NpFmhtNQeYlB2ZPgzg9d7VE9mhnLkluLBJ5.I1.k!/b/dDcBAAAAAAAA&bo=nwYJBAAAAAADF6Y!&rf=viewer_4&t=5"><br>北京的租房房源一共有19068条，可以看到北京的房源主要集中在2环到四环内，其中朝阳区的房源最多，几乎占到北京所有房源的1&#x2F;3，丰台、海淀次之。</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/u6dXz3a7Rc38QFi3.iilLnLm2yam*ryEfoqC0.dcO2g!/b/dL8AAAAAAAAA&bo=*AMUAgAAAAADN*s!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/Tyb*OkGycyZoa01js2At1JJ5Xk4hxAhObm78Jr2G*10!/b/dFMBAAAAAAAA&bo=NgYJBAAAAAADFw8!&rf=viewer_4&t=5"><br>上海房源数据一共有26115条，浦东占到快7000条，比例接近1&#x2F;4，在偏远地区金山崇明基本看不到房源。</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/*cYulEBdxoe7qDj1nIezaBH5zPxv0wx1NWBnYhPZPcg!/b/dDcBAAAAAAAA&bo=AQRAAgAAAAADN1U!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/OwnbF0sPPq2VGAxPSIIS9RdqSI4XkUVuAdwXkX.VVcs!/b/dMAAAAAAAAAA&bo=IgYJBAAAAAADFxs!&rf=viewer_4&t=5"><br>广州的房源在四个城市中是最多的，一共有40022条。主要集中在天河、白云、番禺、增城以及珠海地区。其中天河、白云、番禺均超过7000条。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/DZb6Jn4M.Wee3Cnt8P9ynH8PqikNrJQbofhykaG.KyE!/b/dLkAAAAAAAAA&bo=dgYJBAAAAAADF08!&rf=viewer_4&t=5"><br>深圳的房源共21638条，主要还是分布在南山区、龙岗区、宝安区以及福田区，龙华区。</p><h4 id="2-城市各区域的租金分布怎么样"><a href="#2-城市各区域的租金分布怎么样" class="headerlink" title="2.城市各区域的租金分布怎么样"></a>2.城市各区域的租金分布怎么样</h4><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/IOTmJbo1ouIDk*uRqQhf7pCU*uNIDqWcS1GPC57aCCk!/b/dMAAAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br>由图，北京每平方米租金top10的商圈，平均在200元左右，最贵的商圈在东单，每平方米要237元，也就是说要在东单住一个20平的房子，一个月需要4770元，组一个70平的房子，需要16590元.<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/L6U2bjCbvJGW6*qCRBIfD9yvKu4pHmXRXXZDPgrJdAw!/b/dLYAAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5_"><br>上海每平方米平均租金top10的商区租金要比北京低一点，平均在170左右，其中租金最高的是新天地，租60平的房子需要10610元。</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/EtfpprPfUAn76SDpcuo9ZQT*ZLNIBj9C4*T66XAg*gk!/b/dLYAAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br>相比较北京和上海而言广州的每平方米租金的top10就更平易近人一点，除了二沙岛、人民北的房租贵一点，其他均在1500以下。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/c6ci3ypvMrqS0JNYoZPSP.aZUxxlOJA9NcuDruTtiws!/b/dL8AAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br>深圳前10的商圈，深圳湾以193元每平方米领先，其次是香蜜湖和福田中心，大体上比上海每平方米少10元左右。</p><h4 id="3-房间大小对每平方米租金的影响"><a href="#3-房间大小对每平方米租金的影响" class="headerlink" title="3.房间大小对每平方米租金的影响"></a>3.房间大小对每平方米租金的影响</h4><p>北京<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/OG6kfRxwy2bGO1sV9Jcq4AeeW0Q3.8JJs7AAlePgoJA!/b/dMMAAAAAAAAA&bo=HAJvAQAAAAADF0I!&rf=viewer_4&t=5" alt="北京"><br>上海<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/GFde9NUrcISX3FCr*coiDFLrieKjKXVJqL*2uSOPUKw!/b/dLkAAAAAAAAA&bo=HAJvAQAAAAADF0I!&rf=viewer_4&t=5"><br>广州<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/jR3GLleCUyBlYnwkwwpncpu6PcrgSNp65jXZdY5uVCU!/b/dL8AAAAAAAAA&bo=HAJvAQAAAAADF0I!&rf=viewer_4&t=5"><br>深圳<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/cTalbuRWBs1YzeyImh3xlmyUXNkIr3rszDx6YT98ios!/b/dL8AAAAAAAAA&bo=HAJvAQAAAAADF0I!&rf=viewer_4&t=5"><br>由上面4张图可以知道不管在哪个城市，出租面积在10-20之间的房子每平方米的租金是最贵的。所以最划算的租房方式是找几个认识的小伙伴一起租大一点的房子。</p><h4 id="4-北上广深租房时房客更看重什么？"><a href="#4-北上广深租房时房客更看重什么？" class="headerlink" title="4.北上广深租房时房客更看重什么？"></a>4.北上广深租房时房客更看重什么？</h4><p>以下是北上广深四大城市房源最多的3种户型<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/S6KSz8Q5oZvvsTPEcHY*J6YzWkiYOHJU7ktlMbWZEtU!/b/dLgAAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/OQFaF0tIYMFX3vv*O3zV35NG8xq8t9F6E1G6GIFdvA8!/b/dLYAAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/spKDaHx2gWRWkm3XWBTeaGp8dnlwcaG.Wc4KwUEcK14!/b/dMMAAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/OzlBub6076*dDI5Y71EtgCz4mZ1AS227jKIPIGA6Mpg!/b/dL4AAAAAAAAA&bo=WAKQAQAAAAADF*k!&rf=viewer_4&t=5"><br>可见北上广都偏爱2室1厅1卫的房子，而深圳一枝独秀，一室一卫的出租房比较多。整体来看四个城市都是小户型多。<br>最后根据房屋的标签进行统计，绘制了词云图。</p><p>北京租房词云图<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/16XgV.RpRZJf.FeZruq6aeVR3XegzICXmUhbNSNqUQA!/b/dFMBAAAAAAAA&bo=6ANsAgAAAAADF7c!&rf=viewer_4&t=5"><br>上海租房词云图<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/sLW7BFrXPXrGkgB1XQnQqjbpOp1YJxa0C6FcS.2CgEE!/b/dLkAAAAAAAAA&bo=6ANsAgAAAAADF7c!&rf=viewer_4&t=5"><br>广州租房词云图<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/CaadOj9Z*JRYYqdISpyoCifbYNlE.hWp6Y*BvAK7l2k!/b/dLYAAAAAAAAA&bo=6ANsAgAAAAADF7c!&rf=viewer_4&t=5"><br>深圳租房词云图<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/ynkJmSqSxlHwWQPnQhLC300HQxY.JgwnEnwvbV4E8gI!/b/dFQBAAAAAAAA&bo=6ANsAgAAAAADF7c!&rf=viewer_4&t=5"><br>可见北京不集中供暖可能会活不下去，hhhhhhh；<br>北上广深都看中离地铁近；<br>广州租房流行独栋公寓；<br>深圳、广州对租客性别有限制。</p><p>想要以上涉及到的源代码可以联系我<br>邮箱:<a href="mailto:&#121;&#x75;&#116;&#105;&#110;&#x67;&#57;&#53;&#57;&#55;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;">&#121;&#x75;&#116;&#105;&#110;&#x67;&#57;&#53;&#57;&#55;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;</a></p><p>参考文章：<br>公众号：Alfred数据室<br><a href="http://mp.weixin.qq.com/s?__biz=MzIyMDExNjE0Mg==&mid=2247483899&idx=1&sn=65252ed83b6040849ff35e4d7894f178&chksm=97d1a43aa0a62d2cdfea824ffe1a6dd0c8ac4e63b6a0e9646e5f5d8cb874f42c32cbd22ec165&mpshare=1&scene=23&srcid=0323DJGmpLoSbKuF1Ijqec46#rd">北上广深租房图鉴</a></p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Data Analysis</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建自己的投资理财体系(1.了解各种投资品)</title>
    <link href="/2019/03/17/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E4%BD%93%E7%B3%BB-1.%E4%BA%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%8A%95%E8%B5%84/"/>
    <url>/2019/03/17/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E4%BD%93%E7%B3%BB-1.%E4%BA%86%E8%A7%A3%E5%90%84%E7%A7%8D%E6%8A%95%E8%B5%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一-培养理财意识"><a href="#一-培养理财意识" class="headerlink" title="一.培养理财意识"></a>一.培养理财意识</h3><p>   如果你问有什么技能是越早开始学习越好的，那投资理财一定算一项。因为越早开始享受复利的魔力越大。投资理财是在大学里面学不到的一门学问，但却又是越早学习越好的技能。</p><p> 下面给大家看一张图，体会一下复利的魔力。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/grdO*7KalE3kSDIqutCBRnfrtQXbxC7v3j3OewWKlow!/b/dFYBAAAAAAAA&bo=9AGJAQAAAAARF10!&rf=viewer_4&t=5"><br>50年后，从图中可以看到单利和复利在财富上的巨大分野。巴菲特老爷爷曾经说过复利是世界第八大奇迹。<br><strong>That compound interest was the 8th Wonder of the World or something like that.</strong></p><p>所以理财是越早开始越好的，接下来看看复利的公式</p><ul><li>最终收益&#x3D; 本金* （1+ 收益率）^ 时间</li></ul><p>如果你还是大学生，或者刚毕业本金不够多，没关系我们开始时间早啊，赢在了时间上。然后再想办法让自己的本金变多，怎么让自己本金变多，积累第一笔资金的方法就是<strong>开源节流</strong>。在节流上：分清必要，需要，想要，在需要和想要上做减法。在开源上：可以去做做兼职，大学生嘛什么都不多就是时间多，但是在找兼职上也尽量找一些能提升自己能力的兼职。</p><p>看到这里大家应该都是有学习投资理财的意识的，很好这是开始学习的很重要的一步，在我去年刚开始学习投资理财的时候，有一个小伙伴说了这么一句话，**“在别人眼里看来改变旧观念就像传销一样，而我心甘情愿被理财传销”**。我最开始想要学习投资理财是因为，感觉每年过年回家然后再回上海，虽然新年伊始，但是你都几乎可以把年底你能赚的钱算死。这种感觉很可怕，不想生活就这么一眼可以看到头，这是我学习理财的初衷。</p><h4 id="时间的量化思维"><a href="#时间的量化思维" class="headerlink" title="时间的量化思维"></a>时间的量化思维</h4><p><strong>理财不仅是投资这么狭隘，更多的还有思维的建立。</strong><br>我们在日常生活中，对于开销的理解，多以金钱来量化，很少有人会把时间也计算在内，大多数人在工作和生活中，更多地注意金钱，而很少注意“时间”。有一则小故事讲的是，某位富翁不小心掉了几百美元，路人见状后告知，谁知他头也不回的走了，因为他心里在盘算，在弯腰把几百美元捡起来的这几秒钟时间里，他能赚到更多的钱。富人的财产可以高出普通人数千万倍，但其拥有的时间却无法高出普通人一倍。我们应该下意识的培养时间的量化思维，尽量花时间去武装大脑，而不是为了节约开支而浪费大把时间。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="分清资产和负债"><a href="#分清资产和负债" class="headerlink" title="分清资产和负债"></a>分清资产和负债</h4><p>穷人为什么穷？因为他们不断地买入负债或没有可持续利用价值的东西.<br>富人的第一个秘密：资产品种丰富，给自己带来更多收入，不用单一依靠工资！相对应的穷人的死穴：就是毫无任何资产可言！生活的唯一的经济支柱就是工资！什么是资产，什么是负债。《富爸爸和穷爸爸》里说过<br>资产就是能把钱放进你口袋里的东西，它能给你不断带来收入，而负债则是把钱从你口袋里取走的东西。我们应该尽量增加资产，减少负债。</p><h3 id="二-了解各种投资品及其风险"><a href="#二-了解各种投资品及其风险" class="headerlink" title="二.了解各种投资品及其风险"></a>二.了解各种投资品及其风险</h3><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/RdN7zRIpuSCik.TyJmhg0oLxsYl*qNBgwl8Ze8*iujs!/b/dL4AAAAAAAAA&bo=jASfAgAAAAARFzU!&rf=viewer_4&t=5"><br>这张投资金字塔图我觉得蛮经典的，列举了市面上常见的各种投资品，从金字塔的底部到金字塔顶部，越往上走风险越高。我们存在银行里的活期存款其实也算是一种投资方式，只是回报率很少而已。</p><p>下面来详细说明一下常见的投资品以及它们的特点：<br>首先从风险低的<strong>货币基金</strong>说起，说到货币基金可能大家很陌生，但是说到余额宝大家肯定都知道。余额宝就是货币基金的一种，它的运作方式是由基金公司把散户的钱集中起来，拿去做无风险的投资，买银行的大额存单或者定期存款什么的。但这厮因为拿到的钱多，就可以和银行叫板，自行商定利率，拿到更高的利息。这也是为什么比活期存款利息高的原因。除了大部分用来投资银行存款外，基金公司也会投资债券，票据之类的，投资方向都是很安全的。</p><p><strong>国债逆回购</strong><br>其实说白了就是借钱给别人，是一种短期贷款。个人把自己的资金借出去，获得固定的利息收益。借款人（一般都是大企业）用自己的国债（或达到一定评级的债券）作为抵押获得这笔借款，到期后还本付息。当市场缺钱（银行系统冲业绩、企业公司短期拆借）的时候，企业就会在各种渠道通过高额利息来借钱，国债逆回购就是其中一个渠道。年末季末月末，国债逆回购利率都会比较高。因为在你和借款人之间，既有债券的抵押，中间还有中国证券登记结算有限公司在监督管理，如果借款人还不出来钱，中登公司会帮你把钱要回来；<br><strong>所以它的特点是:安全，永不亏本.</strong><br>国债逆回购的品种一共有 18 种，沪、深两市各 9 种,沪市为国债逆回购，深市为企业债逆回购,上交所购买的品种，10w元起买，只有少量资金的就不适合沪市啦，深交所回购产品1000元起购。券商app里都可购买，参与国债逆回购的前提必须要开户。</p><p><strong>债券</strong>根据借款主体的不同可以分为国债、地方政府债、企业债。也就是国家、地方政府和企业向人民群众借钱，约定一个日期还本付息，自然而然风险也就低了，风险低，利息也就相应低一些了。一般债券收益率在5%-7%之间</p><p><strong>基金</strong>稍微有了解一点的就知道，基金分为货币基金，债券基金，混合基金和股票基金。其中<strong>货币基金</strong>和<strong>债券基金</strong>的篮子里面都是装的国债、地方政府债、公司债等，只不过不同点在于债券基金除了投资债券还可以投资股票，但是债券的占比必须要在80%以上。除了投资债券的比例不同，年限也不同，货币基金投资的一般是1年以内的短期债券，而债券基金则一般是1年以上的债券。<strong>股票基金</strong>因为投资股票的占比在80%以上，所以风险也是最高的。其中股票基金又包含被动投资的指数基金和主动性的主动股票基金，相当于是一篮子股票，有专业人士基金经理帮忙打理。<strong>指数基金</strong>是指追踪特定的指数，并按照这个指数成分股的比例买入同样的股票组合。在A股市场一共有5只主要的指数，</p><ul><li>上证50(由沪市规模大、流动性好的最具代表性的50只股票组成），</li><li>沪深300(由上海和深圳两个交易所所挑选出来的市值排名前300的上市公司组成)</li><li>中证500(沪深两市前800的上市公司中，前500入了沪深300，剩下的500家就组成了中证500指数）</li><li>创业板指数(专门在创业板上市的小型创业公司组成)</li><li>红利指数(由高分红的企业组成的指数)</li></ul><p><strong>股票</strong>这里举一个非常简化的例子帮助理解股票的本质，假设小明开了一家饼干店需要30万，但是钱不够还差10万，于是他来找你借钱，但是把这钱你说不用还，但是以后饼干店赚了钱三分之一的利润是我的。买了一家公司的股票你就成了这家公司的股东，能不能赚到钱，取决于这家公司的经营状况。</p><p><strong>P2P</strong> 就是民间借贷，银行借款的标准较高，所以催生出了个人借钱给个人的P2P。P2P平台就是小额资金直接融资的交易场所，但是由于目前征信系统不完善，去年就听到很多P2P公司跑路的新闻。所以对于这类产品能不碰就不碰。</p><p><strong>外汇 、期货 、贵金属 、实物收藏品</strong>这些都是风险极其高的产品，不懂行的人就不要轻易碰啦。</p><h3 id="三-培养自己的投资理财体系"><a href="#三-培养自己的投资理财体系" class="headerlink" title="三.培养自己的投资理财体系"></a>三.培养自己的投资理财体系</h3><h5 id="资产配置"><a href="#资产配置" class="headerlink" title="资产配置"></a>资产配置</h5><p>了解常见的投资品后，后期还需要在学习和实践中提炼一套适合自己的投资理财体系，首先涉及到资产配置。在这方面有一个著名的资产配置的方法就是标准普尔家庭配置象限图.<img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/qCXfz*iH4jtvXT.o9QphIOcOL7o1t5tovAqkabAbiW0!/b/dLkAAAAAAAAA&bo=8gHRAAAAAAADFxA!&rf=viewer_4&t=5"><br>在这张图上，把钱的用途分成了四份</p><ul><li>1.短期消费<br>这一部分钱用来作为短期消费，平时吃饭逛街买衣服看电影，偶尔出去旅行一次，买书学习等等，钱都从这里出，一般占家庭资产的 <strong>10%</strong>,它最大的要点：满足我们的短期消费。另外预留 3-6 个月的生活费作为应急金、梦想相册基金、短期内需要用到的钱</li><li>2.意外重疾保障<br>这个账户保障突发大额开销，一定要专款专用，保障在家庭成员出现意外事故、重大疾病时，有足够的钱来保命,一般占家庭资产的 **20%**，为的是以小博大</li><li>3.保本升值<br>也是长期收益账户。一般占家庭资产的 **40%**，为保障家庭成员的养老金、子女教育金、留给子女的钱等。这个账户重点是保本升值，一定要保证本金不能有损失，并要抵御通货膨胀的侵蚀，所以收益不一定很高，但却是长期稳定的。第四个账户其实很适合基金定投之类的投资，这就是一个很好的储蓄方式</li><li>4.重在收益<br>这个账户为家庭创造高收益，往往是通过你的智慧，用你最擅长的方式为家庭赚钱，包括你投资的股票、主动型基金、房产等,一般占家庭资产的 **30%**。通过投资来为家庭创造收益，用有风险的投资创造高回报。</li></ul><h5 id="股票投资流派"><a href="#股票投资流派" class="headerlink" title="股票投资流派"></a>股票投资流派</h5><p>做好了资产配置，你就需要找到自己的投资流派，你很多时候会听到周围人说我是投机者，股市行情好的时候，投机者跟着股市上涨的势头，炒一波短线，赚一波块钱，但这很容易踏空，因为股市不可预测，一不小心就买在了山顶。<br>我更倾向于价值投资，股市说到底是<strong>什么时候买，什么时候卖，买什么</strong>三件事情。买在相对低点，卖在相对高点。而价值投资对于资产的估值让我更清楚在低估的时候买，在高估的时候卖。短期来看，股价是由供求决定的。但长期来看，是由它的内在价值决定的。<br>那么<strong>价值投资赚的是谁的钱</strong>,这里有一个公式：<br>资产的收益 &#x3D; 胀 通货膨胀 + 出 自身产出 +  价格的波动<br>价值投资者赚的就是以上三部分的钱，一是央行放水的钱。二是优秀上市公司发展盈利带来的钱。三就是割韭菜的钱。</p><ul><li>央行放水。导致大量的钱涌入股市，助推股价高涨，通常发生在降息周期。同时央行放水，导致通货膨胀，最终导致资产价格的上涨。所以对抗通胀最好的办法是买入资产。</li><li>优秀上市公司发展盈利带来的钱。这个也很好理解。企业盈利之后的分红，公司净资产增加导致的股价上涨都是这部分钱。</li><li>格雷厄姆把股市比作市场先生，市场先生一会情绪高涨，一会情绪低落，反映到股价上，就是牛熊市的转换。正是因为市场的波动，给了价值投资者在低估时买入和高估时卖出的机会，从而取得超额收益。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>1.培养理财意识</strong><br>复利是世界第八大奇迹，理财越早开始，越能享受复利的魔力<br><strong>2.了解各种投资品及其风险</strong><br>货币基金、国债逆回购、债券、基金、股票、外汇、期货、贵金属风险从低到高<br><strong>3.培养自己的投资理财体系</strong><br>做好资产配置，做投资前一定想清楚其中的底层逻辑。买股票就是买入一家公司成为它的股东，搞清楚买什么？什么时候买？以及什么时候卖？</p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>life - 投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《流浪地球》电影评论的爬取和分析</title>
    <link href="/2019/03/09/%E3%80%8A%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83%E3%80%8B%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA%E7%9A%84%E7%88%AC%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <url>/2019/03/09/%E3%80%8A%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83%E3%80%8B%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA%E7%9A%84%E7%88%AC%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本文在猫眼电影上爬取了《流浪地球》的上万评论,并对其评论进行分析</p><h3 id="爬虫-爬取数据"><a href="#爬虫-爬取数据" class="headerlink" title="爬虫-爬取数据"></a>爬虫-爬取数据</h3><h4 id="找到评论网页地址"><a href="#找到评论网页地址" class="headerlink" title="找到评论网页地址"></a>找到评论网页地址</h4><p>先打开猫眼官网找到《流浪地球》的介绍页面：<a href="https://maoyan.com/films/248906">https://maoyan.com/films/248906</a><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/DlzZZcnQmJlcg**2UJdVofzhw1drFquhmgZJnbTisuM!/b/dFIBAAAAAAAA&bo=ZwPdAQAAAAADJ7o!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><ul><li>打开开发者工具</li><li>转换成手机浏览(因为网页版的评论数据只显示部分短评)<br>点击红色箭头指向的位置，然后按F12键刷新，这时候我们就可以看到所有评论了<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/JRF2hjEvkSVM1lW8xlO5RUgFLHO1pGd2.PrJGm8oDog!/b/dDUBAAAAAAAA&bo=ywPFAQAAAAADFz4!&rf=viewer_4&t=5" alt="在这里插入图片描述"><h4 id="获取评论请求地址"><a href="#获取评论请求地址" class="headerlink" title="获取评论请求地址"></a>获取评论请求地址</h4>在点击打开“查看全部533685条讨论”后，屏幕上的评论往下拉，会发现浏览器的网络展示中会不断加载新页面，网络请求多出来了comments.json的请求：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/t4bi2nk3sPPDCunbWpdBJSGco4pUaYEYjCC.RMMQjo0!/b/dL4AAAAAAAAA&bo=DQNIAgAAAAADF3Y!&rf=viewer_4&t=5"></li></ul><p>复制出几个comments.json页面的URL做比较寻找规律</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://m.maoyan.com/review/v2/comments.json?movieId=<span class="hljs-number">248906</span>&amp;userId=-<span class="hljs-number">1</span>&amp;offset=<span class="hljs-number">0</span>&amp;limit=<span class="hljs-number">15</span>&amp;ts=<span class="hljs-number">0</span>&amp;level=<span class="hljs-number">2</span>&amp;type=<span class="hljs-number">3</span><br><span class="hljs-attribute">http</span>://m.maoyan.com/review/v2/comments.json?movieId=<span class="hljs-number">248906</span>&amp;userId=-<span class="hljs-number">1</span>&amp;offset=<span class="hljs-number">15</span>&amp;limit=<span class="hljs-number">15</span>&amp;ts=<span class="hljs-number">1552143388614</span>&amp;level=<span class="hljs-number">2</span>&amp;type=<span class="hljs-number">3</span><br><span class="hljs-attribute">http</span>://m.maoyan.com/review/v2/comments.json?movieId=<span class="hljs-number">248906</span>&amp;userId=-<span class="hljs-number">1</span>&amp;offset=<span class="hljs-number">30</span>&amp;limit=<span class="hljs-number">15</span>&amp;ts=<span class="hljs-number">1552143388614</span>&amp;level=<span class="hljs-number">2</span>&amp;type=<span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><p>可以发现规律：</p><ul><li>初始页面的ts值为0,随后会有ts值，且保持不变。这里的ts是当前的时间戳,看、可以用如下代码查看</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#coding:UTF-8</span><br>import <span class="hljs-keyword">time</span><br><span class="hljs-comment">#毫秒转换成秒</span><br>timeStamp = <span class="hljs-keyword">int</span>(<span class="hljs-number">1552143388614</span>/<span class="hljs-number">1000</span>)<br><span class="hljs-comment">#转换成localtime</span><br>localTime = time.localtime(timeStamp)<br><span class="hljs-comment">#转换成新的时间格式(2017-09-16 11:28:54)</span><br>strTime = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, localTime)<br><span class="hljs-keyword">print</span>(strTime)<br></code></pre></td></tr></table></figure><ul><li>offset是请求评论开始的序号，limit为请求的条数</li></ul><p>再看返回的json结果：</p><ul><li>data.comments中是评论的具体内容</li><li>paging中通过hasMore来告诉我们是否还有更多（判断是否继续抓取）</li></ul><p><strong>构造请求url 方法一</strong></p><p>根据上面的分析，我们构造请求的url就很明确了：</p><ul><li>从offset&#x3D;0&amp;limit&#x3D;15开始</li><li>通过返回的paging.hasMore来判断是否继续抓取</li><li>下一个抓取的url中offset+&#x3D;limit</li></ul><p><strong>只能抓取1000条？！</strong></p><p>根据上述分析，在返回的json数据中是可以看到总评论数的，但是实际抓取的时候，在offset超过1000之后，返回的数据中hasMore就变成了false。</p><p>于是尝试通过浏览器一直下拉刷新，到达offset超过1000的情况，发现页面会不停的发送请求，但也无法获取数据。</p><p>那应该就是网站做了控制，不允许offset超过1000。</p><p><strong>构造请求URL 方法二</strong></p><p>那么就要考虑其他构造url的方法来抓取了。先观察下每个请求返回的信息：</p><p>发现每个comment里都包含有一个time信息，可以发现后台是按照时间顺序的，每分钟一个间隔，那么就可以考虑根据每次返回comment中的时间来更新url中的ts即可。</p><p>由于不确定每次请求返回的数据中包含了多长的时间段，且返回的第一个评论时间戳与第二个评论是不同的，所以抓取思路如下：</p><ul><li>获取请求数据</li><li>记录第一个时间戳</li><li>记录第二个时间戳</li><li>当遇到第三个时间戳时，将ts设置为第二个时间戳，重新构造url</li><li>如果单次抓取中每遇到第三个时间戳，则通过修改offset来继续抓取，直到遇到第三个时间戳</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vim">def parse_json(data):<br>    <span class="hljs-keyword">global</span> <span class="hljs-built_in">count</span><br>    <span class="hljs-keyword">global</span> offset<br>    <span class="hljs-keyword">global</span> limit<br>    <span class="hljs-keyword">global</span> <span class="hljs-keyword">ts</span><br>    ts_duration = <span class="hljs-keyword">ts</span><br>    <span class="hljs-keyword">res</span> = json.loads(data)<br>    comments = <span class="hljs-keyword">res</span>[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;comments&#x27;</span>]<br>    <span class="hljs-keyword">for</span> comment in comments:<br>        comment_time = comment[<span class="hljs-string">&#x27;time&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">ts</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">ts</span> = comment_time<br>            ts_duration = comment_time<br>        <span class="hljs-keyword">if</span> comment_time != <span class="hljs-keyword">ts</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">ts</span> == ts_duration:<br>            ts_duration = comment_time<br>        <span class="hljs-keyword">if</span> comment_time !=ts_duration:<br>            <span class="hljs-keyword">ts</span> = ts_duration<br>            offset = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> get_url()<br>        <span class="hljs-keyword">else</span>:<br>            content = comment[<span class="hljs-string">&#x27;content&#x27;</span>].strip().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;。&#x27;</span>)<br>            <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;get comment &#x27;</span> + str(<span class="hljs-built_in">count</span>))<br>            <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span><br>            write_txt(time.<span class="hljs-built_in">strftime</span>(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,time.<span class="hljs-built_in">localtime</span>(comment_time/<span class="hljs-number">1000</span>)) + <span class="hljs-string">&#x27;##&#x27;</span> + content + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">res</span>[<span class="hljs-string">&#x27;paging&#x27;</span>][<span class="hljs-string">&#x27;hasMore&#x27;</span>]:<br>        offset += limit<br>        <span class="hljs-keyword">return</span> get_url()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> None<br></code></pre></td></tr></table></figure><p>这里贴出另一个思路完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-comment"># 导入爬虫所需工具库</span><br><span class="hljs-keyword">import</span> time,  random<br><span class="hljs-keyword">import</span> datetime <span class="hljs-keyword">as</span> dt<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 8个备用user_agents</span><br>user_agents = [<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22;\</span><br><span class="hljs-string">            CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 \</span><br><span class="hljs-string">            (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5;\</span><br><span class="hljs-string">            Trident/5.0; IEMobile/9.0; HTC; Titan)&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019;\</span><br><span class="hljs-string">            Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) \</span><br><span class="hljs-string">            AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us)\</span><br><span class="hljs-string">            AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) \</span><br><span class="hljs-string">            AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91)\</span><br><span class="hljs-string">            AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&#x27;</span>&#125;,<br>]<br><span class="hljs-comment"># 创建爬虫类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieSpider</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filename</span>):<br>        self.headers = user_agents<br>        self.filename = filename<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self, header, url</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        功能：访问url的网址，获取网页内容并返回</span><br><span class="hljs-string">        参数：url,目标网页的url</span><br><span class="hljs-string">        返回：目标网页的html内容</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            r = requests.get(url, headers=header)<br>            r.raise_for_status()<br>            <span class="hljs-keyword">return</span> r.text<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(e)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_data</span>(<span class="hljs-params">self, html</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        功能：提取 html 页面信息中的关键信息，并整合一个数组并返回</span><br><span class="hljs-string">        参数：html 根据 url 获取到的网页内容</span><br><span class="hljs-string">        返回：存储有 html 中提取出的关键信息的数组</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        json_data = json.loads(html)[<span class="hljs-string">&#x27;cmts&#x27;</span>]<br>        comments = []<br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> json_data:<br>                comment = []<br>                <span class="hljs-comment"># 提取影评中的6条数据：nickName(昵称),cityName(城市),content(评语)，</span><br>                <span class="hljs-comment"># score(评分),startTime(评价时间),gender(性别)</span><br>                comment.append(item[<span class="hljs-string">&#x27;nickName&#x27;</span>])<br>                comment.append(item[<span class="hljs-string">&#x27;cityName&#x27;</span>] <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;cityName&#x27;</span> <span class="hljs-keyword">in</span> item <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;&#x27;</span>)<br>                comment.append(item[<span class="hljs-string">&#x27;content&#x27;</span>].strip().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>                comment.append(item[<span class="hljs-string">&#x27;score&#x27;</span>])<br>                comment.append(item[<span class="hljs-string">&#x27;startTime&#x27;</span>])<br>                comment.append(item[<span class="hljs-string">&#x27;gender&#x27;</span>] <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;gender&#x27;</span> <span class="hljs-keyword">in</span> item <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;&#x27;</span>)<br>                comment.append(item[<span class="hljs-string">&#x27;userLevel&#x27;</span>] <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;userLevel&#x27;</span> <span class="hljs-keyword">in</span> item <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;&#x27;</span>)<br>                comment.append(item[<span class="hljs-string">&#x27;userId&#x27;</span>] <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;userId&#x27;</span> <span class="hljs-keyword">in</span> item <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;&#x27;</span>)<br><br>                comments.append(comment)<br><br>            <span class="hljs-keyword">return</span> comments<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(comment)<br>            <span class="hljs-built_in">print</span>(e)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_data</span>(<span class="hljs-params">self, comments</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        功能：将comments中的信息输出到文件中/或数据库中。</span><br><span class="hljs-string">        参数：comments 将要保存的数据</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        df = pd.DataFrame(comments)<br>        df.to_csv(self.filename, mode=<span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf_8_sig&#x27;</span>,<br>                  index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, header=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, time_lists</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        功能：爬虫调度器，根据规则每次生成一个新的请求 url，爬取其内容，并保存到本地。</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment">#         start_time = dt.datetime.now().strftime(&#x27;%Y-%m-%d  %H:%M:%S&#x27;)</span><br>        start_time = time_lists[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 电影上映时间，评论爬取到此截至</span><br>        end_time = time_lists[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 电影上映时间，评论爬取到此截至</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*******************&#x27;</span>)<br><br>        <span class="hljs-comment"># 抓取评论信息</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> start_time &gt; end_time:<br>            i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;已爬取%s页评论&#x27;</span> % i)<br>            url = <span class="hljs-string">&#x27;http://m.maoyan.com/mmdb/comments/movie/248906.json?_v_=            yes&amp;offset=0&amp;startTime=&#x27;</span> + start_time.replace(<br>                <span class="hljs-string">&#x27;  &#x27;</span>, <span class="hljs-string">&#x27;%20&#x27;</span>)<br>            header = random.choice(self.headers)<br>            time.sleep(<span class="hljs-number">0.05</span>)<br>            html = <span class="hljs-literal">None</span><br><br>            <span class="hljs-keyword">try</span>:<br>                html = self.get_data(header, url)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*************************&#x27;</span>)<br>                time.sleep(<span class="hljs-number">0.83</span>)<br>                html = self.get_data(url)<br>                <span class="hljs-built_in">print</span>(e)<br><br>            <span class="hljs-keyword">else</span>:<br>                time.sleep(<span class="hljs-number">0.3</span>)<br><br>            <span class="hljs-comment"># 解析评论信息</span><br>            comments = self.parse_data(html)<br>            start_time = comments[<span class="hljs-number">14</span>][<span class="hljs-number">4</span>]<br><br>            start_time = dt.datetime.strptime(<br>                start_time, <span class="hljs-string">&#x27;%Y-%m-%d  %H:%M:%S&#x27;</span>) + dt.timedelta(seconds=-<span class="hljs-number">1</span>)<br>            start_time = dt.datetime.strftime(start_time, <span class="hljs-string">&#x27;%Y-%m-%d  %H:%M:%S&#x27;</span>)<br><br>            self.save_data(comments)<br><br><span class="hljs-comment"># 通过改变时间点，选择爬取信息所处的时间段</span><br>t1 = [<span class="hljs-string">&#x27;2019-02-12  18:59:59&#x27;</span>, <span class="hljs-string">&#x27;2019-02-05  00:00:00&#x27;</span>]<br>time_lists = t1<br>filename = <span class="hljs-string">&#x27;流浪地球%s_comments.csv&#x27;</span> % time_lists[<span class="hljs-number">1</span>].split()[<span class="hljs-number">0</span>]<br>spider = MovieSpider(filename)<br>spider.run(time_lists)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;爬取信息结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><ul><li>读取数据<br>前面已经将评论的时间和内容通过<code>csv</code>的格式保存下来，并使用<code>;</code>分割。这里我们将使用<code>pandas</code>读取<code>csv</code>并进行统计处理</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-class"><span class="hljs-keyword">data</span> = pd.read_csv(&#x27;./<span class="hljs-title">data</span>.<span class="hljs-title">csv&#x27;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">data</span>.info()</span><br></code></pre></td></tr></table></figure><ul><li><p>数据详情<br>共有102580条数据；<br>包含字段：<br>评论内容、性别、评论ID、评论者昵称、回复数量、评分、时间、点赞数量、评论者ID、评论者等级</p></li><li><p>清理数据</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 删除无用数据</span><br><span class="hljs-keyword">data</span> = data.dropna(axis = <span class="hljs-number">0</span>, how = <span class="hljs-string">&quot;any&quot;</span>)<br><span class="hljs-comment"># 删除重复评论</span><br><span class="hljs-keyword">data</span> = data.drop_duplicates(subset=<span class="hljs-string">&#x27;content&#x27;</span>)<br><span class="hljs-comment"># 将本来是object类型的time，转换成时间类型</span><br><span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;time&#x27;</span>] = pd.to_datetime(<span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;time&#x27;</span>],format=<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br><span class="hljs-comment"># 日期筛选为上映后的日期</span><br><span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>[<span class="hljs-type">data</span>[<span class="hljs-string">&#x27;time&#x27;</span>]&gt;=<span class="hljs-type">pd.to_datetime</span>(<span class="hljs-string">&#x27;2019-02-05 00:00:00&#x27;</span>)]<br><span class="hljs-comment"># 将时间设置为index</span><br>data.set_index(<span class="hljs-keyword">data</span>[<span class="hljs-string">&#x27;time&#x27;</span>],inplace=True)<br></code></pre></td></tr></table></figure></li><li><p>分析问题<br>1.总体评价如何？<br>2.总体评价的时间走向如何？<br>3.高分的评价理由是什么？<br>4.低分的评价理由是什么？<br>5.低分的人群有哪些特征？（性别、等级）<br>6.低分跟哪位演员有关？</p></li></ul><p> <strong>总体评价如何？</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pyecharts import Bar<br><span class="hljs-keyword">from</span> pyecharts import Overlap<br><span class="hljs-keyword">from</span> pyecharts import Line<br><br>score_total = data[<span class="hljs-string">&#x27;score&#x27;</span>].value_counts().sort_index()<br>bar = Bar(<span class="hljs-string">&#x27;《流浪地球》各评分数量&#x27;</span>,<span class="hljs-attribute">width</span>=700)<br>overlap = Overlap(<span class="hljs-attribute">width</span>=700)<br>bar.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;&quot;</span>, score_total.index, score_total.values, <span class="hljs-attribute">is_label_show</span>=<span class="hljs-literal">True</span>,<br>       <span class="hljs-attribute">bar_category_gap</span>=<span class="hljs-string">&#x27;40%&#x27;</span>, label_color = [<span class="hljs-string">&#x27;#130f40&#x27;</span>],<br>       <span class="hljs-attribute">legend_text_size</span>=18,xaxis_label_textsize=18,yaxis_label_textsize=18)<br>line = Line(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attribute">width</span>=700)<br>line.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;&quot;</span>,score_total.index, score_total.values+500,<span class="hljs-attribute">is_smooth</span>=<span class="hljs-literal">True</span>)<br>overlap.<span class="hljs-built_in">add</span>(bar)<br>overlap.<span class="hljs-built_in">add</span>(line)<br>overlap<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/cpKS154bQyeLY02bQ96*Ib6SRAy1z1xyKt0XBlHR6Zg!/b/dFMBAAAAAAAA&bo=vAKQAQAAAAADFx0!&rf=viewer_4&t=5" alt="在这里插入图片描述"><br> 低分占比</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 低分占比 &lt;5</span><br><span class="hljs-attribute">score_total</span>[:<span class="hljs-number">5</span>].sum()/score_total.sum()*<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>高分占比 8</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 高分占比 8</span><br><span class="hljs-attribute">score_total</span>[<span class="hljs-number">8</span>:].sum()/score_total.sum()*<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>满分占比</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 满分占比</span><br><span class="hljs-attribute">score_total</span>[<span class="hljs-number">10</span>:].sum()/score_total.sum()*<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>通过上述分析计算，高分占比达到90%以上，满分占比也高达70%以上，可以看出《流浪地球》整体评分很高</p><p><strong>高分的评价理由是什么？</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import jieba<br><span class="hljs-keyword">from</span> collections import Counter<br><span class="hljs-keyword">from</span> pyecharts import WordCloud<br><br><span class="hljs-comment"># 比较偏的就不可以被正确分词了 add_word函数提供了解决方法</span><br>jieba.add_word(<span class="hljs-string">&#x27;屈楚萧&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;刘启&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;吴京&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;刘培强&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;李光洁&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;王磊&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;吴孟达&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;达叔&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;韩子昂&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;赵今麦&#x27;</span>)<br>jieba.add_word(<span class="hljs-string">&#x27;韩朵朵&#x27;</span>)<br><br>swords = [x.strip() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> open (<span class="hljs-string">&#x27;stopwords.txt&#x27;</span>,<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span>)]<br><br>def plot_word_cloud(data, swords):<br>    text = <span class="hljs-string">&#x27;&#x27;</span>.join(data[<span class="hljs-string">&#x27;content&#x27;</span>])<br>    words = list(jieba.cut(text))<br>    ex_sw_words = []<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>        <span class="hljs-keyword">if</span> len(word)&gt;1 <span class="hljs-keyword">and</span> (word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> swords):<br>            ex_sw_words.append(word)<br>    c = Counter()<br>    c = Counter(ex_sw_words)<br>    wc_data = pd.DataFrame(&#123;<span class="hljs-string">&#x27;word&#x27;</span>:list(c.keys()), <span class="hljs-string">&#x27;counts&#x27;</span>:list(c.values())&#125;).sort_values(<span class="hljs-attribute">by</span>=<span class="hljs-string">&#x27;counts&#x27;</span>, <span class="hljs-attribute">ascending</span>=<span class="hljs-literal">False</span>).head(100)<br>    wordcloud = WordCloud(<span class="hljs-attribute">width</span>=1300, <span class="hljs-attribute">height</span>=620)<br>    wordcloud.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;&quot;</span>, wc_data[<span class="hljs-string">&#x27;word&#x27;</span>], wc_data[<span class="hljs-string">&#x27;counts&#x27;</span>], word_size_range=[20, 100])<br>    return wordcloud<br><span class="hljs-comment"># 高分的评价</span><br>plot_word_cloud(<span class="hljs-attribute">data</span>=data[data[<span class="hljs-string">&#x27;score&#x27;</span>]&gt;6], <span class="hljs-attribute">swords</span>=swords)<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/Suvm.I8ESBV9Fkc3Bn5PHLMX4QQBcl3X9.4tLRCicRQ!/b/dL8AAAAAAAAA&bo=FAVsAgAAAAADN20!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"># <span class="hljs-selector-tag">nlargest</span>函数不需要排序直接看最大的<br><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">data</span><span class="hljs-selector-attr">[data[<span class="hljs-string">&#x27;score&#x27;</span>]</span>&gt;<span class="hljs-number">6</span>]<span class="hljs-selector-class">.nlargest</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;upCount&#x27;</span>)<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;content&#x27;</span>]</span>:<br>    <span class="hljs-selector-tag">print</span>(i+<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过热度词云可以看出，《流浪地球》评分高的原因是因为中国国产的科幻片，特效的制作精良。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 低分的评价<br>plot<span class="hljs-constructor">_word_cloud(<span class="hljs-params">data</span>=<span class="hljs-params">data</span>[<span class="hljs-params">data</span>[&#x27;<span class="hljs-params">score</span>&#x27;]&lt;5], <span class="hljs-params">swords</span>=<span class="hljs-params">swords</span>)</span><br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/c1TmBZ57ca1AEW4KqsGBt4tYqpisemfDnSInFfkEjto!/b/dC0BAAAAAAAA&bo=FAVsAgAAAAADN20!&rf=viewer_4&t=5" alt="在这里插入图片描述"><br>通过上图低分词云可以看出，网友评论低分的原因是因为剧情，虽然在中国科幻片上特效制作精良，算是中国国产科幻片里程碑作品，但剧情欠佳。</p><p><strong>低分的人群有哪些特征？（性别、等级）</strong></p><p>观众总体的性别占比</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 总体的性别比例</span><br>gender_total = data[<span class="hljs-string">&#x27;gender&#x27;</span>].value_counts()<br>bar = Bar(<span class="hljs-string">&quot;《流浪地球》观众性别&quot;</span>, <span class="hljs-attribute">width</span>=700)<br>bar.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;&quot;</span>,[<span class="hljs-string">&#x27;未知&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>],gender_total.values, <span class="hljs-attribute">is_stack</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">is_label_show</span>=<span class="hljs-literal">True</span>,<br>               <span class="hljs-attribute">bar_category_gap</span>=<span class="hljs-string">&#x27;60%&#x27;</span>, label_color = [<span class="hljs-string">&#x27;#130f40&#x27;</span>],<br>       <span class="hljs-attribute">legend_text_size</span>=18,xaxis_label_textsize=18,yaxis_label_textsize=18)<br>bar<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/1esG2QMjcqJC1.mYkRqhwpW9AksjehmcW2LJxEQfpTg!/b/dD4BAAAAAAAA&bo=vAKQAQAAAAADFx0!&rf=viewer_4&t=5" alt="在这里插入图片描述"><br>低分观众的性别占比</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gender_low = data[data[<span class="hljs-string">&#x27;score&#x27;</span>]&lt;5][<span class="hljs-string">&#x27;gender&#x27;</span>].value_counts()<br><br>bar = Bar(<span class="hljs-string">&quot;《流浪地球》低分评论观众性别&quot;</span>, <span class="hljs-attribute">width</span>=700)<br>bar.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;&quot;</span>,[<span class="hljs-string">&#x27;未知&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>],gender_low.values, <span class="hljs-attribute">is_stack</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">is_label_show</span>=<span class="hljs-literal">True</span>,<br>        <span class="hljs-attribute">bar_category_gap</span>=<span class="hljs-string">&#x27;60%&#x27;</span>, label_color = [<span class="hljs-string">&#x27;#130f40&#x27;</span>],<br>       <span class="hljs-attribute">legend_text_size</span>=18,xaxis_label_textsize=18,yaxis_label_textsize=18)<br>bar<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/R7Q0V7LQMy*UacK3XIfKxxNisOP7KhjRJ3epJzoU2OM!/b/dDMBAAAAAAAA&bo=vAKQAQAAAAADFx0!&rf=viewer_4&t=5" alt="在这里插入图片描述"><br>可以看出低分观众在男女比例上跟总体的男女比例基本一致</p><p><strong>高低分跟哪位演员有关？</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mapping = &#123;<span class="hljs-string">&#x27;liucixin&#x27;</span>:<span class="hljs-string">&#x27;刘慈欣|大刘&#x27;</span>, <span class="hljs-string">&#x27;guofan&#x27;</span>:<span class="hljs-string">&#x27;郭帆&#x27;</span>, <span class="hljs-string">&#x27;quchuxiao&#x27;</span>:<span class="hljs-string">&#x27;屈楚萧|刘启|户口&#x27;</span>, <span class="hljs-string">&#x27;wujing&#x27;</span>:<span class="hljs-string">&#x27;吴京|刘培强&#x27;</span>, <br>           <span class="hljs-string">&#x27;liguangjie&#x27;</span>:<span class="hljs-string">&#x27;李光洁|王磊&#x27;</span>, <span class="hljs-string">&#x27;wumengda&#x27;</span>:<span class="hljs-string">&#x27;吴孟达|达叔|韩子昂&#x27;</span>, <span class="hljs-string">&#x27;zhaojinmai&#x27;</span>:<span class="hljs-string">&#x27;赵今麦|韩朵朵&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> key,values <span class="hljs-keyword">in</span> mapping<span class="hljs-selector-class">.items</span>():<br>    data<span class="hljs-selector-attr">[key]</span> = data<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;content&#x27;</span>]</span><span class="hljs-selector-class">.str</span><span class="hljs-selector-class">.contains</span>(values)<br><br>staff_count = pd<span class="hljs-selector-class">.Series</span>(&#123;key: data<span class="hljs-selector-class">.loc</span><span class="hljs-selector-attr">[data[key]</span>,<span class="hljs-string">&#x27;score&#x27;</span>]<span class="hljs-selector-class">.count</span>() <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> mapping<span class="hljs-selector-class">.keys</span>()&#125;)<span class="hljs-selector-class">.sort_values</span>()<br>staff_count<br><br>bar = <span class="hljs-built_in">Bar</span>(<span class="hljs-string">&quot;《流浪地球》演职员总体提及次数&quot;</span>, <span class="hljs-attribute">width</span>=<span class="hljs-number">700</span>)<br>bar<span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;李光洁&#x27;</span>,<span class="hljs-string">&#x27;郭帆&#x27;</span>,<span class="hljs-string">&#x27;赵今麦&#x27;</span>,<span class="hljs-string">&#x27;吴孟达&#x27;</span>,<span class="hljs-string">&#x27;屈楚萧&#x27;</span>,<span class="hljs-string">&#x27;刘慈欣&#x27;</span>,<span class="hljs-string">&#x27;吴京&#x27;</span>]</span>,staff_count<span class="hljs-selector-class">.values</span>,is_stack=True, is_label_show=True<br>       ,bar_category_gap=<span class="hljs-string">&#x27;60%&#x27;</span>,label_color = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;#130f40&#x27;</span>]</span><br>        ,legend_text_size=<span class="hljs-number">18</span>,xaxis_label_textsize=<span class="hljs-number">18</span>,yaxis_label_textsize=<span class="hljs-number">18</span>)<br>bar<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/rnGVOTZd7zmRNS1tc4g0i8rfqLGHXuj8YMkHRGFC6NI!/b/dLgAAAAAAAAA&bo=vAKQAQAAAAADFx0!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">staff_low = pd<span class="hljs-selector-class">.Series</span>(&#123;key: data<span class="hljs-selector-class">.loc</span><span class="hljs-selector-attr">[data[key]</span>&amp;(data<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;score&#x27;</span>]</span>&lt;<span class="hljs-number">5</span>),<span class="hljs-string">&#x27;score&#x27;</span>]<span class="hljs-selector-class">.count</span>() <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> mapping<span class="hljs-selector-class">.keys</span>()&#125;)<span class="hljs-selector-class">.sort_values</span>()<br><br>staff_count_pct = np<span class="hljs-selector-class">.round</span>(staff_low/staff_count*<span class="hljs-number">100</span>, <span class="hljs-number">2</span>)<span class="hljs-selector-class">.sort_values</span>()<br><br>bar = <span class="hljs-built_in">Bar</span>(<span class="hljs-string">&quot;《流浪地球》演职员低分评论提及百分比&quot;</span>, <span class="hljs-attribute">width</span>=<span class="hljs-number">700</span>)<br>bar<span class="hljs-selector-class">.add</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;郭帆&#x27;</span>,<span class="hljs-string">&#x27;刘慈欣&#x27;</span>,<span class="hljs-string">&#x27;李光洁&#x27;</span>,<span class="hljs-string">&#x27;屈楚萧&#x27;</span>,<span class="hljs-string">&#x27;赵今麦&#x27;</span>,<span class="hljs-string">&#x27;吴京&#x27;</span>,<span class="hljs-string">&#x27;吴孟达&#x27;</span>]</span>,staff_count_pct<span class="hljs-selector-class">.values</span>,is_stack=True,is_label_show=True,bar_category_gap=<span class="hljs-string">&#x27;60%&#x27;</span>,label_color = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;#130f40&#x27;</span>]</span><br>       ,legend_text_size=<span class="hljs-number">18</span>,xaxis_label_textsize=<span class="hljs-number">18</span>,yaxis_label_textsize=<span class="hljs-number">18</span>)<br>bar<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/aOLybbDPCMTpLrTYK3d.SNPKptH3AFEWdqp0fGHRf2o!/b/dD4BAAAAAAAA&bo=vAKQAQAAAAADFx0!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h3><p><a href="https://segmentfault.com/a/1190000018242134">https://segmentfault.com/a/1190000018242134</a></p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Data Analysis</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine-Learning-笔记 -Bagging&amp;Boosting</title>
    <link href="/2019/01/28/Machine-Learning-%E7%AC%94%E8%AE%B0%20-Bagging&amp;Boosting/"/>
    <url>/2019/01/28/Machine-Learning-%E7%AC%94%E8%AE%B0%20-Bagging&amp;Boosting/</url>
    
    <content type="html"><![CDATA[<p>本文介绍Bagging和Boosting的概念以及运用它们的集成学习算法Adaboost。</p><h3 id="Bagging-amp-Boosting"><a href="#Bagging-amp-Boosting" class="headerlink" title="Bagging &amp; Boosting"></a><strong>Bagging &amp; Boosting</strong></h3><p>Bagging和Boosting都是将多个弱分类器集成起来形成一个强分类器，俗话说三个臭皮匠顶个诸葛亮。<br>首先介绍Bagging</p><h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a><strong>Bagging</strong></h4><p>Bagging(bootstrap aggregating) ,采用一种有放回的抽样方式，每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本，而bootstrap是一种有放回的抽样方法。</p><p>Bagging的算法过程如下：</p><ol><li>从原始样本中抽取训练集，每一轮从中抽取N个样本。共进行K轮抽取，得到K个训练集。</li><li>每个训练集用来训练一个模型，K个训练集共得到K个模型</li><li>对于分类问题：将上面得到的K个模型采用投票的方式得到分类结果；对于回归问题：计算上述模型的均值作为最后的结果。</li></ol><p>注：这里的投票方式，可以采用每个模型不同的投票数的方式，可以给某个模型权重比大。也可以每个模型一样的权重。打个比方说，这就像你在买股票的时候，你有来自各方面的消息，有一个来自这家公司的高层，你跟他是朋友，他告诉你现在公司经营良好，市场份额逐年攀升，那么这时候这位高管朋友的消息一定给的权重大，因为这个是比其他更重要的信息。<br>运用Bagging的典型集成模型为随机森林。</p><h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a><strong>Boosting</strong></h4><p>Bagging是通过有放回的抽样方式来构建强分类器，那么Boosting呢？Boosting则是通过在上一个弱分类器的基础上，通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果</p><p>运用Boosting的集成模型有Adaboost、GBDT、Xgboost。限于篇幅大小，这篇文章只介绍Adaboost，后续文章中再介绍另外两种算法。</p><h3 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a><strong>Adaboost</strong></h3><p>Adaboost该算法先通过对N个训练样本的学习得到第一个弱分类器。然后增大犯错样本的权重，进行下一轮弱分类器的训练，最终得到一个强分类器。</p><p>Adaboost算法的大体描述为以下三步：<br>首先初始化训练数据，假设有N个训练样本数据，每个样本数据的权重为1&#x2F;N，可以表示为<br>D1(i) &#x3D; (W1,W2,W3,W4,…Wn)&#x3D;[1&#x2F;N,1&#x2F;N,1&#x2F;N…1&#x2F;N]</p><p>第二步，训练弱分类器Ht,如果某个训练样本被错误分类，那么在构造下一个训练集中，它对应的权重要增大；相反，如果某个训练样本被正确分类，那么它的权重就减小。</p><p>   a.选取一个当前误差率最低的弱分类器h,作为第t个基本分类器Ht,并计算该分类器在Dt分布上的误差et。<br>   b.计算该弱分类器在最终分类器所占的权重(弱分类器用at表示)：<br>$$a_t &#x3D;\ln(\sqrt{\frac{1-e_t}{e_t}})$$<br>   c.更新训练样本的权值分布Dt+1:<br>$$D_{t+1} &#x3D; \frac{D_t(i)exp(-a_iy_iH_t(x_i))}{Z_t} $$<br>其中：$$归一化常数Z_t&#x3D;2\sqrt{e_t(1-e_t)}$$</p><p><strong>说明：</strong><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/QR*Fk74acZJgXDxWzEgd*DQT2vpOU5cSP10Zu6P5gnk!/b/dL8AAAAAAAAA&bo=OATLAQAAAAARF9Y!&rf=viewer_4&t=5"><br>从上面推导可得<br>错误分类样本，权重更新：<br>$$D_{t+1}(i) &#x3D; \frac{D_t(i)}{2e_i}$$<br>正确分类样本，权重更新：<br>$$D_{t+1}(i) &#x3D; \frac{D_t(i)}{2(1-e_i)}$$</p><p>第三步，将各个训练得到的弱分类器组合成一个强分类器，各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用。而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。<br>$$H_{final}&#x3D;sign(f(x))&#x3D;sign(\sum_{t&#x3D;1}^T a_tH_t(x))$$</p><h3 id="Adaboost算法实例："><a href="#Adaboost算法实例：" class="headerlink" title="Adaboost算法实例："></a><strong>Adaboost算法实例：</strong></h3><p>将这10个样本作为训练数据，根据X和Y的对应关系，把这10个数据分为两类，其中用“+”表示类别1，用“O”表示类别-1.如图所示训练样本，弱分类器采用平行于坐标轴的直线。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/N0Rkanv6x1NzMozPz0IuBIXknW4yxVGqe6Sis.xOCNE!/b/dLkAAAAAAAAA&bo=OAS6AwAAAAARF6U!&rf=viewer_4&t=5"><br><strong>初始化</strong>：令每个权值w1i &#x3D; 1&#x2F;N &#x3D; 0.1，其中，N &#x3D; 10，i &#x3D; 1,2, …, 10，然后分别对于t&#x3D; 1,2,3, …等值进行迭代（t表示迭代次数，表示第t轮）</p><p><strong>第一次迭代t&#x3D;1：</strong><br>初始的权值分布D1为1&#x2F;N（10个数据，每个数据的权值皆初始化为0.1），D1&#x3D;[0.1,  0.1, 0.1, 0.1, 0.1, 0.1,0.1, 0.1, 0.1, 0.1]</p><p>在权值分布D1的情况下，取已知的三个弱分类器h1、h2和h3中误差率最小的分类器作为第1个基本分类器H1(x)（三个误差率都是0.3，那就取第一个吧）</p><p>在分类器H1(x)&#x3D;h1情况下，样本点“5 7 8”被错分，因此基本分类器H1(x)的误差率为：e1&#x3D;0.3<br>根据误差率e1计算Ht的权重:<br>$$a_1&#x3D;\frac{1}{2}ln(\frac{1-0.3}{0.3})&#x3D;0.4236$$<br>然后更新训练样本数据的权值分布，用于下一轮迭代，对于正确分类的训练样本“1 2 3 4 6 9 10”（共七个）的权值更新：<br> $$D_2(i) &#x3D; \frac{D_1(i)}{2(1-e_1)}&#x3D;\frac{1}{10}*\frac{1}{2(1-0.3)}&#x3D;\frac1{14}$$<br>对于错误分类的训练样本“5 7 8”（共三个）的权值更新：<br>$$D_2(i) &#x3D; \frac{D_1(i)}{2e_1}&#x3D;\frac{1}{10}<em>\frac{1}{2</em>0.3}&#x3D;\frac1{6}$$</p><p>这样在第一轮结束后，最后得到的各个样本数据新的权值分布为：D2&#x3D;[1&#x2F;14,1&#x2F;14,1&#x2F;14,1&#x2F;14,1&#x2F;6,1&#x2F;14,1&#x2F;6,1&#x2F;6,1&#x2F;14,1&#x2F;14]</p><p>可得分类函数f1(x)&#x3D;a1H1(x)&#x3D;0.4236H1(x)，这时，强分类器的训练错误为0.3</p><p><strong>第二次迭代t&#x3D;2：</strong></p><pre><code class="hljs">在权值分布D2的情况下，再取三个弱分类器h1、h2和h3中误差率最小的分类器作为第2个基本分类器H2(x)：1)　当取弱分类器h1=X1=2.5时，此时被错分的样本点为“5 7 8”：误差率e=1/6+1/6+1/6=3/6=1/2；2)　当取弱分类器h2=X1=8.5时，此时被错分的样本点为“3 4 6”：误差率e=1/14+1/14+1/14=3/14；3)　当取弱分类器h3=X2=6.5时，此时被错分的样本点为“1 2 9”:误差率e=1/14+1/14+1/14=3/14；</code></pre><p>因此选取当前最小的分类器h2作为第2个基本分类器H2(x),显然H2(x)把样本“3 4 6”分错了，根据D2可以得知他们的权值D2(3)&#x3D;1&#x2F;14,D2(4)&#x3D;1&#x2F;14,D2(6)&#x3D;1&#x2F;14,所以H2(x)在训练集上的误差率：e2&#x3D;3 * 1&#x2F;14 &#x3D; 3&#x2F;14</p><p>根据误差率e2计算Ht的权重:<br>$$a_2&#x3D;\frac{1}{2}ln(\frac{1-3&#x2F;14}{3&#x2F;14})&#x3D;0.6496$$<br>对于正确分类的训练样本的权值更新：<br>$$D_3(i) &#x3D; \frac{D_2(i)}{2(1-e_2)}&#x3D;\frac{7}{11}D_2(i)$$<br>对于错误分类的训练样本的权值更新：<br>$$D_3(i) &#x3D; \frac{D_2(i)}{2e_2}&#x3D;\frac{7}{3}D_2(i)$$</p><p>经过第2轮后，最后得到各个样本数据新的权值分布：<br>D3&#x3D;[1&#x2F;22,1&#x2F;22,1&#x2F;6,1&#x2F;6,7&#x2F;66,1&#x2F;6,7&#x2F;66,7&#x2F;66,1&#x2F;22,1&#x2F;22]<br>分类函数f2(x) &#x3D; 0.4236H1(x)+0.6496H2(x),此时组合两个基本的分类函数错分类点为”3 4 6”</p><p><strong>第三次迭代t&#x3D;3：</strong></p><pre><code class="hljs">在权值分布D3的情况下，再取三个弱分类器h1、h2和h3中误差率最小的分类器作为第3个基本分类器H3(x)：1)当取弱分类器h1=X1=2.5时，此时被错分的样本点为“5 7 8”：误差率e=7/66+7/66+7/66=7/22；2)当取弱分类器h2=X1=8.5时，此时被错分的样本点为“3 4 6”：误差率e=1/6+1/6+1/6=1/2=0.5；3)当取弱分类器h3=X2=6.5时，此时被错分的样本点为“1 2 9”：误差率e=1/22+1/22+1/22=3/22；</code></pre><p>选取当前最小的分类器h3作为第3个基本分类器H3(x),显然H3(x)把样本“1 2 9”分错了，根据D3可以得知他们的权值D3(1)&#x3D;1&#x2F;22,D3(2)&#x3D;1&#x2F;22,D3(9)&#x3D;1&#x2F;22,所以H3(x)在训练集上的误差率：e3&#x3D;3 * 1&#x2F;22 &#x3D; 3&#x2F;22</p><p>根据误差率e3计算Ht的权重:<br>$$a_3&#x3D;\frac{1}{2}ln(\frac{1-3&#x2F;22}{3&#x2F;22})&#x3D;0.9229$$<br>对于正确分类的训练样本的权值更新：<br>$$D_4(i) &#x3D; \frac{D_3(i)}{2(1-e_3)}&#x3D;\frac{11}{19}D_3(i)$$<br>对于错误分类的训练样本的权值更新：<br>$$D_4(i) &#x3D; \frac{D_3(i)}{2e_3}&#x3D;\frac{11}{3}D_3(i)$$</p><p>经过第3轮后，最后得到各个样本数据新的权值分布：<br>D4&#x3D;[1&#x2F;6,1&#x2F;6,11&#x2F;114,11&#x2F;114,7&#x2F;114,11&#x2F;114,7&#x2F;114,7&#x2F;114,1&#x2F;6,1&#x2F;38]<br>分类函数f3(x) &#x3D; 0.4236H1(x)+0.6496H2(x)+0.9229H3(x),此时组合三个基本的强分类函数在数据集上有0个误分类点。至此，结束整个训练过程。<br>最终得到的强分类器为：<br>$$H_{final}&#x3D;sign(\sum_{t&#x3D;1}^T a_tH_t(x))&#x3D;sign(0.4236H_1(x)+0.6496H_2(x)+0.9229H_3(x)$$</p><p>以上是Adaboost的全过程</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h3><p>pan_jinquan博客：<a href="https://blog.csdn.net/guyuealian/article/details/70995333">https://blog.csdn.net/guyuealian/article/details/70995333</a><br>林轩田 机器学习技法</p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>Decision Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning-笔记 -决策树</title>
    <link href="/2019/01/20/Machine-Learning-%E7%AC%94%E8%AE%B0%20-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2019/01/20/Machine-Learning-%E7%AC%94%E8%AE%B0%20-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a><strong>决策树</strong></h3><p>本文介绍的是决策树算法原理</p><p>决策树是一种基本的回归与分类算法，是一种模仿人类做决定的思维方式构建的算法，在分类问题中，是基于特征对实例进行分类的过程，决策树本质上是从训练数据集中归纳出一组分类规则。</p><p>例如下面这个例子。对下班时间、约会情况、提交截止时间这些条件进行判断，从而决定是否要进行在线课程测试。我们模拟一下今天晚上要不要上课决定的过程。这可能取决于下班时间，如果18：30之前就下班了，那有充足的时间，可以去上课。但可能还取决于今天有没有约会，要是有约会，这个课怕是也上不成了。另一种情况，今天要加班到21：30，这时可能要看看今天是不是里交作业的期限，或者离交作业的期限还早。</p><p>把上面的决策过程画成图如下：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/zhC4zsM5.r55QvKFGVPHpe7KZF3Ok1V2xAXvtsIkzV8!/b/dL8AAAAAAAAA&bo=4AE2AQAAAAARF*Y!&rf=viewer_4&t=5"><br>决策树学习算法包含<strong>特征选择</strong>、<strong>决策树生成</strong>与<strong>决策树的剪枝</strong>过程。</p><p>决策树学习常用的算法有ID3，C4.5,与CART，下面结合这些算法分别叙述决策树学习的特征选择、决策树的生成和剪枝过程。</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a><strong>特征选择</strong></h3><p>决策树的第一步是选择属性判断结点，那么通过什么来决定选择哪一个属性呢？<br>这就需要引入熵的概念和信息增益的概念，1948年，香农提出了 ”<strong>信息熵</strong>(entropy)“的概念，一条信息的信息量大小和它的不确定性有直接的关系，要搞清楚一件非常非常不确定的事情，或者是我们一无所知的事情，需要了解大量信息&#x3D;&#x3D;&gt;信息量的度量就等于不确定性的多少。<br>例子：猜世界杯冠军，假如一无所知，猜多少次？每个队夺冠的几率不是相等的，比特(bit)来衡量信息的多少。<br>采用如下方式求信息熵：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/M3xhIVYF2YDeNDrsfZ9N*nxzIPhen1dBIT9uDyKfgP4!/b/dL8AAAAAAAAA&bo=tAFKAAAAAAADF80!&rf=viewer_4&t=5"><br>当每个球队夺冠概率相等时候，由上面的式子可以求得<br>H &#x3D; -(1&#x2F;32<em>log1&#x2F;32+ 1&#x2F;32</em>log1&#x2F;32+…+1&#x2F;32<em>log1&#x2F;32)<br>&#x3D;-[1&#x2F;32</em>(-5)*32] &#x3D; 5<br>32支参加世界杯夺冠球队的信息熵是5，也就是你5次可以猜对那支球队夺冠。<br><strong>变量的不确定性越大，熵也越大。</strong></p><p><strong>信息增益</strong><br>特征A对训练集D的信息增益g(D,A),定义为集合D的经验熵H(D)与特征A在给定条件下D的经验条件熵H(D|A)之差。<br>                    g(D,A)&#x3D;H(D)-H(D|A)</p><p> 例：有如下数据集,分别有年龄、有工作、有自己的房子、信贷情况4个特征，根据这些特征判断是否批准借贷申请。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/PMaYRc4iFbzStp4l3TvsITRsKFTYN4oQx7AB76qTxHk!/b/dL8AAAAAAAAA&bo=eQY4BAAAAAARF2M!&rf=viewer_4&t=5"></p><p>每个特征的信息增益的计算过程如下：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/yNeCh1UYjpEgClSMkbBPdrnXZTk2OBVNl.I2cBJg4y8!/b/dL4AAAAAAAAA&bo=OAS0BQAAAAARF60!&rf=viewer_4&t=5"><br>ID3算法的核心是在决策树上应用信息增益准则选择特征，递归地构建决策树。但以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。这里使用<strong>信息增益比</strong>可以对这一问题进行校正。</p><p>信息增益比定义为其信息增益g(D,A)与训练数据集D关于特征A的值的熵HA(D)之比。<br>C4.5算法与ID3算法类似，只是C4.5对ID3的算法进行了改进，C4.5在生成树的过程中，用信息增益比来筛选特征。</p><h3 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a><strong>决策树的生成</strong></h3><p>决策树的基本思想是递归的过程：</p><ul><li><strong>1) 开始构建根结点，选择一个最优特征，按照这一特征将数据集分割成子集，使得各个子集有一个在当前条件下最好的分类。</strong></li><li><strong>2) 如果样本都在同一类，则该结点成树叶</strong></li><li><strong>3) 否则选择最有分类能力的属性作为决策树的当前结点</strong></li><li><strong>4) 根据当前决策结点属性取值的不同，将训练样本数据集分成若干子集，每个取值形成一个分支，有几个取值形成几个分支。重复进行先前的步骤</strong></li></ul><h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a><strong>决策树的剪枝</strong></h3><p><strong>决策树什么时候停下来</strong><br>1.一种最直观的方式是当每个子节点只有一种类型的记录时停止，但是这样往往会使得树的节点过多，导致过拟合问题（Overfitting）。<br>2.另一种是人工设置最小的阀值，当前节点中的记录数低于一个最小的阀值，那么就停止分割，将max(P(i))对应的分类作为当前叶节点的分类。</p><p>决策树生成算法递归地产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的数据分类却没有那么准确。解决这个问题的办法是考虑决策树的复杂度，对已经生成的决策树进行简化。<br>决策树通过极小化误差函数Ca(T) &#x3D; C(T)+a|T|来实现剪枝，|T|表示模型复杂度，C(T)表示模型对训练数据的预测误差。在对训练数据的预测误差和决策树复杂度之间做一个平衡。</p><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a><strong>CART算法</strong></h3><p>CART算法是通过基尼指数Gini筛选特征，然后递归的构建二叉树，再进行剪枝的过程。基尼指数其表征了特征的不纯度，以下为计算 GINI 公式<br>$$GINI(D)&#x3D;1-\sum_{i&#x3D;1}^n p(i)^2$$<br>我们取一个极端情况，如果数据集合中的类别只有一类，那么<br>GINI(D）&#x3D;0，当集合中有两类，概率分别是1&#x2F;2，那么Gini(D)&#x3D;1&#x2F;2, 说明Gini(D)越小，则数据集D的纯度越高。</p><p>现在很多python集成模型，比如sklearn，决策树里都默认是CART算法，采用基尼指数划分数据，因为基尼指数和熵计算在误差率上几乎没有差异，而基尼指数又规避了计算log的过程，这样当数据量很大时，就会节约大量的时间。</p><p><strong>参考资料：</strong><br>台大林轩田的机器学习技法—第九课<br>《统计学习方法》李航</p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>Decision Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我熟读《影响力》,把销售小哥看得更透</title>
    <link href="/2019/01/19/%E6%88%91%E7%86%9F%E8%AF%BB%E3%80%8A%E5%BD%B1%E5%93%8D%E5%8A%9B%E3%80%8B,%E6%8A%8A%E9%94%80%E5%94%AE%E5%B0%8F%E5%93%A5%E7%9C%8B%E5%BE%97%E6%9B%B4%E9%80%8F/"/>
    <url>/2019/01/19/%E6%88%91%E7%86%9F%E8%AF%BB%E3%80%8A%E5%BD%B1%E5%93%8D%E5%8A%9B%E3%80%8B,%E6%8A%8A%E9%94%80%E5%94%AE%E5%B0%8F%E5%93%A5%E7%9C%8B%E5%BE%97%E6%9B%B4%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>   深谙心理学的销售人员可以说是一种很恐怖的存在，房产中介销售商可以利用<strong>稀缺性</strong>，让本来犹豫不决的你，立马支付了定金。他可能会编造出一个假想的客户，告诉你说，等会我还有一个客户，他很喜欢这套房子，您要是犹豫不决的话，我不敢保证下午这套房子还没卖出去哦。汽车销售员可以利用<strong>对比心理</strong>让你额外买了一套车险，因为在相比刚刚支付的车的价格，后面随之销售的车险的价格就显得有点微不足道了，这时候的成功率就会更高。大街上推销课程的销售员可以利用<strong>互惠原理</strong>,先给你送一个精美的小礼物，拼命强调小礼物是免费的。人们听说是免费的就很容易接受这份小礼物。当接受礼物了之后，他接下来会要求你进他们的站点去了解一下他们推销的产品，这时你因为拿到了小礼物，觉得拒绝他的这个要求好像有点不近人情，所以就跟着去了。</p><p>有一些顺从业者给我们虚假信号，利用人的心理，试图刺激我们的捷径反应，达到让自己盈利的目的。而我们却浑然不知。《影响力》为了避免有人谋求私利误导规则，列举了以下心理原则，它们影响了人们顺从一个要求的倾向性。</p><h3 id="对比原理"><a href="#对比原理" class="headerlink" title="对比原理"></a><strong>对比原理</strong></h3><p>假设有人走进一家时尚男装店，说自己想要买三件套的西服和一件毛衣。如果你是售货员，你该先给他看哪样东西，好让他花最多的钱呢？服装店指点销售人员，要先给顾客看贵的东西。依照人们的常识，顺序应该反过来才对：要是人们买西服时就花了大把的钱，他恐怕不愿再多花钱买毛衣了。但服装商们心知肚明的。他们依照对比原理来设计销售策略：先卖西服，因为顾客接下来买毛衣的时候，哪怕它再贵，价格跟西服比起来，也显得没那么高了。</p><h3 id="互惠原理"><a href="#互惠原理" class="headerlink" title="互惠原理"></a><strong>互惠原理</strong></h3><p>机场的一个行人，正匆匆穿过一个人群拥挤的区域。红十字协会的募捐员走到他的面前，递给他一朵花。这个人吃了一惊，把花接住了。但他马上反应过来，想把花还回去，说自己并不需要花。募捐员说，这是协会的一份礼物，他可以保留的。不过要是，他能够捐一些钱，帮助协会做更多的善举，协会将不胜感激。此时，内心的矛盾从脸上阔散到了全身。他的身体从募捐者的身上移开，似乎要走，但随即又被互惠原理的力量拉回来。他从口袋里摸出几美元，对方礼貌的接下了。</p><p>很明显，在上面的例子中，互惠原理迫使对方接受小馈赠，使得下一步的行动进行的更加容易。人们在互惠原理的压力下往往会更容易做出自己本不愿意做的举动。</p><p>互惠原理还有另一个特点，也容易遭人利用。尽管它确立起来是为了促进伙伴之间的平等交流，但却也可以用来实现完全不平等的结果。它比直接给人恩惠再索取回报的方式更加微妙。</p><p>罗伯特走在大街上，碰到了一个十一二岁的男孩子。他做了自我介绍，并说童子军一年一度的马戏表演就要在本周六晚上举行了，他正在卖门票。他问罗伯特是否愿意购买5美元的门票。罗伯特可不想把大好的周末时光耗在看童子军马戏表演上，于是拒绝了。“好吧”。他说，“要是比不想买门票，买几根巧克力棒如何？才一块钱”罗伯特买了两根，但立刻意识到发生了点怪事，因为：a.罗伯特对巧克力棒没什么兴趣。b.罗伯特喜欢钞票c.罗伯特手里拿着巧克力棒傻傻的站在那儿。d.小孩拿着罗伯特的钞票走了</p><p>这种技巧被叫做“<strong>拒绝-后撤</strong>”术，指的是你想让我答应你的某个要求，为了提高获胜的概率，你可以先向我提出一个大一些的要求，你再提一个稍微小的要求，这个要求才是你真正的目的。倘若你的要求设置的巧妙，我会把你的第二个要求看成是一种对我的让步，并感到自己这边也应该让让步。于是就顺从了第二个要求。</p><p><strong>互惠原理之所以能够屡试不爽的原因是：亏欠感让人很不舒服；违背互惠原理，接受而不是试图回报他人善举的人，是不受社会群体欢迎的。</strong></p><p>如何破功：<br>要怎么样才能抵消互惠这种社会原理的影响呢？一旦激活，它的力量就会铺天盖地压下来，强大得让我们根本无法抵挡。这样看来，不让它激活似乎是个好办法。我们应该抢先出手，拒绝请求者的善意或者让步，大概可以让我们避免跟互惠原理发生冲突。理论上听起来好像很不错。但是，我们需要时刻处于备战状态吗？他靠近我是要干嘛？我们总是戒备森严，看起来像只斗鸡。很显然这不是理想的解决方案。另一种有效的解决方案是<strong>倘若别人的提议我们确实赞同，那就不妨接受它</strong>；<strong>倘若这一提议别有所图，那我们就置之不理</strong>。具体来说就是，有人给了我们一个恩惠，我们大可以接受下来，同时认识到将来有回报他的义务。跟别人达成这样的协议，并不意味着这个人能通过互惠原理利用我们。相反，要是最初的善意其实是专门设计为了刺激我们回报以更大恩惠的圈套、机关或者诡计，那情况就完全不一样了。一旦我们确定最初的恩惠并非出于善意，而是一个顺从的伎俩，那我们就不必受它影响了，该怎么做就怎么做。</p><h3 id="承偌和一致"><a href="#承偌和一致" class="headerlink" title="承偌和一致"></a><strong>承偌和一致</strong></h3><p>在美国，一些玩具商在面临季节性波动的时候，总很难有好的方法改善这种情况，销售最好的时候当然是在圣诞节了，但是在接下来几个月里销售额往往会一落千丈，因为父母们在圣诞节给孩子买了礼物，一段时间他们的玩具预算已经花掉了，他们坚决拒绝在圣诞节后在为孩子买礼物。商家就会面临一个进退两难的问题，怎么样在接下来的几个月了保持消费者对玩具的需求呢？</p><p>如何让刚刚在圣诞节已经花钱的父母，心甘情愿的再花钱为他们已经有太多玩具的孩子再买一件玩具呢？他们是这样做的：在圣诞节前几周就开始为一些特别的玩具做一些吸引人的广告。孩子看到了他们就会央求父母送她这个玩具当做圣诞礼物。这时这些玩具公司就开始执行他们的天才计划了：他们故意不充分的供应这些玩具。大部分家长会发现玩具卖完了，所以只好买一些价值差不多的玩具来代替。这些代替品的供应是足足的。圣诞节过后，这些商家又会把广告拿出来从新播放。这一下，小家伙们就会跑去父母那里哭着说“你答应过我要买的，你答应过的”，家长们只好履行他们的诺言，因为如果不履行承偌，无疑在孩子面前做了一个坏榜样。他们是完完全全被自己之前做出的承诺打败。</p><p>承偌和一致的原理其实很简单，人人都有一种言行一致的愿望，一旦我们作出了一个选择，或者采取了某种立场，我们就会立刻碰到来自内心或者外部的压力，迫使我们按照承诺说的那样去做。在这样的压力下，我们会想方设法地以行动证明之前的决定是正确的。</p><p>如何破功：<br>心理学证据表明，面对一样东西，我们总是先体验到感觉，过上短暂的一瞬间后，才能将之理性化。如果我们多注意训练自己，应该可以在感觉十分轻微还来不及给自己找各种借口时，发现自己是不是在为言行一致找借口。打个比方说：停在加油站的自助加油站跟前，在这里汽油的广告要比本地区其他加油站每加仑低两分钱时，但等把加油泵拿起来，才发现泵上的标价要比广告价要高两分。服务员说价格几天前刚刚调整过了，还来不及把招牌的价格改过来。这时你脑海里可能跳出好些留下来加油的理由——“我必须得加油了”，“我好像记得我的车子用这个牌子的汽油开起来更顺畅”。这时，你需要判断这些理由到底是真的还是自己找的借口。</p><h3 id="社会认同"><a href="#社会认同" class="headerlink" title="社会认同"></a><strong>社会认同</strong></h3><p>在基尤加登斯，一个凶手跟踪一位妇女，并对其施以三次攻击，而皇后区38位尊敬的、遵纪守法的公民们却漠然视之。有两次他们的声音、他们卧室突然亮起的灯光打断了凶手的攻击，把他吓跑了。可他两次都回来了，重新跟上他，用刀子捅她，悲剧发生期间没有一个人打电话报警，知道妇女死后，才有一个目击者报了警。</p><p>出现这样的冷漠社会事件，社会心理学提出了一种最让人难以置信的解释：目击者都没有报警，恰恰是因为当时有38个人在场。没人帮忙，正是因为有那么多的旁观者。因为周围有其他可以帮忙的人，单个人要承担的责任就减少了。再者因为，多元无知效应，很多时候是目击者不知道到底发生什么事情了，碰到这种不确定的情况，人很自然地会根据周围其他人的行动来加以判断。尤其是在我们觉得这些人跟自己相似的时候，这种效率发挥的作用更大。</p><p>如何破功：<br>人们很容易认为当很多人在做相同的事情，他们必然知道一些我们不知道的事情。尤其在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。其次，人群很多时候都是错的，因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应。《乌合之众》在群体意识上描述得很详尽。所以我们需要确认自己不是在被社会证据误导，这时可以用该环境下的客观事实、先前的经验、我们自己的判断与之进行对比。确保它没有出乱子。</p><h3 id="喜好"><a href="#喜好" class="headerlink" title="喜好"></a><strong>喜好</strong></h3><p>我们大多数人总是更容易答应自己认识和喜欢的人所提出的要求。顺从专业人士会采用喜好原则来达到自己的目的，比如人们会对长得好看的人更宽容，除了好看的长相，还有相似性同样能让人产生好感，现在好多销售培训项目现在都敦促学员“模仿和迎合”顾客的身体姿态、语气和口头表达风格，因为这些方面的相似之处都能够带来积极的效果。</p><p>如何破功：<br>在跟顺从专业人士接触的时候，我们只需关注跟好感有关的一件事就行：我们是不是觉得自己超乎寻常、迅速、热烈地喜欢上对方？只要发现这种感觉，我们就要保持警惕了，他可能采取了某种手法，而这时我们就可以采用必要的反击对策，在我们做出顺从决定时，把提出请求的人和请求本身从感性上分开，只根据生意的好坏做决定。我们用顺从专业人士自己最青睐的社交柔道之术，不去压抑好感因素产生的影响力，听凭这些因数发挥力量，然后用这股力量反过来对付那些想从中获利的人。这股力量越大，其发作用力也越强。</p><h3 id="权威"><a href="#权威" class="headerlink" title="权威"></a><strong>权威</strong></h3><p>在国外，有一些餐厅的服务员因为底薪太低，要靠客人给的小费补足收入。在一家高档餐厅里，有一个厉害人物，他叫文森特，经过他手点的菜单总是价目比较高，他收到的小费也总是很丰富。他有一大堆方法，会根据不同的情有针对性的使用。面对8-12个人的大聚餐，文森特会在第一个人点餐的时候，不管她点什么，总是会做出同样的反应，眉头紧锁，手在点餐单上打转，之后飞快地扭头过去瞅一眼经理那儿。他稍稍朝餐桌倾过身子说：“今晚这道菜恐怕不够好，我可以向您推荐这个吗（推荐菜单上比顾客刚刚点的稍微便宜一点）?”他把自己打扮得像这家店里的权威人物，清楚今晚哪样菜好，哪样不好。他像顾客证明他并非是只顾着自己兜里的钱，而是把顾客的最大利益放在心上。这时候，他等到众人点餐完毕，“你们愿意让我帮你们选一些红酒来搭配吗？”经过之前的铺垫，顾客们都会微笑的点头表示同意。这样便通过优雅的态度既提高了顾客的消费总额，又提高了自己的消费。</p><h3 id="稀缺"><a href="#稀缺" class="headerlink" title="稀缺"></a><strong>稀缺</strong></h3><p>倘若瑕疵把一件东西变得稀缺了，垃圾也能化身成为值钱的宝贝。参与竞争稀缺资源的感觉，对人有着强大的刺激性。<br>它的力量主要来自两个方面：</p><p>第一，<strong>和其他影响力武器一样，稀缺性原理钻了我们思维捷径上的空子</strong>。我们都知道，难以得到的东西往往比容易得到的东西要好，因此，我们倾向于根据获得一样的东西的难易程度来判断它的质量。也就是说，稀缺原理成立的一个重要原因在于，根据它做出判断，大部分时候是正确的。</p><p>第二，机会越来越少的话，我们的选择自由也会随之丧失，而我们本身又都痛恨失去本该拥有的自由。保住既得利益的愿望，是心理逆反理论的核心。</p><p>根据心理逆反理论，只要选择的自由受到限制或者威胁，保护自由的需求就会使我们得到它们的愿望愈发强烈。因此，一旦短缺或者其他因素妨碍我们获取某物，我们就会比以前更想得到它，更想占有它，跟这种妨碍对着干。两岁的孩子和十几岁的少年是逆反心理最旺盛的，这是一个成长的必经阶段。</p><p>每当有东西获取起来比以前更难，我们拥有他的自由受了限制，我们就越发想要得到它。不过我们很少意识到是逆反心理带来了这种迫切感，而只知道是自己想要。为了解释这种莫名的渴望，我们开始给它安上各种积极的品质，比如探索欲，好奇心，与众不同。</p><p>如何破功：<br>在这种情况下，要知道稀缺的东西并不因为难以弄到手，就变得更好吃、更好听、更好听、更好玩。</p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>psychology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning-笔记 -SVM</title>
    <link href="/2019/01/12/Machine-Learning-%E7%AC%94%E8%AE%B0%20-SVM/"/>
    <url>/2019/01/12/Machine-Learning-%E7%AC%94%E8%AE%B0%20-SVM/</url>
    
    <content type="html"><![CDATA[<p>本文介绍的是SVM算法原理(NG的ML课程笔记)</p><p>适应人群：想了解SVM原理的</p><p>为了好好理解SVM算法的原理，我们先从逻辑回归开始。</p><p>逻辑函数的假设函数(Hypothesis)如下图：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/HVBY*luEKsAWFVFT6oee4DGr*VkgUwIb*0y4kuaN.x0!/b/dDcBAAAAAAAA&bo=nAJlAQAAAAADF8g!&rf=viewer_4&t=5"><br>下面将用Z代替等号右边</p><p>$$Z&#x3D;Θ^TX $$</p><h3 id="逻辑回归用来做什么"><a href="#逻辑回归用来做什么" class="headerlink" title="逻辑回归用来做什么"></a><strong>逻辑回归用来做什么</strong></h3><p>很显然逻辑回归用来分类，如果有一个y&#x3D;1的样本，我们希望h(x)趋近1，因为我们想正确地将此样本分类，这就意味着当h(x) 趋近于 1 时，Z应当远大于0，用数学符号表示Z&gt;&gt;0,从上图可以看出当Z&gt;&gt;0是对应的函数输出是1；相反，如果我们有另外一个样本，即y&#x3D;0。我们希望假设函数的输出值将趋近于 0，对应的Z要远远小于0，Z&lt;&lt;0</p><p>进一步观察逻辑回归的代价函数,每一个样本都会为代价函数做贡献。现在，考虑两种情况，一种是 y 等于 1 的情况；另一种是 y 等于 0 的情况。</p><p>在第一种情况中，假设y&#x3D;1，此时在目标函数中只需有第一项起作用，因为 y 等于 1 时，(1-y) 项将等于0。画出关于 z 的函数，你会看到左下角的这条曲线，当z增大时，z 对应的值会变的非常小。对整个代价函数而言，影响也非常小。这也就解释了，为什么逻辑回归在观察到正样本 y&#x3D;1 时，试图将z设置得非常大。因为，在代价函数中的这一项会变的非常小。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/hzVtQJF*zGgUxoMzif6lIwh6gZhiubtZXOURit1R63I!/b/dL4AAAAAAAAA&bo=nAKLAQAAAAADJxY!&rf=viewer_4&t=5"></p><h3 id="建立SVM-支持向量机"><a href="#建立SVM-支持向量机" class="headerlink" title="建立SVM(支持向量机)"></a><strong>建立SVM(支持向量机)</strong></h3><p>现在开始建立支持SVM(向量机)，首先从这个代价函数开始,一点点修改<br>$$ \log(1- \frac{1} {1+e^{-Z}})$$<br>红线画出的函数表示将要用的代价函数<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/m3oxpA4dmsJjWc6kPaVuGmOsbXDehBKpNIXSYUbNQn4!/b/dL8AAAAAAAAA&bo=hwFfAQAAAAADF.o!&rf=viewer_4&t=5"><br>新的代价函数将会水平的从这里到右边 (图外),到了这里已经非常接近逻辑回归中使用的代价函数了。只是这里是由两条线段组成，即位于右边的水平部分和位于左边的直线部分，先别过多的考虑左边直线部分的斜率，这并不是很重要.</p><p>我们用一个新的代价函数来代替逻辑函数，即这条从 0 点开始的水平直线，然后是一条斜线。左边的函数，我称之为 Cos t1(z)，同时，右边函数我称它为 Cos t0(z)。这里的下标是指在代价函数中，对应的 y&#x3D;1 和 y&#x3D;0 的情况.<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/LDxD6g7vF5Hv24*xtYGVTg06PeeIpgIDKrm9cLfhbBU!/b/dMIAAAAAAAAA&bo=fQFCAQAAAAADFw0!&rf=viewer_4&t=5"></p><h3 id="开始构建SVM-支持向量机"><a href="#开始构建SVM-支持向量机" class="headerlink" title="开始构建SVM(支持向量机)"></a><strong>开始构建SVM(支持向量机)</strong></h3><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/LqBf*CXhMKdG*f1P6CuvCfdDJkrhCX0wvSLeUtKBrgs!/b/dL8AAAAAAAAA&bo=pQJxAQAAAAADJ9U!&rf=viewer_4&t=5"><br>上面是逻辑回归当中使用的代价函数J(Θ),SVM在这里稍微做个转变,把括号里的log函数分别用上面提到的 Cos t1(z)和Cos t0(z)替换，然后再加上正则项。</p><p>这里我们有两项：第一是训练样本的代价，第二个是我们的正则化项，我们不得不去用这一项来平衡.这就相当于我们想要最小化 A 加上正则化参数λ，然后乘以其他项 B 对吧？这里的 A 表示这里的第一项，同时我用 B 表示第二项，但不包括λ，我们不是优化这里的 A+λ×B.</p><p>我们依照惯例使用一个不同的参数称为 C，那么，我现在删掉这里的λ，并且用常数 C 来代替。同时改为优化目标，C×A+B 因此SVM hypothesis可以表示为<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/aePvUWA*0mJ4xkJvYnELd*mxTc37Ax22ztT*MEFwv3U!/b/dDcBAAAAAAAA&bo=gAJGAQAAAAADJ8c!&rf=viewer_4&t=5"></p><p>现在让我们考虑一下，最小化这些代价函数的必要条件是什么.如果你有一个正样本，y 等于 1.则只有在 z 大于等于 1 时,代价函数 cost 1 (z)才等于 0.换句话说，如果你有一个正样本，我们会希望Θ^TX  &gt;&#x3D;1，反之，如果 y 是等于 0 的，我们观察一下，函数 cost 0 (z)，它只有在 z&lt;&#x3D;1的区间里函数值为 0，这是支持向量机的一个有趣性质。</p><p>我接下来会考虑一个特例，将这个常数 C 设置成一个非常大,比如我们假设 C 的值为 100000 或者其它非常大的数，然后来观察支持向量机会给出什么结果？如果 C 非常大，则最小化代价函数的时候，我们将会很希望找到一个使第一项为 0 的最优解。因此，让我们尝试在代价项的第一项为 0 的情形下理解该优化题。</p><p>第一项为0，必须是c乘以0，所以这将遵循以下约束，y  (i )是等于 1,Z &gt;&#x3D;1,如果 y  (i )是等于 0的,Z&lt;&#x3D;-1.当你最小化这个关于变量 θ 的函数的时候，你会得到一个非常有趣的决策边界。那么就只剩下第二项，这个优化目标函数可以被写成等于<br>$$  \frac{1}{2}||Θ^2||<br>$$ </p><p>具体而言，如果你考察这样一个数据集，其中有正样本，也有负样本，可以看到这个数据集是线性可分的。我的意思是，存在一条直线把正负样本分开。当然有多条不同的直线，可以把正样本和负样本完全分开。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/TaY.XOPn8wB6ywygqVKTVfGr1bWGA03qtFNZygBkxL8!/b/dL8AAAAAAAAA&bo=GQIyAQAAAAADFxo!&rf=viewer_4&t=5"><br>比如，这就是一个决策边界可以把正样本和负样本分开。但是多多少少这个看起来并不是非常自然是么?</p><p>或者我们可以画一条更差的决策界，这是另一条决策边界，可以将正样本和负样本分开，但仅仅是勉强分开，这些决策边界看起来都不是特别好的选择，支持向量机将会选择这个黑色的决策边界，相较于之前我用粉色或者绿色画的决策界。这条黑色的看起来好得多.在分离正样本和负样本上它显得的更好。数学上来讲，这是什么意思呢？这条黑线有更大的距离，这个距离叫做间距 (margin).因此支持向量机有时被称为 大间距分类器，而这其实是求解上面优化问题的结果。</p><h3 id="大间隔分类背后的数学原理"><a href="#大间隔分类背后的数学原理" class="headerlink" title="大间隔分类背后的数学原理"></a><strong>大间隔分类背后的数学原理</strong></h3><p>首先复习一下关于向量内积的知识,假设我有两个向量，u 和 v 。uT<em>v 叫做向量 u 和 v 之间的内积。向量的内积在几何上的表示为将 v 投影到 u上，p 是 v 投影到向量 u 上的长度, uT</em>v &#x3D;p * ||u||。<br>顺便说一句，uT<em>v&#x3D;vT</em>u。最后一点，需要注意的就是 p 值，p 事实上是有符号的。如果 u 和 v 之间的夹角小于 90 度，那么那条红线的长度 p 是正值。然而如果这个夹角大于 90 度，则 p 将会是负的。</p><p>我们接下来将会使用这些关于向量内积的性质试图来理解支持向量机中的目标函数。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/eQeKytLiAttggAuvBaWBxt.eF2wx2e6O0u4R5MpKHRo!/b/dDQBAAAAAAAA&bo=tAKQAQAAAAADJyU!&rf=viewer_4&t=5"><br>接下来忽略掉截距，令 θ 0  &#x3D; 0,这样更容易画示意图。我将特征数 n 置为 2，因此我们仅有两个特征 x 1 和 x 2 ，现在 我们来看一下目标函数，支持向量机的优化目标函数。当我们仅有两个特征，即n&#x3D;2时，这个式子可以写作：<br>$$  \frac{1}{2}(Θ^2_1+Θ^2_2) &#x3D; \frac{1}{2}(\sqrt{Θ^2_1+Θ^2_2})^2&#x3D;  \frac{1}{2}||Θ||^2<br>$$<br>因此支持向量机做的全部事情，就是 极小化参数向量 θ  范数的平方 ， 或者说长度的平方.</p><p>现在我将要看看这些项：<br>我们考察一个单一的训练样本，我有一个正样本在这里，用一个叉来表示这个样本x(i),意思是在水平轴上取值为x1(i),在竖直轴上取值为x2(i).，我们有一个参数向量我会将它也画成向量。我将 θ 1 画在横轴这里，将 θ 2  画在纵轴这里，那么内积θT*X(i)将会是什么呢？</p><p>使用我们之前的方法，我们计算的方式就是我将训练样本投影到参数向量 θ,θT*X(i)&#x3D;P*||θ||&#x3D;θ1*X1+θ2*X2</p><p>转换一下约束：Z&gt;&#x3D;1或者Z&lt;&#x3D;-1时，约束是被P(i)*θ&gt;&#x3D;1,或者&lt;&#x3D;-1代替，因为θT*X(i)&#x3D;P*||θ||.</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/.pPSCQwwf7DkZ3F1.kOrwXPVq*kiV7CQQjCCS6ngkYQ!/b/dLgAAAAAAAAA&bo=bgJ1AQAAAAADFyo!&rf=viewer_4&t=5"></p><p>前面提到的代价函数可以被写成等于<br>$$  \frac{1}{2}||Θ^2||$$<br>现在，继续使用之前的简化，即 θ 0 &#x3D;0。(θ 过原点)<br>要想最小化代价函数，必须使得θ的范式尽可能小。但是不要忘了一个前提当为正样本时，P(i)*||Θ||&gt;&#x3D;1,所以必须满足P尽可能的大。而P是特征向量X在参数向量Θ的投影。这个投影长度越大，说明产生间距越大。这就是支持向量机如何能有效地产生大间距分类的原因。</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/*Z4h0eBDl68ALF9H4Avsr.rLJUSRgWtkD7MEI1etaI8!/b/dDYBAAAAAAAA&bo=rgELAQAAAAADF5c!&rf=viewer_4&t=5"><br>看这条绿线，这个绿色的决策界。我们希望正样本和负样本投影到 θ 的值大。要做到这一点的唯一方式就是选择这条绿线做决策界。这是大间距决策界来区分开正样本和负样本这个间距的值。这个间距的值就是 p (1) p (2) p (3) 等等的值。通过让间距变大，支持向量机最终可以找到一个较小的 θ 范数。这正是支持向量机中最小化目标函数的目的。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a><strong>核函数</strong></h3><p>以上介绍的一条直线就可以划分边界的情况，是线性核函数，但很多情况是不能简单的用一条直线就能够划分边界出来的。这时就需要换用更复杂的核函数。这里仅仅列举一下常用的核函数。</p><ul><li>高斯核函数（Gaussian Kernel）</li><li>sigmoid核函数</li><li>线性核函数 </li><li>多项式核函数</li></ul><h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a><strong>一些规则</strong></h3><p>下面是一些普遍使用的准则：<br>n 为特征数，m 为训练样本数。</p><ul><li>如果相较于 m 而言，n 要大许多，即训练集数据量不够支持我们训练一个复杂的非线性模型，我们选用逻辑回归模型或者不带核函数的支持向量机。</li><li>如果 n 较小，而且 m 大小中等，例如 n 在 1-1000 之间，而 m 在 10-10000 之间，使用高斯核函数的支持向量机。</li><li>如果 n 较小，而 m 较大，例如 n 在 1-1000 之间，而 m 大于 50000，则使用支持向量机会非常慢，解决方案是创造、增加更多的特征，然后使用逻辑回归或不带核函数的支持向量机。</li></ul><p>SVM优点：主要在于它的代价函数是凸函数，不存在局部最小值</p><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>SVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做计划，不是一份愿望清单...</title>
    <link href="/2018/12/31/%E5%81%9A%E8%AE%A1%E5%88%92,%E4%B8%8D%E6%98%AF%E4%B8%80%E4%BB%BD%E6%84%BF%E6%9C%9B%E6%B8%85%E5%8D%95/"/>
    <url>/2018/12/31/%E5%81%9A%E8%AE%A1%E5%88%92,%E4%B8%8D%E6%98%AF%E4%B8%80%E4%BB%BD%E6%84%BF%E6%9C%9B%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>做计划，不是一份愿望清单……</p><p>2018年最后一天了，你的愿望是不是改一改时间2019还能继续用，为什么新年愿望总实现不了？就真的只是愿望放在那儿一年又一年。当看到别人纤细苗条的身材，穿漂亮的衣服，而自己眼看漂亮的裙子不合身，急了眼，于是在愿望清单上加上一条，减肥瘦身，每天去健身房。事后坚持一个星期都坚持不下来。对于自己定下来的看书计划，一个星期看一本书，晚上捧着书就开始呼呼大睡。一个月过去了才看到第一章。从明天开始我要早起背单词，第二天你摆好pose发朋友圈，配上文字，今天有早起背单词，早晨的空气是真的新鲜。第三天，你因为下雨，计划又延后。</p><h3 id="为什么定下的目标总是实现不了？"><a href="#为什么定下的目标总是实现不了？" class="headerlink" title="为什么定下的目标总是实现不了？"></a>为什么定下的目标总是实现不了？</h3><p>我们总说，工作一年学到的东西比大学四年学到的都要多，为什么？因为大学里的东西很多都没有实操性，有的课本几十年没有更新换代，案例也是一些老掉牙的案例。拿理科生，工科生必学的基础课“线性代数”举例来说，从1997年以后，美国新出版的线性代数教材几乎全部采用了计算机算题，而我国教材中找不到一本用计算机的，全靠手算。我在念这门课的时候，完全被这繁琐的演算，搞得一点兴趣没有。你说这门课难吗，其实并不难，只是在学的时候你根本不知道它可以做什么用。毕业后我慢慢开始接触到机器学习(Machine Learning)，深度学习(Deep-Learning),数据挖掘(Data-Mining)这些后，我发现线性代数学好了是多么有用，因为上述领域中要求数学基础知识中，有一项就是线性代数，矩阵的运算只要一步就可以解决的问题，而for需要套很多层，速度还慢。而这些用处我在大学课堂上根本体会不到，就像又不会拿线性代数去买菜一样，大学里很多课程形同虚设。学了也没有学到精髓。<strong>因为它不是你的刚需。</strong>我现在就特别想爬进机器学习领域，我想去发觉那些类似于亚马逊发现超市将啤酒和尿布摆在一起卖，会莫名的销量好一样，去发现一些潜在的规律，我觉得那将会是很有意义的工作。</p><p>再来看为什么定下的目标总是实现不了，<strong>是因为没那么想实现,是因为那不是你的刚需，你看每天早起背英语的过程太痛苦了，改变实在太难了，现状好像也没有那么糟糕，于是“愿望”就被搁置了。等到年终的时候，就只是愿望了。</strong> 当愿望是刚需时，都不用逼迫自己，你都会每天努力去实现它。与其在新年伊始，开始列愿望清单，不如多想想自己想要什么样的生活？用结果作导向。</p><p>我记得罗胖在一次直播中，描绘得到的宏伟蓝图的时候说过，当你不知道你现在做的事会不会成功时，你不妨设想一下，你希望它十年后是什么样子。以结果为导向，你就知道你现在要做什么了，而且更加清楚你现在做的事的意义。</p><h3 id="制定合理且具体的计划"><a href="#制定合理且具体的计划" class="headerlink" title="制定合理且具体的计划"></a>制定合理且具体的计划</h3><p>我曾在知乎上看到过一个概念，[<strong>NLP理解层次</strong>]。它是这么说的，对于一件事的理解，我们可以分为6个不同的层次。理解层次越高的人，解决问题的能力也越强。举一个事例，帮助理解 。</p><p>“我现在对这个工作不满意”</p><h4 id="第5流人才"><a href="#第5流人才" class="headerlink" title="第5流人才"></a>第5流人才</h4><ul><li><strong>又名:怨妇</strong></li><li><strong>所处理解层次：环境</strong></li><li><strong>典型思考模式：不怪我，都是你们的错！</strong><br>处在理解层次最底层第六层次的人,遇到问题时，他会首先把问题归结为「<strong>因为环境的不好</strong>」而产生的问题， 把一些都归结于环境，就是除自己以外的一切。我对这个工作不满意，是因为领导无能，公司办公室政治严重。</li></ul><p><strong>而他在寻找解决办法的路径上，也会从改变环境的角度思考。比如：</strong><br>我不喜欢这个工作，我换一个就是，此处不留爷自有留爷处。</p><p>这一类人总是不停的在抱怨，好像就只有他们的生活命运多舛，在《这个杀手不太冷》中，小女孩问里昂，生活总是这样还是只有小时候是这样，里昂回答always。谁不是一面不想活了又拼命活着。<br>她们似乎好像也知道抱怨不好？但为什么他们还是在不断抱怨呢？那就是因为他们的理解层次处在了最低的「环境层」，并不是他们想抱怨，而是在他眼里，除了看到环境之外，再也无法看到其他的了。因此，他们能想到的最好办法，也就只能是换个更好的环境了。</p><h4 id="第4流人才"><a href="#第4流人才" class="headerlink" title="第4流人才"></a>第4流人才</h4><ul><li><strong>又名:行动派</strong></li><li><strong>所处理解层次：行动</strong></li><li><strong>典型思考模式：我还不够努力！</strong><br>这里我们往上走了一层，来到第二个层次「行为」。处在这一层次的人，当问题发生的时候，他首先会把问题归结成「因为我的努力还不够」而产生的问题。比如：<br>我对这个工作不满意。是因为我的能力还不够，没有看到这个工作给你带来的潜在意义。<br>收入太低？因为我还不够努力…<br>总之，发生了问题，先从自身找原因，看看是不是因为自己偷懒了？是不是努力程度还不够？</li></ul><p>你会发现，处在这一层次，环境问题并不是什么问题了，变得没那么重要了，你发现没有越往上走，看到的点越不一样，换句话说，当你处在环境层次时，你觉得可能跨不去的坎，在行动层次的人来说根本就不是什么问题。</p><p><strong>而他在寻找解决办法的路径上，也会从行为的层面思考。比如：</strong><br>几年没涨工资了，今天开始多加班。<br>业绩不好，我多联系一下别的客户</p><p>但是，是不是努力了，所有问题都解决了呢。学生时代有些学生就是很努力，一天学到晚，但成绩就是上不去。努力的确是成功的一个必要条件，但远远不是充分条件。现在网上到处充斥着鸡汤，今天又是元气满满的一天哟。这种鸡汤喝所谓的成功学。它们只告诉了你要努力，却没有给你方法，它们只是帮助你脱离了最低的「环境」层，来到了第二低的「行为」层！以为给你打一针鸡血，你就开始奋斗了，就一定能成功了！只靠努力却在目标的道路上背道而驰，感动地只有你自己。</p><h4 id="第3流人才"><a href="#第3流人才" class="headerlink" title="第3流人才"></a>第3流人才</h4><ul><li><strong>又名:战术家</strong></li><li><strong>所处理解层次：能力</strong></li><li><strong>典型思考模式：方法总比问题多！</strong><br>理解层次处在「能力」层次的人，当问题发生的时候，首先会把问题归结成是「因为我的能力不足」而产生的。所以，他们也会在「能力」这个层次里去寻找更好的「方法」来解决问题。比如：<br>开的火锅店生意不太好，是因为我的经营模式太陈旧，我需要学习新的方法…比如，可以通过社群经济的方式来降低我的获客成本。<br><strong>这类人有非常强大的学习能力和应用能力，能把学习到的知识，转化为可操作的方法，进而改善效率，解决问题</strong></li></ul><p>他们清楚的知道太阳底下没有新鲜事，你现在遇到的问题，前人一定都遇到过，说不定还已经编成书了。如果你能走到这个层次，既有「行为层」的勤奋努力，又有「能力层」的方法套路，普通的问题已经难不倒你了，你总能找到办法来解决它们。这里说的每提高一个层次，并不是说就不要下一个层次了，而是在原来的基础上，上升了一个思考层次。</p><p>到这里已经是我们人的意识能想到的最高层次了。那肯定有人问了，还有什么问题是你有能力解决不了的事呢？答案是，你没抓住问题是什么，病急乱投医。什么意思，你在着手解决问题之前，你得先清楚，你要解决的问题是什么？比如一个门店人烟稀少，导致现状的原因看上去有很多，哪个才是最重要的问题？</p><ul><li>是团队管理的问题？营销方式的问题？还是商业模式的问题？</li><li>是应该打折清库存减少损失，准备关门？还是战略转型，坚持到底？<br>每一个选择都意味着不同的问题，一旦选择出了问题，没有抓住主要矛盾，你那优秀的「能力」和「行动力」只会让你越走越远。提高做选择题的能力，接下来需要进入下一层。</li></ul><h4 id="第2流人才"><a href="#第2流人才" class="headerlink" title="第2流人才"></a>第2流人才</h4><ul><li><strong>又名:战略家</strong></li><li><strong>所处理解层次：BVR（信念&#x2F;价值观&#x2F;规条）</strong></li><li><strong>典型思考模式：什么才是更重要的？</strong></li></ul><p>什么是BVR？</p><ul><li><strong>B（Believe）：信念</strong>，你相信什么是对的？</li><li><strong>V（Value）：价值观</strong>，你认为A和B哪个更重要？<br>我们说三观不合，不能做朋友，我向往海洋，而你却说那里淹死过很多人。我们每个人都会有一个价值衡量尺度，有的人觉得享乐重要，就优先享乐，把赚到的钱去换不同的体验，比如去国外旅游。有些人觉得挣钱重要，就把省着钱留下来。</li><li><strong>R（Rule）：规条</strong>,做人做事的原则。每个人有自己做事的原则，这些原则就来自于信念和价值。我有一条自己的原则是：答应别人的事，一定做到。而背后的信念其实是说到做到。诚信大于一切，就是觉得诚信最重要。</li></ul><p>处在「BVR层」的人，当问题发生的时候，首先会先思考「哪个是最重要的问题？」、「除了我看到的这些问题，还有什么更重要的问题是我没有看到的？」</p><p>BVR更多的是在有一个客观的价值标准时，你选择那个对你来说更有价值的问题去解决。BVR的缺陷，当遇到主观选择题的时候，我们不知道该怎么办。这时我们再往上走一个层次。</p><h4 id="第1流人才"><a href="#第1流人才" class="headerlink" title="第1流人才"></a>第1流人才</h4><ul><li><strong>又名:觉醒者</strong></li><li><strong>所处理解层次：身份</strong></li><li><strong>典型思考模式：因为我是XXX，所以我会XXX</strong><br>广大的股民朋友们都知道股神巴菲特，但是在自己选股择时的时候，有没有想过如果我是巴菲特，我此时会怎么做到。除了巴菲特，利弗莫尔同样在股票界享有声明。当你想想自己是利弗莫尔时，又会有怎样的不一样。这最后让你做决定的是你想成为谁，<strong>当你想清楚自己的「身份」定位后，就应该围绕它配套相应的BVR，再构建你的能力圈，并做出相应的计划与行动，你就会成为第一流的人才！</strong><br>第一流人才再往上走一层，是顶级的人才。</li></ul><h4 id="顶级人才"><a href="#顶级人才" class="headerlink" title="顶级人才"></a>顶级人才</h4><ul><li><strong>又名:领袖&#x2F;伟人</strong></li><li><strong>所处理解层次：精神&#x2F;使命</strong></li><li><strong>典型思考模式：人活着就是为了改变世界！</strong><br>理解层次的最高层次「精神」,精神是什么？就是你与世界的关系。也就是我们经常听到的「人生使命」，你来到这个世界是为了什么？这个层次所有的思考都是利他主义，现在全球气候越来越暖，我要做什么来改变这个现状。我要怎样才能推动时代的进步。像马丁路德金，解放黑人奴隶制度。乔布斯，活着就是为了改变世界。</li></ul><h4 id="根据NLP理解层次我们再来制定自己明确的目标。"><a href="#根据NLP理解层次我们再来制定自己明确的目标。" class="headerlink" title="根据NLP理解层次我们再来制定自己明确的目标。"></a>根据<strong>NLP理解层次</strong>我们再来制定自己明确的目标。</h4><p>这里还有一个很好用的制定目标的原则“<strong>SMART原则</strong>”<br><strong>即目标应当是具体的(Specific)、可以衡量的(Measurable)、可以达到的(Attainable)、与其他目标具有一定的相关性的(Relevant)、具有明确的截止期限的(Time-bound)。</strong></p><p><strong>比如我2019的愿望清单是：</strong></p><ul><li>想爬进数据挖掘领域</li><li>继续完成EF的课程</li><li>投资理财</li><li>读书</li></ul><p>对于第一个愿望，想爬进数据挖掘领域，我在文章前面说过了，我想去发觉那些类似于亚马逊发现超市将啤酒和尿布摆在一起卖，会莫名的销量好一样，去发现一些潜在的规律，我觉得那将会是很有意义的工作。所以我想成为这个专业领域的人，好了，有了这个目标，我该向下培养什么能力呢？我去查了招聘网站的任职要求。</p><ul><li><strong>1.熟悉常用算法</strong></li></ul><ul><li>决策树</li><li>逻辑回归</li><li>SVM</li><li>k-means</li><li>GBDT</li><li>XGBOOST</li><li>PCA<br>对于这个要求，我再把目标打散，一个一个算法攻克</li></ul><ul><li><strong>2.熟练使用SQL</strong><br>因为我现在的工作日常就是写SQL，所以不太需要额外训练。</li><li><strong>3.至少一门统计分析工具python&#x2F;R&#x2F;spss</strong><br>人生苦短我用python，再具体化一点，每天leecode上刷一道题，两个星期做一次总结。</li><li><strong>4.参加kaggle比赛</strong><br>我准备先复现2018CCF BDCI《供应链需求预测》和《基金间的相关性预测》一等奖的开源思路，上半年参加两次比赛。</li></ul><p>对于第二个愿望，继续完成EF的课程。具体可衡量一点就是在20190126前，完成level9的练习，每个星期2-3次online-group lesson，offline F2F twice a week, offline workshop twice a week。20190126后花一个月复习level4到level9的课程内容。20190630之前完成中高级(level10-12)课程。年底完成高级课程。</p><p>对于第三个愿望，复习香帅的北大金融学课，一课一课重新做复习笔记。每天一篇。一个月对一个上市公司进行研究，并写研究报告。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>首先介绍了为什么定下的目标总是实现不了？是因为定下的目标都不是的刚需。</li><li>然后引入NLP理解层次，分为6个层次，精神、身份、BVR(信念&#x2F;价值观&#x2F;规条)、能力、行为、环境。</li><li>制定自己明确的目标(SMART原则)</li></ul><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>plan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning-实战 电信行业智能套餐个性化匹配</title>
    <link href="/2018/12/30/MachineLearning-%E5%AE%9E%E6%88%98%20%E7%94%B5%E4%BF%A1%E8%A1%8C%E4%B8%9A%E6%99%BA%E8%83%BD%E5%A5%97%E9%A4%90%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8C%B9%E9%85%8D/"/>
    <url>/2018/12/30/MachineLearning-%E5%AE%9E%E6%88%98%20%E7%94%B5%E4%BF%A1%E8%A1%8C%E4%B8%9A%E6%99%BA%E8%83%BD%E5%A5%97%E9%A4%90%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>本文是关于BDCI 2018-面向电信行业存量用户的智能套餐个性化匹配模型大赛 TOP1开源代码的实现</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li><strong>windows</strong></li><li><strong>python3.6</strong></li><li><strong>pandas sklearn xgboost</strong> <h2 id="赛事说明"><a href="#赛事说明" class="headerlink" title="赛事说明"></a>赛事说明</h2></li></ul><p>赛事链接<a href="https://www.datafountain.cn/competitions/311/details/data-evaluation">面向电信行业存量用户的智能套餐个性化匹配模型</a></p><p>可以参看链接，里面有详细的训练集数据说明，里面包含了如下信息：<br>数据说明<br>作品要求<br>评分方式</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我复现了top1的解决方案，以下是top1的解决方案：</p><h3 id="1-数据探查"><a href="#1-数据探查" class="headerlink" title="1.数据探查"></a><strong>1.数据探查</strong></h3><h5 id="分类label"><a href="#分类label" class="headerlink" title="分类label"></a><strong>分类label</strong></h5><p>根据赛事说明，该比赛是一个多分类的问题，对应着有11种套餐，首先看看这11种套餐的分布情况，可以看出它们的分布较为不均。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入数据</span><br>path = <span class="hljs-string">&#x27;D:/Pywork/2018_CCF_BDCI_CHINA_TOP1/project/preliminary_training_set/train_all.csv&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">import_data</span>(<span class="hljs-params">path</span>):<br>    train_data = pd.read_csv(path, low_memory=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">return</span> train_data<br><br>train_data = import_data(path)<br><br><span class="hljs-comment"># current_service 条形图</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">service_view</span>(<span class="hljs-params">train_data,categories</span>):<br>    data_by_service = train_data.groupby(categories).size().reset_index(name=<span class="hljs-string">&#x27;counts&#x27;</span>)<br>    data_by_service[categories] = data_by_service[categories].astype(<span class="hljs-built_in">str</span>)<br>    <span class="hljs-built_in">print</span>(data_by_service)<br>    <span class="hljs-comment"># 随机生成几种颜色，reshape第二个参数-1指随着N变化，第一维度填满有剩就来填第二维</span><br>    <span class="hljs-comment"># 生成的是随机的N组三通道(r,g,b)的颜色</span><br>    N = <span class="hljs-number">7</span><br>    colors = np.random.rand(N * <span class="hljs-number">3</span>).reshape(N, -<span class="hljs-number">1</span>)<br>    fig, ax = plt.subplots()<br><br>    ax.bar(data_by_service[categories], data_by_service[<span class="hljs-string">&#x27;counts&#x27;</span>], color=colors)<br>    plt.xticks(rotation=<span class="hljs-number">270</span>)<br>    plt.xlabel(categories)<br>    plt.ylabel(<span class="hljs-string">&#x27;counts&#x27;</span>)<br>    plt.show()<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;current_service&#x27;</span><br>service_view(train_data,<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/E.Y6SXlAuAZdQj0B0gLQ01oNeJ6d9fTl6fpWJMuVF5U!/b/dLYAAAAAAAAA&bo=gALgAQAAAAADF1E!&rf=viewer_4&t=5"></p><p>多分类问题，典型的评价指标为<strong>macro-f1</strong>：首先针对每个套餐类别，统计分别统计TP（预测答案正确），FP（错将其他类预测为本类），FN（本类标签预测为其他类标）。计算<strong>Precision</strong>(精确率)和<strong>Recall</strong>(召回率)</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/2CgTAjY8XgkPczB78E3PLBNvufN45qQ.lN*Y3ZNflc8!/b/dL4AAAAAAAAA&bo=vQHsAAAAAAADF2I!&rf=viewer_4&t=5"></p><p>举个具体场景的例子：</p><p>假如某个班级有男生80人,女生20人,共计100人.<br>目标是找出所有女生.<br>现在某人挑选出50个人,其中20人是女生,另外还错误的把30个男生也当作女生挑选出来了.<br>作为评估者的你需要来评估(evaluation)下他的工作<br><img src="http://pjqhk6p7v.bkt.clouddn.com/tp_fp.png"><br>通过表格可以得出：<br>TP:20<br>FP:30<br>FN:0<br>TN:50</p><p>精确率(precision)$$P &#x3D; \frac{TP}{TP+FP}$$<br>召回率(recall)的公式是：$$R&#x3D;\frac{TP}{TP+NP}$$,</p><p>首先我们可以计算<strong>精确率(precision)</strong>:很容易，我们可以得到,他把其中70(20女+50男)人判定正确了,而总人数是100人，所以它的accuracy就是70%(70 &#x2F; 100).</p><p><strong>召回率(recall)</strong>:它计算的是所有”正确被检索的item(TP)”占所有”应该检索到的item(TP+FN)”的比例,所以它的recall为100%.<br>如果单看某一个指标，预测结果是不会被正确衡量的。比如在以上例子中，如果我全部判断为女生，则召回率可以达到100%，单看召回率它是一个非常准确的预测，但此时你能说该模型的预测效果好吗，很显然不能。所以必须结合P,R一起看。结合起来最常见的方法应该就是F-Measure了，有些地方也叫做F-Score：<br>$$F&#x3D;\frac{(a^2+1)P*R} {a^2(P+R)}$$<br>当参数a&#x3D;1时，就是最常见的F1了：<br>$$F1 &#x3D; \frac{2PR} {P+R} $$</p><p>回到赛题，在得到每个类别下的F1-score后，对各个类别的F1-score求均值，得到最后的评测结果，计算方式如下：<br>$$score&#x3D;\frac 1n\sum{f1_k}$$</p><h5 id="原始特征与标签相关性"><a href="#原始特征与标签相关性" class="headerlink" title="原始特征与标签相关性"></a>原始特征与标签相关性</h5><p>以下是关于原始特征<strong>service_type和label相关性的观察图表</strong>：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/KY5lH8e4LrLIXcvf7VHrq708jx51ArS2kVKuYJVXiGM!/b/dLkAAAAAAAAA&bo=sARtAgAAAAADF.k!&rf=viewer_4&t=5"><br>可以明显的看出一个规律，service_type可以将套餐分为两个部分，这两个部分是没有交叉的，其中一类有8个，另外一类有3个。这给我们比赛带来一个思路是，可以分模型预测。</p><p><strong>关于age和label相关性的观察图表：</strong><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/X5b5TqayXddoVT.HM*t6M24cdgZGjZxdJrepRtMBaoc!/b/dL4AAAAAAAAA&bo=gALgAQAAAAADF1E!&rf=viewer_4&t=5"></p><p>我们可以看到对于年龄来讲，基本上符合电信用户群体的分布,但是有很多0岁的异常值，对于异常值,可以先不做处理，或填充-1.</p><p><strong>关于gender和label相关性的观察图表：</strong><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/AQZ*DQ*mGsh*7Wi53H.sJja7P16s76WXyP5mfYD8SOM!/b/dL8AAAAAAAAA&bo=gALgAQAAAAADF1E!&rf=viewer_4&t=5"><br>我们观察到性别中有0 的缺省值，对于这部分，我们使用了两种方法处理，一种是填充service_type对应字段的众数，和原始值。最终选取了原始值.</p><h3 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2.数据预处理"></a><strong>2.数据预处理</strong></h3><p>首先将分类的label映射到0-11数字当中便于处理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;label&#x27;</span>]</span> = train<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;current_service&#x27;</span>]</span><span class="hljs-selector-class">.map</span>(p)<br></code></pre></td></tr></table></figure><p>为了避免利用pandas.read_csv()导入的类型不统一。可以传入dtype&#x3D;set_str，pandas.read_csv(dtype&#x3D;set_str),来指定类型，set_str是自己创建的字典，每个字段指向的类型，均可自己设定。</p><p>对于年龄，话费不合理的值，用nan值替换。</p><h3 id="3-特征工程"><a href="#3-特征工程" class="headerlink" title="3.特征工程"></a><strong>3.特征工程</strong></h3><p>(1)关联规则<br>受max-encoding的方法的启发，对有关联关系的话费字段，1_total_fee, 2_total_fee, 3_total_fee, 4_total_fee四个字段的构建关联规则，这样可以利用整体信息，对话费字段这个强特征进行降维编码。使得其数据更加具有代表性<br>(2) 业务特征<br>业务特征的部分，我们深入研究了联通的套餐消费场景，从比赛的一开始，首先就通过联通官网以及消费论坛认真的开始调研工作，深入了解了联通的各种套餐特点和用户群差别。通过熟悉套餐的特性，我们可以为各种特定用户群推荐适宜他们的套餐，比如腾讯天王卡玩腾讯游戏看腾讯视频不花钱是深度腾讯用户的福音，蚂蚁大宝卡则可以赠送2g无差别流量给高流量消费者。联通传统套餐的各种优惠活动，比如预充值冲100返流量和话费，适合平时那些流量和话费不够用的用户，充值返话费则适合那些薅羊毛的用户。对此我们针对用户的流量和通话做了一系列特征，比例、差值，求和等，力求尽可能的描绘出一幅用户画像。</p><p>提出了以下几种针对业务的特征：</p><ol><li>话费减去16元是否是整数</li><li>流量的有效数字是否是27的整数倍</li><li>话费的有效数字能否被15乘除</li><li>话费是否是整数（用户可能未超套餐）</li><li>连续两个月套餐的差值能否被5,10,15,27,30等计费单元整除</li><li>四个月话费的最小值</li><li>计算流量的平均单价</li><li>计算通话时间的平均单价</li><li>等等…</li></ol><p> 伪代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 平均值 按照行 axis=1</span><br>data[month_fee[:4]].mean(<span class="hljs-attribute">axis</span>=1)<br>data[month_fee[:3]].mean(<span class="hljs-attribute">axis</span>=1)<br>data[month_fee[:2]].mean(<span class="hljs-attribute">axis</span>=1)<br>data[month_fee[:4]].std(<span class="hljs-attribute">axis</span>=1)<br><br><span class="hljs-comment"># CV 变异系数 = 标准差/平均数 </span><br><span class="hljs-comment"># 反映数据离散程度的绝对值，可以认为变异系数和极差、标准差和方差一样，可以消除测量尺度和量纲的影响</span><br>data[<span class="hljs-string">&#x27;total_fee_std4&#x27;</span>] / (data[<span class="hljs-string">&#x27;total_fee_mean4&#x27;</span>] + 0.1)<br><br><span class="hljs-comment"># 四个月最大，最小话费</span><br>data[month_fee[:4]].max(<span class="hljs-attribute">axis</span>=1)<br>data[month_fee[:4]].min(<span class="hljs-attribute">axis</span>=1)<br><br><span class="hljs-comment"># 电话时间 差，和，最小，最大</span><br>data[<span class="hljs-string">&#x27;service2_caller_time&#x27;</span>]-data[<span class="hljs-string">&#x27;service1_caller_time&#x27;</span>]<br>data[<span class="hljs-string">&#x27;service2_caller_time&#x27;</span>]+data[<span class="hljs-string">&#x27;service1_caller_time&#x27;</span>]<br>data[[<span class="hljs-string">&#x27;service2_caller_time&#x27;</span>, <span class="hljs-string">&#x27;service1_caller_time&#x27;</span>]].min(<span class="hljs-attribute">axis</span>=1)<br>data[[<span class="hljs-string">&#x27;service2_caller_time&#x27;</span>, <span class="hljs-string">&#x27;service1_caller_time&#x27;</span>]].max(<span class="hljs-attribute">axis</span>=1)<br><br><span class="hljs-comment">#  话费是否是整数</span><br>data[<span class="hljs-string">&#x27;&#123;&#125;_1&#x27;</span>.format(fee)] = ((data[fee] % 1 == 0) &amp; (data[fee] != 0))<br>data[<span class="hljs-string">&#x27;&#123;&#125;_01&#x27;</span>.format(fee)] = ((data[fee] % 0.1 == 0) &amp; (data[fee] != 0))<br><br><span class="hljs-comment"># 分组标准化</span><br>def grp_standard(data,keys,names,<span class="hljs-attribute">drop</span>=<span class="hljs-literal">False</span>):<br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>        new_name = name <span class="hljs-keyword">if</span> drop <span class="hljs-keyword">else</span> name + <span class="hljs-string">&#x27;_&#x27;</span> + keys + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-string">&#x27;standardize&#x27;</span><br>        mean_std = data.groupby(keys, <span class="hljs-attribute">as_index</span>=<span class="hljs-literal">False</span>)[name].agg(&#123;<span class="hljs-string">&#x27;mean&#x27;</span>: <span class="hljs-string">&#x27;mean&#x27;</span>, <span class="hljs-string">&#x27;std&#x27;</span>: <span class="hljs-string">&#x27;std&#x27;</span>&#125;)<br>        data = data.merge(mean_std, <span class="hljs-attribute">on</span>=keys, <span class="hljs-attribute">how</span>=<span class="hljs-string">&#x27;left&#x27;</span>)<br>        data[new_name] = ((data[name]-data[<span class="hljs-string">&#x27;mean&#x27;</span>])/data[<span class="hljs-string">&#x27;std&#x27;</span>]).fillna(0).astype(np.float32)<br>        # 防止除0报错<br>        data[new_name] = data[new_name].replace(-np.inf, 0).fillna(0)<br>        data.drop([<span class="hljs-string">&#x27;mean&#x27;</span>, <span class="hljs-string">&#x27;std&#x27;</span>], <span class="hljs-attribute">axis</span>=1, <span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>        return data<br><br><span class="hljs-comment"># 按照 合约类型 标准化</span><br> data = grp_standard(data, <span class="hljs-string">&#x27;contract_type&#x27;</span>, [<span class="hljs-string">&#x27;1_total_fee_log&#x27;</span>], <span class="hljs-attribute">drop</span>=<span class="hljs-literal">False</span>)<br> <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br> #  年龄分组<br>data[<span class="hljs-string">&#x27;age_scatter&#x27;</span>] = pd.qcut(data[<span class="hljs-string">&#x27;age&#x27;</span>], 5)<br>data = grp_standard(data, <span class="hljs-string">&#x27;age_scatter&#x27;</span>, [<span class="hljs-string">&#x27;1_total_fee_log&#x27;</span>], <span class="hljs-attribute">drop</span>=<span class="hljs-literal">False</span>) <br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br><span class="hljs-comment"># online_time 分组</span><br>data[<span class="hljs-string">&#x27;online_time_scatter&#x27;</span>] = pd.qcut(data[<span class="hljs-string">&#x27;online_time&#x27;</span>], 5)<br>data = grp_standard(data, <span class="hljs-string">&#x27;online_time_scatter&#x27;</span>, [<span class="hljs-string">&#x27;1_total_fee_log&#x27;</span>], <span class="hljs-attribute">drop</span>=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br><span class="hljs-comment"># 热编码</span><br>data = pd.get_dummies(data, columns=[<span class="hljs-string">&#x27;contract_type&#x27;</span>], <span class="hljs-attribute">dummy_na</span>=-1)<br>data = pd.get_dummies(data, columns=[<span class="hljs-string">&#x27;net_service&#x27;</span>], <span class="hljs-attribute">dummy_na</span>=-1)<br>data = pd.get_dummies(data, columns=[<span class="hljs-string">&#x27;complaint_level&#x27;</span>], <span class="hljs-attribute">dummy_na</span>=-1)<br>    <br></code></pre></td></tr></table></figure><h3 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3.构建模型"></a><strong>3.构建模型</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;multi:softprob&#x27;</span>,<br>         <span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.5</span>,<br>         <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">6</span>,<br>         <span class="hljs-string">&#x27;silent&#x27;</span>: <span class="hljs-number">1</span>,<br>         <span class="hljs-string">&#x27;num_class&#x27;</span>: <span class="hljs-number">3</span>,<br>         <span class="hljs-string">&#x27;eval_metric&#x27;</span>: <span class="hljs-string">&quot;mlogloss&quot;</span>,<br>         <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">3</span>,<br>         <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,<br>         <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,<br>         <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">66</span><br>         &#125;<br><span class="hljs-comment"># 单独拿 service_type=1出来训练 train_feat1</span><br>train_preds1, test_preds1 = xgb_cv(params, train_feat1, test_feat1, predictors1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;xgb_cv函数返回的test_preds1的类&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(test_preds1)))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xgb_cv</span>(<span class="hljs-params">params, train_feat, test_feat, predictors, label=<span class="hljs-string">&#x27;label&#x27;</span>,groups=<span class="hljs-literal">None</span>,cv=<span class="hljs-number">5</span>,stratified=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始CV 5折训练...&#x27;</span>)<br>    t0 = time.time()<br>    <span class="hljs-comment"># train_feat[label].nunique() 不同label的个数</span><br>    train_preds = np.zeros((<span class="hljs-built_in">len</span>(train_feat), train_feat[label].nunique()))<br>    test_preds = np.zeros((<span class="hljs-built_in">len</span>(test_feat), train_feat[label].nunique()))<br>    xgb_test = xgb.DMatrix(test_feat[predictors])<br>    models = []<br>    <span class="hljs-comment"># len(train_feat)个样本分成 5个样本集</span><br>    kf = KFold(<span class="hljs-built_in">len</span>(train_feat), n_folds=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">520</span>)<br>    <span class="hljs-keyword">for</span> i, (train_index, test_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf):<br>        <span class="hljs-comment"># 将测试集均分 取一份当测试集</span><br>        xgb_train = xgb.DMatrix(train_feat[predictors].iloc[train_index], train_feat[label].iloc[train_index])<br>        xgb_eval = xgb.DMatrix(train_feat[predictors].iloc[test_index], train_feat[label].iloc[test_index])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;..........开始第&#123;&#125;轮训练&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        params = &#123;<span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;multi:softprob&#x27;</span>, <span class="hljs-comment"># 多分类的问题</span><br>                  <span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.1</span>,                    <span class="hljs-comment"># 如同学习率</span><br>                  <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">6</span>,                <span class="hljs-comment"># 构建树的深度，越大越容易过拟合</span><br>                  <span class="hljs-string">&#x27;silent&#x27;</span>: <span class="hljs-number">1</span>,      <span class="hljs-comment"># 取0时表示打印出运行时信息，取1时表示以缄默方式运行，不打印运行时信息。缺省值为0</span><br>                  <span class="hljs-string">&#x27;num_class&#x27;</span>: <span class="hljs-number">11</span>,  <span class="hljs-comment"># 类别数，与 multisoftmax 并用</span><br>                  <span class="hljs-string">&#x27;eval_metric&#x27;</span>: <span class="hljs-string">&quot;mlogloss&quot;</span>,  <span class="hljs-comment"># 评价指标 negative log-likelihood</span><br>                  <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">3</span>,<br>                  <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,   <span class="hljs-comment"># 随机采样训练样本</span><br>                  <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,  <span class="hljs-comment"># 生成树时进行的列采样</span><br>                  <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">66</span><br>                  &#125; <span class="hljs-keyword">if</span> params <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> params<br>        watchlist = [(xgb_train, <span class="hljs-string">&#x27;train&#x27;</span>), (xgb_eval, <span class="hljs-string">&#x27;val&#x27;</span>)]<br>        clf = xgb.train(params,<br>                        xgb_train,<br>                        num_boost_round=<span class="hljs-number">3000</span>,<br>                        evals=watchlist,<br>                        verbose_eval=<span class="hljs-number">50</span>,<br>                        early_stopping_rounds=<span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 每次更新的是从训练集中划出来的一部分测试集</span><br>        train_preds[test_index] += clf.predict(xgb_eval)<br>        <span class="hljs-comment"># xgb_test 是 xgb.DMatrix(test_feat) 的返回值</span><br>        test_preds += clf.predict(xgb_test)<br>        models.append(clf)<br>        pickle.dump(models, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;xgb_&#123;&#125;.model&#x27;</span>.<span class="hljs-built_in">format</span>(datetime.datetime.now().strftime(<span class="hljs-string">&#x27;%Y%m%d_%H%M%S&#x27;</span>)), <span class="hljs-string">&#x27;+wb&#x27;</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用时&#123;&#125;秒&#x27;</span>.<span class="hljs-built_in">format</span>(time.time()-t0))<br>        <span class="hljs-keyword">return</span> train_preds, test_preds/<span class="hljs-number">5</span><br><br></code></pre></td></tr></table></figure><p>xgb_cv函数解读：划分数据集的方法采用K折交叉验证，K折交叉验证具体实现是</p><ul><li>将数据集平均分割成K个等份<br><strong>sklearn.cross_validation.KFold</strong>(len(train_feat), n_folds&#x3D;5, shuffle&#x3D;True, random_state&#x3D;520)<br><strong>n_folds&#x3D;5</strong>，K折验证的K值；默认3，最小为2<br><strong>shuffle</strong>默认False;shuffle会对数据产生随机搅动(洗牌)<br><strong>random_state</strong>默认None，随机种子</li><li>使用1份数据作为测试数据，其余作为训练数据</li><li>计算测试准确率</li><li>使用不同的测试集，重复2、3步骤</li><li>对测试准确率做平均，作为对未知数据预测准确率的估计</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">params</span> = &#123;<span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;multi:softprob&#x27;</span>, <span class="hljs-meta"># 多分类的问题</span><br>          <span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.1</span>,                    <span class="hljs-meta"># 如同学习率</span><br>          <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">6</span>,                <span class="hljs-meta"># 构建树的深度，越大越容易过拟合</span><br>          <span class="hljs-string">&#x27;silent&#x27;</span>: <span class="hljs-number">1</span>,      <span class="hljs-meta"># 取0时表示打印出运行时信息，取1时表示以缄默方式运行，不打印运行时信息。缺省值为0</span><br>          <span class="hljs-string">&#x27;num_class&#x27;</span>: <span class="hljs-number">11</span>,  <span class="hljs-meta"># 类别数，与 multisoftmax 并用</span><br>          <span class="hljs-string">&#x27;eval_metric&#x27;</span>: <span class="hljs-string">&quot;mlogloss&quot;</span>,  <span class="hljs-meta"># 评价指标 negative log-likelihood</span><br>          <span class="hljs-string">&#x27;min_child_weight&#x27;</span>: <span class="hljs-number">3</span>,<br>          <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">0.7</span>,   <span class="hljs-meta"># 随机采样训练样本</span><br>          <span class="hljs-string">&#x27;colsample_bytree&#x27;</span>: <span class="hljs-number">0.7</span>,  <span class="hljs-meta"># 生成树时进行的列采样</span><br>          <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">66</span><br>          &#125; <span class="hljs-keyword">if</span> <span class="hljs-keyword">params</span> <span class="hljs-keyword">is</span> None <span class="hljs-keyword">else</span> <span class="hljs-keyword">params</span><br></code></pre></td></tr></table></figure><p><strong>xgb.train(params, xgb_train,num_boost_round&#x3D;3000,<br>evals&#x3D;watchlist, verbose_eval&#x3D;50, early_stopping_rounds&#x3D;50)</strong><br>**params:**训练的参数，上面代码块中有详细的解释<br>**xgb_train:**训练的数据</p><p>测试集的预测结果取5次的平均。</p><p>代码链接：<a href="https://pan.baidu.com/s/1VcY_BWTLPcONr2WGgr7bZA">https://pan.baidu.com/s/1VcY_BWTLPcONr2WGgr7bZA</a><br>密码：idgg</p><p>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/hOjLTNEBAt3DNiT6F-yHCw">机器学习初学者</a></li><li><a href="https://blog.csdn.net/iyuanshuo/article/details/80142730">Xgboost参数</a></li></ul><hr><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>XGBoost</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你对一万小时定律有什么误解?</title>
    <link href="/2018/12/28/%E4%BD%A0%E5%AF%B9%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%AE%9A%E5%BE%8B%E6%9C%89%E4%BB%80%E4%B9%88%E8%AF%AF%E8%A7%A3/"/>
    <url>/2018/12/28/%E4%BD%A0%E5%AF%B9%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%AE%9A%E5%BE%8B%E6%9C%89%E4%BB%80%E4%B9%88%E8%AF%AF%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="认识刻意练习"><a href="#认识刻意练习" class="headerlink" title="认识刻意练习"></a>认识刻意练习</h3><p>   有没有那么一本书里的内容让你觉得相见恨晚？《刻意练习》是我觉得相见恨晚的一本书，里面的学习方法对我的触动很大。</p><p>   我们都听过一万小时定律，意思是说要成为一个领域的专家，需要一万个小时，这被很多人误解我只要花够一万个小时在某个领域，我就可以成为那个领域的专家。其实这种为了完成任务式的一万个小时根本没有用。我想格拉德威尔先生在《异类》一书中提出一万小时定律的本意并不是为了强调那一万个小时。</p><p>   接下来看看一万个小时究竟有什么问题，驳斥1万小时定律可以玩一个巧妙的思想游戏，这就是古希腊哲学家欧布里德<br>（Eubulides）提出的沙堆悖论（Sorites paradox）：<br>1粒沙子不是堆。如果1粒沙子不是堆，那么2粒沙子也不是堆；如果2粒沙子不是堆，那么3粒沙子也不是堆；以此类推，9999粒沙子也不是堆；因此，1万粒沙子还不是堆。<strong>“破解”沙堆悖论时，我们经常不得不设定一个固定的边界</strong>。如果我们说“1万粒沙粒是一堆沙”，那么少于1万粒沙粒组成的就不能称之为一堆沙。那么这样区分9999粒沙和10001粒沙就有点不合理。这样不得不设定一个可变的边界，但是这个边界是多少呢？我们现在并不知道。那么最初设定的“1万粒沙粒是一堆沙”作为知识的价值就被削减了。<strong>练习的成果并不与时间呈正相关，这一点，也取决于练习方法</strong>。<strong>刻意练习是成为某一个领域专家的正确练习方式，而并不是时间量的达标</strong>。</p><h3 id="刻意练习的必要条件-—有目的的练习"><a href="#刻意练习的必要条件-—有目的的练习" class="headerlink" title="刻意练习的必要条件 —有目的的练习"></a>刻意练习的必要条件 —有目的的练习</h3><p><strong>有目的的练习</strong>是我们迈向<strong>刻意练习</strong>的第一步，有目的的练习具有以下四个特征：</p><p> <strong>1. 有目的的练习具有定义明确的特定目标</strong><br> 假想一个音乐学生，给自己设定了一个目标“连续三次，不犯任何错误，以适当的速度弹奏完曲子”，和一个完整的弹奏完一首曲子没有设置明确的目标的学生相比，谁的进步更快，明显是后者，因为如果不制定这样的目标，根本没办法判断练习是否是正确了。</p><p><strong>2.有目的的练习是专注的</strong><br>在进行练习时，必须把全部集中力放在你的任务上。</p><p><strong>3.有目的的练习包含反馈</strong><br>不论你在努力做什么事情，都需要反馈来准确辨别你在哪些方面还有不足，以及怎么会存在这些不足。如果没有反馈（要么是你自己给自己提出的，要么是局外人给你提出的），你不可能搞清楚你在哪些方面还需提高，或者你现在离实现你的目标有多远。</p><p><strong>4.有目的的练习需要走出舒适区</strong><br>走出舒适区，意味着要试着做一些你以前没做过的事情。有时候，你也许发现，做一些没做过的事情，相对较为容易，然后你会继续逼迫自己。但有时候，你偶然碰到了那些让你感到很难做好的事情，似乎你永远也做不了。想办法去逾越这些障碍，是通向有目的的练习的隐藏钥匙。试着做不同的事情，而非更难的事情。</p><p><strong>总结一下有目的的练习:</strong><br>走出你的舒适区，但要以专注的方式制订明确的目标，为达到那些目标制订一个计划，并且想出监测你的进步的方法。哦，还要想办法保持你的动机。</p><p>  有目的的练习只能保证人体短时间的记忆，当有目的练习达到瓶颈时，我们需要另找办法。这时我们就需要在有目的的练习上再建立心理表征，心理表征是什么呢? </p><h3 id="创建心理表征"><a href="#创建心理表征" class="headerlink" title="创建心理表征"></a>创建心理表征</h3><p>  心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。一个简单的例子是视觉形象。例如，一提到蒙娜丽莎，很多人马上便会在脑海中“看到”那幅著名油画的形象；那个形象就是蒙娜丽莎在他们脑海中的心理表征。由于各个行业或领域之间心理表征的细节具有极大差异，我们难以给出一个十分清晰的顶层定义，但基本上，这些表征是信息预先存在的模式（比如事实、图片、规则、关系，等等），这些模式保存在长时记忆之中，可以用于有效且快速地顺应某些类型的局面。对于所有的心理表征，有一点是相同的：尽管短时记忆存在局限，但它们使得人们可以迅速地处理大量信息。</p><p>而创建心理表征是《刻意练习》中的重要环节，艾利克森在《刻意练习》之中提出了刻意练习的指向与本质，它就是长时记忆。核心观点就是，那些处于中上水平的人们，拥有一种较强的记忆能力：长时记忆。长时记忆正是区分卓越者与一般人的一个重要能力。</p><p>长时记忆的培养要点主要有以下几个：<br>◆<strong>赋予意义，精细编码：</strong><br>（准）专家们能非常快地明白自己领域的单词与术语，在存<br>储信息的时候，可以有意识地采取元认知的各项加工策略。</p><p>◆<strong>提取结构或模式：</strong><br>往往需要将专业领域的知识、提取结构或者模式以更好的方式存储。比如，专家级的开发者善用设计模式。</p><p>◆<strong>加快速度、增加连接：</strong><br>通过大量重复的刻意练习，专家在编码与提取过程方面比新<br>手都快很多，增加了长时记忆与工作记忆之间的各种通路。</p><p>所以，刻意练习的本质是去买SSD硬盘，而不是纯粹卖苦力，更不是帮畅销书作者们营销，喊喊热血口号：1万小时，今天，你坚持了吗？</p><h3 id="如何实践刻意练习"><a href="#如何实践刻意练习" class="headerlink" title="如何实践刻意练习"></a>如何实践刻意练习</h3><p>  首先，它需要一个已经得到合理发展的行业或领域，也就是说，在那一行业或领域之中，最杰出的从业者已达到一定程度的表现水平，使他们与其他刚刚进入该行业或领域的人们明显地区分开来。<strong>找出杰出人物和其他人的差别</strong>。一旦你已经辨认出某个行业或领域中的杰出人物，下一步就是<strong>有针对性地思考他们都做了些什么</strong>，使自己从同一个行业或领域中那些成就不太卓著的人之中脱颖而出，同时<strong>还要思考哪些训练方法帮助他们实现了卓越</strong>。问题的一部分出在心理表征发挥的关键作用。在许多行业或领域之中，心理表征质量的高低将最杰出人物和其他人区分开来。</p><p><strong>其次，自己设计练习方法，设定明确的目标与计划</strong>。</p><p><strong>最后用“三个F”创建有效的心理表征</strong>。这三个F，其实是以字母F开头三个单词，即：<strong>专注</strong>（focus）、<strong>反馈</strong>（feedback）以及<strong>纠正</strong>（fix it）。将技能分解成一些组成部分，以便反复地练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决它们。</p><p>小tips：富兰克林如何提高写作技巧</p><p>  富兰克林首先偶然看到了一期英国杂志《观察者》,被里面高质量的文章深深吸引，他立下目标决定也要写出这样高质量的文章。于是他开始观察，一旦他忘记了文章中的一些句子的措辞，可以怎样以最为接近的方式重写那些句子。所以他选择了自己喜欢的几篇文章，然后写下对每个内容的简短描述，只要能够让他回想起来句子是什么意思就行。</p><p>  不久，他开始厌倦从一开始自己写下的线索中重写文章。他的目的不是复写这些文章，他的目的是要让自己写的文章和它们一样用词精炼，描写细致入微。所以他写完后，开始对比文章，在必要时纠正自己的版本，这教会了富兰克林如何明确且中肯地表达观点。</p><p>  后来他发现自己的词汇积累量并不像《观察者》的投稿者那样丰富，并不是说他不认识，而是无法在写作时“文思泉涌，信手拈来”。为了这一目标，他想出了前一种练习的变体，他确定，写诗将迫使他想出不同的词语。因此他找到《观察者》杂志的一些文章，并将他们改写成诗句。再接下来，等待了足够多的时间之后，再把这些诗句改写成散文。这使他形成了一个习惯，就是找到正确的词汇，并且增加对词汇的积累量，以至于他可以迅速从记忆中调用这些词汇。</p><p>  最后，富兰克林再来完善文章的总体结构和逻辑。他找来《观察者》的文章，为每一个句子都写下一些提示的线索，并把顺序打乱，使词汇处于完全无序的状态。然后等到足够长的时间，它忘记那些文章如何措辞，再一次复写文章。他找来从某一篇文章中摘抄下来的、没有按顺序排列的提示线索，并按他认为最符合逻辑的顺序来排列，根据每条线索写出一些句子，并将自己写的结果与最初的文章进行对比。这样的练习，迫使他小心翼翼地思考怎样在文章中理清思路。如果他发现，在文章中的某些地方，他整理的思路与原文作者的思路不一致，他会纠正自己，并试着从这些错误中学习。</p><p>我们可以类比富兰克林提高写作技巧的方法来制定自己的刻意练习方法。</p><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>study skills</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的个人网站(彩蛋)</title>
    <link href="/2018/12/26/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E5%BD%A9%E8%9B%8B/"/>
    <url>/2018/12/26/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E5%BD%A9%E8%9B%8B/</url>
    
    <content type="html"><![CDATA[<p>本篇彩蛋是基于上两篇个人网站搭建系列博文增加新的功能（评论、打赏）<br>以Anisina主题为例</p><p>难度指数：♥♥<br>系统环境：win8</p><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>本文采用的是valine评论系统，首先你需要注册一个<a href="https://leancloud.cn/">leancloud</a>账户,然后创建一个应用来存储管理评论内容,注册和创建新应用完了之后，就完成了准备工作。</p><p><strong>1.准备工作就绪后，然后修改 Anisina主题配置文件 _config.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Valine comment system https://valine.js.org</span><br><span class="hljs-attr">valine:</span> <br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">appid:</span>  <span class="hljs-string">KPXIfOuMVwWIv2Skprm5gYB</span><br>  <span class="hljs-attr">appkey:</span> <span class="hljs-string">f92SiTdYRrLO0zwfdQ</span><br>  <span class="hljs-attr">verify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#验证码</span><br>  <span class="hljs-attr">notify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#评论回复提醒</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">mm</span> <span class="hljs-comment">#评论列表默认头像样式</span><br>  <span class="hljs-attr">placeholder:</span> <span class="hljs-string">Just</span> <span class="hljs-string">go</span> <span class="hljs-string">go</span> <span class="hljs-comment">#评论框占位符</span><br>  <br><span class="hljs-attr">CDN:</span><br>  <span class="hljs-attr">valine:</span> <span class="hljs-string">http://unpkg.com/valine@1.2.0-beta1/dist/Valine.min.js</span><br></code></pre></td></tr></table></figure><p>这里的appid，appkey可在创建的新应用的设置里面查看<br>新应用名称&gt;设置&gt;应用Key<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/TzCVOAq*UEKUbBlUDelxgRYGM3KQVijH5xouYp4MJB4!/b/dL4AAAAAAAAA&bo=IgLrAQAAAAADF*g!&rf=viewer_4&t=5"></p><p><strong>2.修改 Anisina&#x2F;layout&#x2F;_partial&#x2F;article.ejs</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;<span class="hljs-meta">%</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">(!index &amp;&amp; post.comments)</span>&#123; <span class="hljs-meta">%</span>&gt;<br>    &lt;<span class="hljs-meta">%</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">(theme.duoshuo.on)</span> &#123; <span class="hljs-meta">%</span>&gt;<br>      &lt;<span class="hljs-meta">%</span>- partial<span class="hljs-comment">(&#x27;comments/duoshuo&#x27;, &#123;</span><br><span class="hljs-comment">          key: post.path,</span><br><span class="hljs-comment">          title: post.title,</span><br><span class="hljs-comment">          url: config.url+url_for(post.path)</span>,<br>          &#125;) <span class="hljs-meta">%</span>&gt;<br>    &lt;<span class="hljs-meta">%</span> &#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(theme.youyan.on)</span> &#123; <span class="hljs-meta">%</span>&gt;<br>        &lt;<span class="hljs-meta">%</span>- partial<span class="hljs-comment">(&#x27;comments/youyan&#x27;)</span> <span class="hljs-meta">%</span>&gt;<br>    &lt;<span class="hljs-meta">%</span> &#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(theme.disqus.on)</span> &#123; <span class="hljs-meta">%</span>&gt;<br>        &lt;<span class="hljs-meta">%</span>- partial<span class="hljs-comment">(&#x27;comments/disqus&#x27;, &#123;</span><br><span class="hljs-comment">            shortname: theme.disqus.shortname</span><br><span class="hljs-comment">          &#125;)</span> <span class="hljs-meta">%</span>&gt;<br>    &lt;<span class="hljs-meta">%</span> &#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(config.disqus_shortname)</span> &#123; <span class="hljs-meta">%</span>&gt;<br>        &lt;<span class="hljs-meta">%</span>- partial<span class="hljs-comment">(&#x27;comments/disqus&#x27;, &#123;</span><br><span class="hljs-comment">            shortname: config.disqus_shortname</span><br><span class="hljs-comment">          &#125;)</span> <span class="hljs-meta">%</span>&gt;<br>   &lt;<span class="hljs-meta">%</span> &#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(theme.valine.on)</span>&#123; <span class="hljs-meta">%</span>&gt;<br>       &lt;<span class="hljs-meta">%</span>- partial<span class="hljs-comment">(&#x27;comments/valine&#x27;, &#123;</span><br><span class="hljs-comment">           key: post.slug,</span><br><span class="hljs-comment">           title: post.title,</span><br><span class="hljs-comment">           url: config.url+url_for(post.path)</span><br>       &#125;) <span class="hljs-meta">%</span>&gt;<br>    &lt;<span class="hljs-meta">%</span> &#125; <span class="hljs-meta">%</span>&gt;<br>&lt;<span class="hljs-meta">%</span> &#125; <span class="hljs-meta">%</span>&gt;<br><br></code></pre></td></tr></table></figure><p><strong>3.创建 layout&#x2F;_partial&#x2F;comments&#x2F;valine.ejs 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;comments&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 2em; padding: 2em; background: rgba(255, 255, 255, 0.5)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;vcomment&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%- theme.CDN.valine %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Valine</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#vcomment&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">notify</span>: <span class="hljs-string">&#x27;&lt;%= theme.valine.notify %&gt;&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">verify</span>: <span class="hljs-string">&#x27;&lt;%= theme.valine.verify %&gt;&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">app_id</span>: <span class="hljs-string">&quot;&lt;%= theme.valine.appid %&gt;&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">app_key</span>: <span class="hljs-string">&quot;&lt;%= theme.valine.appkey %&gt;&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">placeholder</span>: <span class="hljs-string">&quot;&lt;%= theme.valine.placeholder %&gt;&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">avatar</span>: <span class="hljs-string">&quot;&lt;%= theme.valine.avatar %&gt;&quot;</span></span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成，部署hexo后就可以看到评论功能新增上去了</p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><p>效果可以先预览一下</p><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe><p><strong>1.首先到我的github页去Fork 一下这个项目donate-page-yu</strong><br><a href="https://github.com/YUTING0907">https://github.com/YUTING0907</a><br>这个我是Fork 了TinyJay的repositories </p><p><strong>2.然后在donate-page-yu&#x2F;simple&#x2F;images&#x2F;下</strong> 修改你的支付宝，微信收款等其他收款码，当然你也可以不修改, 扫我的收款码就可以了~</p><p><strong>3.进入这个路径：donate-page&#x2F;simple&#x2F;index.html,复制该路径，然后进入</strong><a href="http://raw.githack.com/">http://raw.githack.com/</a> <strong>生成对应的访问链接。</strong><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/XTbfuH3ETb1NM2DJo.MKvH9ByYiaV4R0R0mUsWgD8EI!/b/dL8AAAAAAAAA&bo=zwQMAgAAAAADF*c!&rf=viewer_4&t=5"></p><p><strong>4.修改iframe</strong></p><p>将下面的代码中src对应的网页指向改为刚刚生成的网页，之后将下面的iframe代码块放到文章中就可以了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;iframe <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html </span><br><span class="hljs-string">&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;&quot;</span>  <br><span class="hljs-attribute">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attribute">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span>&gt;&lt;/iframe&gt;<br></code></pre></td></tr></table></figure><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个人越过越年轻是喜还是悲</title>
    <link href="/2018/12/23/%E4%B8%80%E4%B8%AA%E4%BA%BA%E8%B6%8A%E8%BF%87%E8%B6%8A%E5%B9%B4%E8%BD%BB%E6%98%AF%E5%96%9C%E8%BF%98%E6%98%AF%E6%82%B2/"/>
    <url>/2018/12/23/%E4%B8%80%E4%B8%AA%E4%BA%BA%E8%B6%8A%E8%BF%87%E8%B6%8A%E5%B9%B4%E8%BD%BB%E6%98%AF%E5%96%9C%E8%BF%98%E6%98%AF%E6%82%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="一个人越过越年轻是喜还是悲"><a href="#一个人越过越年轻是喜还是悲" class="headerlink" title="一个人越过越年轻是喜还是悲"></a><strong>一个人越过越年轻是喜还是悲</strong></h2><p>故事发生一战结束初期，一位名叫Gateau的知名钟表匠受邀为火车站制作一个大钟，他儿子在战争中失去了生命，他希望时间可以倒转，战争没有发生，世界和平，儿子重返家园。所以把大钟做成了倒转的模样。</p><p>就在这时，一个新生儿降临在一个有着124年做纽扣生意历史的家族中，虽是新生儿却没有那般吹弹可破的皮肤，生下来就是充满褶皱的脸，各方面都很糟糕，像极了八十岁的老人。</p><p>它一出生，她妈妈就难产死了，爸爸也因为他奇丑无比而抛弃了他，把他扔在老人院门口，襁褓里只夹带了18美分。</p><p>本杰明被好心的Queenie收养，巧的是跟一群老人生活在一起，他跟周围老人一样坐轮椅，但却像孩子一样对这个世界一无所知。他听着老人们讲述自己的一生。</p><p>等到他五岁的时候，他慢慢学会了走路。他在老人公寓遇到了后来带他开始航海之旅的船长，当船长问本杰明一生碰过几个女人时，他说一个也没有，那时的本杰明虽然长得老，但也才十几岁。船长带他去妓院爽了一把。那一夜他异常的兴奋</p><p>本杰明在老人公寓还遇到了一个眼眸无比清澈的女孩子黛西，他们在很小的就认识了。那时候本杰明外貌还是很老，但是黛西却说我觉得你跟别人不一样。</p><p>本杰明感觉自己的身体一天比一天年轻，在18岁的时候，离开了家乡，他答应黛西无论到哪里，都会给她寄明信片。本杰明随着船长去远航，期间遭遇了日本偷袭珍珠港，船长的船要做军用，而船上的水手自然而然的变成了海军，包括本杰明。有一天夜里，他们遇上了日军军船，那天晚上死了很多人。船长死了，还有一个前天夜里把自己所有积蓄拿出来托付给本杰明，叫他寄给她的妻儿，说他一直在想他们。可能由于在老人院，经历了太多周围的人的生生死死，本杰明很平静但很惋惜。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/TpYccEQe4Sdm37iY82dXvgz94s8pNTQYwAMg48vbs88!/b/dLkAAAAAAAAA&bo=OATUAgAAAAARF8o!&rf=viewer_4&t=5"></p><p>同时黛西也在慢慢长大，成了有名的芭蕾舞舞者，也与别的男孩谈过恋爱，但即使晚上睡在别人旁边，黛西也总会在睡觉前说，晚安，本杰明。直到一次意外车祸，她再也不能跳舞。本杰明千里迢迢赶过来照顾她，但黛西却赶他走，因为她看着本杰明越来越年轻英俊，而自己这般窘态。本杰明一直在暗中关心她，直到她的腿能再次下床走路。</p><p>他们在一次次错过与过错中，终于在两个人生命的中点遇见，在一切都刚刚好的时间，他们疯狂醉入爱河。两人有了小baby，是个女孩，在女孩儿满一周岁，他给她办了周岁生日party后，本杰明选择离开她们，在女儿还对他没有印象的时候。他对黛西说，我不想你到时候养两个孩子，你应该给卡洛琳找一个成熟的爸爸，而不是玩伴。他从他亲身父亲那里得到了一笔遗产，他什么都没带走，走的时候只穿走了一件夹克。就像他一出生那样，他的一生必定写满不平凡，爱而不能陪在挚爱的人身边，有着比别人多的孤独。<strong>在不顺心的时候，你可以像疯狗那样发狂，你可以破口大骂，诅咒命运，但到头来，还是得放手。</strong><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/QgIQbqM8q0EQQSt*PMqKEY4YAt*EEjc3Sh8d1YJ8xsc!/b/dLkAAAAAAAAA&bo=OASiAwAAAAARF70!&rf=viewer_4&t=5"><br>本杰明慢慢变小，慢慢地很多事都不记得了，只是一直念着黛西。他后来回到那个老人公寓，变小的本杰明变得很难管，他们后来找来黛西，黛西那时也已人入黄昏，看着小本杰明感慨万千，最后他变成婴儿，死在了黛西的怀里。本杰明给女儿写过很多信一封都没有寄出去。<br>他说：“我希望 可以领着你 上第一天学”，“我希望你伤心的时候有我安慰”，“我希望可以在你睡前吻你”，“我希望 可以在你身边 教你钢琴”，“我希望可以告诉你 别去追那邦楞头小子”，“我希望我可以当你的爸爸”。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/MnQQ.H..FNfcP3mztTF5OzkjBoWfl4r0JtIrz0aZp4Y!/b/dL8AAAAAAAAA&bo=OAQJBAAAAAARFxE!&rf=viewer_4&t=5"><br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/.X9*xY8iy0HnUi9zw1NZDQo5Krdn4ujHDgobnTh6eDQ!/b/dDYBAAAAAAAA&bo=OASiAwAAAAARF70!&rf=viewer_4&t=5"></p><p>整个电影在黛西和本杰明的女儿的叙述中娓娓道来的，在她妈妈黛西即将老死的病房里，在本杰明记录自己一生的日记本里，女孩在妈妈将死的一刻才知道这个凄美的故事。看完电影，好像走完了一生。</p><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>movies</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的个人网站(下)</title>
    <link href="/2018/12/16/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E4%B8%8B/"/>
    <url>/2018/12/16/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>本篇个人网站搭建系列博文是基于:GitHub+Hexo。<br>难度指数：♥♥<br>系统环境：win8</p><p>修饰上篇搭建的个人网站框架(包括theme主题设置、头像的设置、以及图片的显示、链接上自己的RSS)</p><h2 id="Hexo克隆主题"><a href="#Hexo克隆主题" class="headerlink" title="Hexo克隆主题"></a>Hexo克隆主题</h2><p>在初始化hexo后，也就是执行hexo init 命令后会给一个默认的主题：landscape。里面还有一篇写好的示例文章：Hello World</p><h4 id="选择喜欢的主题"><a href="#选择喜欢的主题" class="headerlink" title="选择喜欢的主题"></a>选择喜欢的主题</h4><p>觉得不喜欢可以换主题，以下链接可以供你挑选自己喜欢的主题<br><a href="https://hexo.io/themes">Themes</a></p><p>我选择的是Aisina，这里就以Aisina为例，讲主题的配置</p><h4 id="通过git命令下载"><a href="#通过git命令下载" class="headerlink" title="通过git命令下载"></a>通过git命令下载</h4><p>找到之后通过git命令下载<br>界面右侧，在主题的repository点击clone 复制一下那个地址<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/O*u6Zb9euiuiSSnDUbQKGeA0FADpHFfcQT6RASgQNwg!/b/dDQBAAAAAAAA&bo=yQRWAgAAAAADF6s!&rf=viewer_4&t=5"></p><h4 id="在你计算机本地文件夹-YUTING0907-github-io-x2F-themes-x2F-下新建一个文件夹Anisina"><a href="#在你计算机本地文件夹-YUTING0907-github-io-x2F-themes-x2F-下新建一个文件夹Anisina" class="headerlink" title="在你计算机本地文件夹 YUTING0907.github.io&#x2F;themes&#x2F; 下新建一个文件夹Anisina"></a>在你计算机本地文件夹 YUTING0907.github.io&#x2F;themes&#x2F; 下新建一个文件夹Anisina</h4><p>执行复制代码</p><pre><code class="hljs">$ git clone 复制的地址  themes/Anisina</code></pre><p>后面还可以将自己博客个性化装饰~</p><h4 id="修改整站配置文件"><a href="#修改整站配置文件" class="headerlink" title="修改整站配置文件"></a>修改整站配置文件</h4><p>配置文件是 _config.yml，在YUTING0907.github.io目录下，可以用记事本打开，但推荐用Nodepad++或者UE打开。</p><p>修订清单如下，文档内有详细注释，可按注释逐个修订</p><pre><code class="hljs"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: YUTINGsubtitle: 2019 TO BE YOUR YEARdescription: &quot;YUTING在 Github 上的个人博客&quot;keywords: MLauthor: Echo Yulanguage: zh-CNtimezone: Asia/Shanghai# custom Site settings# more detail check out docsSEOTitle: YUTING&#39;s blog header-img: //o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpgemail: YUTING9597@163.comfavicon: # your favicon png# custom end# URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://YUTING0907.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# SNS settings# RSS:weibo_username: ytfantasticzhihu_username: yu-ting-66-78github_username: YUTING0907twitter_username: YUTINGfacebook_username: YUTINGlinkedin_username:  # Build settingsanchorjs: false          # if you want to customize anchor. check out line:181 of `post.html`# Disqus settings disqus_username: # Duoshuo settingsduoshuo_username:  # 你的多说帐号# Share component is depend on Comment so we can NOT use share only.duoshuo_share: true    # set to false if you want to use Comment without Sharing# Use livereuse_livere:# Valine comment system https://valine.js.orgvaline:   enable: false  appid:  #Leancloud应用的appId  appkey:  #Leancloud应用的appKey  verify: false #验证码  notify: false #评论回复提醒  avatar: mm #评论列表默认头像样式  placeholder: Just go go #评论框占位符# Analytics settings# Baidu Analyticsba_track_id:# Google Analyticsga_track_id:             # Format: UA-xxxxxx-xxga_domain:# Featured Tagsfeatured-tags: true                     # whether or not using Feature-Tagsfeatured-condition-size: 1              # A tag will be featured if the size of it is more than this condition value# friendsfriends:  # 友链# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: false  tab_replace:   # Home page setting# path: Root path for your blogs index page. (default = &#39;&#39;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#39;&#39;  per_page: 10  order_by: -date  # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: Anisinamarkdown:  plugins:    - markdown-it-abbr    - markdown-it-footnote    - markdown-it-ins    - markdown-it-sub    - markdown-it-sup    - markdown-it-emoji# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: git@github.com:YUTING0907/YUTING0907.github.io.git  branch: master  # Qiniu imageView2 API# More info http://developer.qiniu.com/code/v6/api/kodo-api/image/imageview2.htmlclip-content: &quot;?imageView2/1/w/1400/h/400/interlace/1/q/90&quot;clip-avatar: &quot;?imageView2/2/w/300/h/300/interlace/1/q/90&quot;clip-home-post-bg: &quot;?imageView2/1/w/800/h/300/interlace/1/q/70&quot;# post default imagespost-default-img: &quot;5.gif&quot; #博文默认的图片post-default-img-mobile: #移动端显示的图片# search api , set your custom keyswiftype_key: # archive page title archive:    title: archives    description: 可以根据归档日期检索所有文件   # Sidebar settingssidebar: truesidebar-about-description: &quot;看看你的时间都花在哪了&quot;sidebar-avatar: /image/20181215001153.jpg    # img CDN pathcdn-url: &quot;http://pjqhk6p7v.bkt.clouddn.com/&quot;reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /image/WeChatQR.jpgalipay: /image/aipay.jpg  post_copyright:  enable: true   author: yuting   copyright_text: 作者拥有版权，请注明出处转载。  # create by yuting  #gitmentgitment:  #id：  owner: YUTING0907  repo: YUTING0907.github.io  client:     id: d9972ee4a19b27a1c952     secret: 717a42cc6c5bb05dbf6b53180def49e7e4e42501</code></pre><h4 id="在Github上设置OAuth-Apps"><a href="#在Github上设置OAuth-Apps" class="headerlink" title="在Github上设置OAuth Apps"></a>在Github上设置OAuth Apps</h4><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/rHYddItm.czImPrq4LkOLNBA6a4sI3MOcBU1oT*pxLc!/b/dL8AAAAAAAAA&bo=FQU5AgAAAAADFxk!&rf=viewer_4&t=5"></p><p>生成一个OAuth Apps<br>然后在 _config.yml里设置上id，secret,如下图</p><pre><code class="hljs">#gitmentgitment:  #id：  owner: YUTING0907  repo: YUTING0907.github.io  client:     id: d9972ee4a1     secret: 717a42cc6c5bb05dbf6b5318</code></pre><h4 id="启用新下载的主题"><a href="#启用新下载的主题" class="headerlink" title="启用新下载的主题"></a>启用新下载的主题</h4><p>在刚打开的的_config.yml 文件中，找到“# Extensions”，把默认主题 landscape 修改为刚刚下载下来的主题名：Aisina。</p><h4 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h4><p>git bash 里执行</p><pre><code class="hljs">$ cd themes/主题名$ git pull</code></pre><p>每次修改都要hexo g 生成一下<br>再hexo d部署一下</p><h3 id="头像设置（侧边栏的个人简介）"><a href="#头像设置（侧边栏的个人简介）" class="headerlink" title="头像设置（侧边栏的个人简介）"></a>头像设置（侧边栏的个人简介）</h3><pre><code class="hljs">Sidebar settingssidebar: truesidebar-about-description: &quot;看看你的时间都花在哪了&quot;sidebar-avatar: /image/20181215001153.jpg   </code></pre><p>sidebar-avatar后面跟的就是你想设置的头像，事先你需要把照片放在image目录下。<br>sidebar-about-description就是描述</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/SbJ1ZOnLnpvS1gm8OhOJrR7zbl5ryDTGti7fLcy7iQw!/b/dL8AAAAAAAAA&bo=6gBGAQAAAAADF58!&rf=viewer_4&t=5"></p><p>这是我设置成功后的效果。</p><h3 id="图片的显示"><a href="#图片的显示" class="headerlink" title="图片的显示"></a>图片的显示</h3><h5 id="1-1设置站点配置-config-yml"><a href="#1-1设置站点配置-config-yml" class="headerlink" title="1.1设置站点配置_config.yml"></a>1.1设置站点配置_config.yml</h5><p>post_asset_folder: true</p><h5 id="1-2-cdn-url"><a href="#1-2-cdn-url" class="headerlink" title="1.2 cdn-url"></a>1.2 cdn-url</h5><p>   注册一个你自己的七牛CDN ，然后拷贝你自己的CDN URL</p><p>在七牛里上传图片</p><p><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/mHc17tcJoHv8gOszj14QM.oRNhvP7NU8MgFoM2CTYOE!/b/dDIBAAAAAAAA&bo=DwVFAgAAAAADF38!&rf=viewer_4&t=5"></p><p>复制外链</p><p>这里可以不选择运用七牛<br>还可以安装插件</p><pre><code class="hljs">npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p> 这个插件在运行hexo n “xxxx”来生成新md博文时，&#x2F;source&#x2F;_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，你可以讲要引用的照片放在此目录下。然后只需要在xxxx.md中按照markdown的格式引入图片：</p><pre><code class="hljs">! [ 这里输入图片描述] ( xxxx/图片名.jpg )</code></pre><p>这里我没有尝试成功，我看网上有很多引用成功的都是在hexo g生成页面后，进入public文件中查看相关字段，可以发现，html标签内的语句是&lt; img src&#x3D;”…xxxx&#x2F;图片名.jpg”&gt;，而不是&lt; img src&#x3D;”xxxx&#x2F;图片名.jpg&gt;，而我生成的是&lt; img src&#x3D;”xxxx&#x2F;图片名.jpg&gt;，不知道什么原因。大家可以尝试造作一下。</p><h5 id="1-3-运用-复制过来的连接"><a href="#1-3-运用-复制过来的连接" class="headerlink" title="1.3 运用![](复制过来的连接)"></a>1.3 运用<code>![](复制过来的连接)</code></h5><p><code>![](复制过来的连接)</code>格式即可在文章中显示照片。</p><p>博文标题背景图片</p><pre><code class="hljs">header-img: &quot;http://sometest.png&quot;</code></pre><p>如果你没有设置的话，会默认使用 _config.yml 下 post-default-img指定的背景图像</p><p>使用 cdn 标签，切换单页面背景图片的URL</p><pre><code class="hljs">cdn: &#39;header-off&#39; header-img: &quot;http://www.imagestest.com/god.png&quot;</code></pre><h3 id="链接weibo，知乎，github"><a href="#链接weibo，知乎，github" class="headerlink" title="链接weibo，知乎，github"></a>链接weibo，知乎，github</h3><pre><code class="hljs"># RSS:weibo_username: ytfantasticzhihu_username: yu-ting-66-78github_username: YUTING0907twitter_username: YUTINGfacebook_username: YUTINGlinkedin_username: </code></pre><p>上述配置可以在你的网站上链接上你的weibo，知乎，github等平台页面。前提是你要设置weibo域名，知乎域名等平台域名，不懂如何设置域名可以自行百度啦<del>操作很简单的</del></p><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的个人网站(上)</title>
    <link href="/2018/12/15/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E4%B8%8A/"/>
    <url>/2018/12/15/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>本篇个人网站搭建系列博文是基于:GitHub+Hexo。<br>难度指数：♥♥<br>系统环境：win8</p><p><strong>前言：</strong>真正搭建这个网站框架的时间也就花了两个晚上，不需要你有多么深厚的编程基础，可能会遇到一些坑，就需要你遇到问题解决问题的能力了，还有搜功，因为很多你遇到的问题很多人都遇到了，太阳底下没有新鲜事儿，会搜索基本解决了大多数问题。</p><h3 id="第一步：准备必要的软件"><a href="#第一步：准备必要的软件" class="headerlink" title="第一步：准备必要的软件"></a>第一步：准备必要的软件</h3><p><strong>1.Git下载</strong><br>     <a href="https://git-scm.com/downloads">Git</a>,选择适合自己电脑的环境，一路Next下来就行了。</p><p><strong>2、安装node.js</strong><br>    <a href="http://nodejs.cn/">node.js</a>,也是基于自己的电脑环境选择下载，下载最新版本，在Windows安装时务必选择全部组件，包括勾选<code>Add to Path</code>。安装完成后，在Windows环境下，打开命令行提示符，输入<code>node -v</code>，看到版本号正常输出，则安装完成。<br>           <img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/rm7.QvW1mxRhb6sdXnYhiskAulDc0JF9F0bBkPmX50s!/b/dFYBAAAAAAAA&bo=4AAqAAAAAAADF*g!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><h3 id="第二步：Github注册与配置"><a href="#第二步：Github注册与配置" class="headerlink" title="第二步：Github注册与配置"></a>第二步：Github注册与配置</h3><h4 id="1-注册Github"><a href="#1-注册Github" class="headerlink" title="1.注册Github"></a>1.注册Github</h4><p>点击→<a href="https://github.com/">https://github.com</a>右上角sign up<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/5x0MOWtEd4jqwAH5TXRe1qhXefHiOiLCsLpl0vLFZ04!/b/dFQBAAAAAAAA&bo=eQRqAgAAAAADFyc!&rf=viewer_4&t=5" alt="在这里插入图片描述"><br>注册完成后，记住自己的用户名，因为后续个人网站的网址格式为：username.github.io<br>这个username就是你的github用户名。<br>这里我的GitHub账号是：YUTING0907<br>个人网站：YUTING0907.github.io<br>你后续也可以自己绑定域名，叫个更炫酷的名字XXX.com</p><h4 id="2-创建Repository"><a href="#2-创建Repository" class="headerlink" title="2.创建Repository"></a>2.创建Repository</h4><p>登陆GitHub，点击右上角的+，会出现New repository创建一个与你博客相关你的Repository进行管理，之后你的博客都会在GitHub的这个Repository里同步更新。<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/*bhCJMsQQlH5*0hTH7p1in230nG62njUjBHVSaqhKn0!/b/dD4BAAAAAAAA&bo=DQVSAgAAAAADF2o!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><p>Repository的名字是username.github.io，比如我的YUTING0907.github.io。其余可以先不填，点击Create repository</p><h4 id="3-配置SSH-Keys"><a href="#3-配置SSH-Keys" class="headerlink" title="3.配置SSH Keys"></a>3.配置SSH Keys</h4><p>SSH Keys用来使本地git项目与GitHub联系，这样能在GitHub上的博客项目是最新更新的。</p><p>检查SSH Keys的设置<br><strong>I. 开始–所有应用–找到git bash</strong></p><p><strong>II. 检查你电脑里现有的SSH Key</strong><br>   $ cd ~&#x2F;.ssh<br>如果显示 No such file or directory，说明这是你第一次用git<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/3KDk1iRk5gEdR1LEgUg.TqHLInCwu2ZEY7D9QyUCZ*4!/b/dAgBAAAAAAAA&bo=NAE5AAAAAAADFz4!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><p><strong>III. 接下来生成新的SSH Key:</strong><br>$ ssh-keygen -t rsa -C “邮件地址”<br>Generating public&#x2F;private rsa key pair.<br>Enter file in which to save the key (&#x2F;Users&#x2F;your_user_directory&#x2F;.ssh&#x2F;id_rsa):&lt;回车就好&gt;</p><p>这里的邮箱地址，输入注册 Github 的邮箱地址</p><p> 然后系统会要你输入密码：<br>Enter passphrase (empty for no passphrase):&lt;设置密码&gt;<br>Enter same passphrase again:&lt;再次输入密码&gt;</p><p>再回车，这里会提示你输入一个密码，作为你提交项目时使用</p><p><strong>注意：</strong>输入密码的时候没有输入痕迹的，不要以为什么也没有输入。<br>最后看到这样的界面，就成功设置ssh key了：<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/mYRnwZ8YFWIqmMRyqUbc5ob0slTpOiDo96NSAVjeo08!/b/dLwAAAAAAAAA&bo=5gEpAQAAAAADF*0!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><h4 id="IV-添加SSH-Key到GitHub上"><a href="#IV-添加SSH-Key到GitHub上" class="headerlink" title="IV. 添加SSH Key到GitHub上"></a>IV. 添加SSH Key到GitHub上</h4><p>在本地文件夹找到id_rsa.pub文件，看上面的图片第四行的位置告诉你存在哪里了，没有的话可能是隐藏了，勾选一下文件扩展名 隐藏的项目。</p><p>回到你的GitHub主页，右上角点击头像选中Setting</p><p>继续选中左边菜单栏的SSH and GPG keys</p><p>Title最好写，随便写。否则可能出现各种各样的二逼问题<br>Key部分就是放刚才复制的内容了，点击Add SSH key</p><h4 id="V-测试"><a href="#V-测试" class="headerlink" title="V.测试"></a>V.测试</h4><p>git bash里输入代码：<code>$ ssh -T git@github.com</code> </p><pre><code class="hljs">The authenticity of host &#39;GitHub.com (52.74.227.119)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)</code></pre><p>输入yes，回车<br>按照提示输入刚才设置的密码，回车<br>You’ve successfully authenticated…<br>设置成功！</p><h4 id="VI-设置用户信息"><a href="#VI-设置用户信息" class="headerlink" title="VI.设置用户信息"></a>VI.设置用户信息</h4><pre><code class="hljs">$ git config --global user.name &quot;YUTING0907&quot; </code></pre><p>&#x2F;&#x2F;输入注册时的username</p><pre><code class="hljs">$ git config --global user.email  &quot;YUTING9597@163.COM&quot; </code></pre><p>&#x2F;&#x2F;填写注册邮箱<br>把名称和邮箱替换成你自己的,SSH Key就配置成功啦！<br>本机已成功连接到 github。</p><h3 id="第三步：搭建Hexo博客"><a href="#第三步：搭建Hexo博客" class="headerlink" title="第三步：搭建Hexo博客"></a>第三步：搭建Hexo博客</h3><p><strong>利用npm命令安装hexo</strong><br>npm Node Package Manager是随同NodeJS一起安装的包管理工具，想了解更多可以自行去百度。</p><pre><code class="hljs">$ npm install -g hexo</code></pre><p>安装完成后，在本地创建一个与 Repository中博客项目同名的文件夹username.github.io(如D:&#x2F;YUTING0907.github.io)在文件夹上点击鼠标右键,选择 Git bash here（可以代替命令行指示符的存在~）,【这一步的作用是因为以后博客部署和更新都要在此文件夹下】</p><p><strong>hexo初始化</strong></p><pre><code class="hljs">hexo init</code></pre><p><strong>安装依赖包</strong></p><pre><code class="hljs">$ npm install</code></pre><p>这里我踩坑了，<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/95hREaV7iXFGebAzGGu01Ayke2nVXhftPOPm1vntWyg!/b/dL8AAAAAAAAA&bo=rQFfAQAAAAADF8A!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><p>然后上百度、google各种找解决办法，后来发现是因为<br>Your versions of node and npm are years old and no longer supported。版本太低了，后来更新node.js版本就好了.<br><a href="https://github.com/npm/npm/issues/8488">npm install 报错解决办法</a><br>这里放上更新node.js的方法<br>方法一：执行下列代码</p><pre><code class="hljs">npm install npm@latest -g</code></pre><p>但我的电脑出现了如下报错，如有朋友出现更新错误，课移步方法二。<br>C:\Users\lenovo\AppData\Roaming\npm\node_modules\npm\bin\npm-cli.js:79<br>      let notifier &#x3D; require(‘update-notifier’)({pkg})<br>      ^^^<br>方法二:<br>1.到node官网（<a href="https://nodejs.org/en/%EF%BC%89">https://nodejs.org/en/）</a><br>下载最新版或者官网推荐版本，我下载的是10.14.1。</p><p>2.将下载的文件安装到之前安装node.js的地方<br>通过where node命令查看node路径<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/IPFuuHtZ8RT5DD1PnwVAUJeaBY3smLyDDB3Yvka.x4g!/b/dL4AAAAAAAAA&bo=AQEoAAAAAAADFxo!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><p>将刚刚下载的文件放到上面查到的路径中<br>双击刚刚下载的文件,点击next 具体安装方法和之前第一次安装一样，但是【<strong>注意在选择路径的时候要选成上面查到的node路径中</strong>】</p><p>3.安装完成。通过npm -v和node -v查看当前版本号</p><p><strong>确保git部署</strong></p><pre><code class="hljs">$ npm install hexo-deployer-git --save</code></pre><p><strong>本地查看</strong><br>做到这里恭喜你😀，现在已经搭建好本地的 Hexo 博客了，执行完下面的命令就可以到浏览器输入 localhost:4000 查看到啦！<br>$ hexo g   &#x2F;&#x2F;生成更新网站<br>$ hexo s   &#x2F;&#x2F;这一步是让你可以在本地localhost:4000可以浏览网站，一个服务预览的作用，退出服务按ctrl+c<br>$ hexo d &#x2F;&#x2F;部署网站</p><p>【小提醒】如果在配置 SSH key 时设置了密码，执行 hexo d 命令上传文件时需要输入密码进行确认，会出现一个小框框，让你输入密码，你输入密码即可部署更新。</p><p>执行完 hexo init 命令后会给一个默认的主题：landscape</p><h3 id="最后一步：将博客部署到username-github-io"><a href="#最后一步：将博客部署到username-github-io" class="headerlink" title="最后一步：将博客部署到username.github.io"></a>最后一步：将博客部署到username.github.io</h3><p><strong>复制SSH码</strong></p><p>进入 Github 个人主页中的 Repository，复制新建的独立博客项目username.github.io的 SSH码<br><img src="http://m.qpic.cn/psb?/V10c1VbY1Y4Fvm/3S8S4ph4RLihnpcoxSNWWtYoCcwUhNHDmmzmJVypCeQ!/b/dLgAAAAAAAAA&bo=cgQpAgAAAAADF28!&rf=viewer_4&t=5" alt="在这里插入图片描述"></p><p><strong>编辑整站配置文件</strong><br>打开 D:&#x2F;username.github.io&#x2F;_config.yml,把刚刚复制的 SSH码粘贴到repository：后面</p><pre><code class="hljs">deploy:  type: git  repository: git@github.com:username/username.github.io.git  branch: master</code></pre><p>冒号后一定要空一格。否则会报FATAL can not read a block mapping entry的错。</p><p>当当当当~~到这里你已经拥有一个属于自己的网站，可能有点简陋，但是整个框架已经搭起来了。期待下一篇把网站拾掇得更好吧。</p><p>搭建参考：<br><a href="http://codewithzhangyi.com/archives/">如何搭建自己的个人网站</a></p><p><a href="https://blog.csdn.net/H_duolalu/article/details/80215580">更新node</a></p><p><a href="https://github.com/npm/npm/issues/8488">npm install错误</a></p><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019 do better</title>
    <link href="/2018/12/12/article/"/>
    <url>/2018/12/12/article/</url>
    
    <content type="html"><![CDATA[<p>回头想想今年都干了些什么，学了理财，知道了怎么投资指数基金，还看了很多理财方面的<br>经典书籍，搭建了属于自己的理财框架，不过还没开始认真看研究报告，等得我慢慢爬进自<br>己想进去的专业领域之后，再来慢慢分析上市公司，慢慢看研报。<br>报了EF的英语课，每天下班泡EF，跟老外说着蹩脚的英文还挺有意思的，关键更有趣的是你<br>可以每天见不同的人,有意大利五星厨师，短跑运动员，各种hr，hunter….期待自己能说出一口流利英语的时刻。<br>自己专业领域这一块，把NG的ML重新实现了一遍，后面要做的就是多参加比赛和复现大佬的项目代码了。<br>还做了一个重要的决定，可能是改变生活轨迹的决定，但是这一刻不后悔就好!</p><iframe src="https://rawcdn.githack.com/YUTING0907/donate-page-yu/df1732a5993401f9d372918c3f7680ca0e1c2ca3/simple/index.html " style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
